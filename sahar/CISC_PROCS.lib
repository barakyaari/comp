With problems:

NOT:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	MOV(R1, 0);
	MOV(R1, FPARG(2));
	CMP(INDD(R1, 0), T_BOOL);
	JUMP_NE(NOT_RETURN_FALSE);
 	CMP(R1, IMM(FALSE));
 	JUMP_EQ(NOT_RETURN_TRUE);
NOT_RETURN_FALSE:
 	MOV(R0,IMM(FALSE));
 	JUMP(NOT_END);
NOT_RETURN_TRUE:
 	MOV(R0,IMM(TRUE));
NOT_END:
 	POP(R1);
 	POP(FP);
 	RETURN;

/*** TODO: Go over this ***/
APPLY_TC:
	PUSH(FP);
	MOV(FP, SP);
	
	/* R1 is the function */
	MOV(R1, FPARG(2));	
	CMP(IND(R1), T_CLOSURE);
	JUMP_NE(ERROR);
	
	/* R2 hold the list of params */
	MOV(R2, FPARG(3));	

	PUSH(R2);
	PUSH(1);
	PUSH(0);
	CALL(LIST_LENGTH);
	DROP(IMM(3));
	
	/* R3 holld the new list length */
	MOV(R3, INDD(R0, 1));

	CMP(R3, 0);
	
	/* check if the list empty */
	JUMP_NE(APPLY_TC_LIST_NOT_EMPTY);
	
	/* else push 0 as the number of args .. */
	PUSH(IMM(0));
	JUMP(APPLY_TC_REVERSE_LIST_END); /* NO NEED TO COPY AND REVERS PARAMS */

APPLY_TC_LIST_NOT_EMPTY:
	MOV(R4, 0);
	MOV(R5, 1);
APPLY_TC_LOOP_REVERSE:
	CMP(R4, R3);
	JUMP_EQ(APPLY_TC_REVERSE_LIST_END);
	PUSH(R2);
	MOV(R6, R3);
	SUB(R6, R5);
	PUSH(R6);
	CALL(LIST_REF);
	DROP(2);
	PUSH(INDD(R0, 1));
	ADD(R4, IMM(1));
	ADD(R5, IMM(1));
	JUMP(APPLY_TC_LOOP_REVERSE);

APPLY_TC_REVERSE_LIST_END: 
	/* number of params */
	PUSH(R3);
	/* func env ... */
	PUSH(INDD(R1, 1));
	
	/* NEW CHANGES .... */
	/*  Push the return address from current frame */
	PUSH(FPARG(-1));
						
	/* R8 hold the old fp */
	MOV(R8,FPARG(-2));
	/* R12 hold the old num of arg */
	MOV(R12,FPARG(1));
	/* R13 hold the new num of arg */
	MOV(R13,STARG(1));
						
	/* R6 will old the STARG offset */
	MOV(R6, R3);
	ADD(R6, 1);	
						
	/* R5 will old the FPARG offset */
	MOV(R5, R12);
	ADD(R5, IMM(1));

	/* R4 is the running index */
	MOV(R4, IMM(0));
	
	/* R14 is the number of copy */
	MOV(R14, R3);
	ADD(R14, 3);
	
APPLY_TC_FIX_STACK:
	CMP(R4, R14);
	JUMP_EQ(APPLY_TC_FIX_STACK_EXIT);
	MOV(FPARG(R5), STARG(R6));
	SUB(R6, IMM(1));
	SUB(R5, IMM(1));
	ADD(R4, IMM(1));
	JUMP(APPLY_TC_FIX_STACK);
APPLY_TC_FIX_STACK_EXIT:
	MOV(R9, R13);
	SUB(R9, IMM(1));
	SUB(R9, R12);
	MOV(SP, FP);
	ADD(SP, R9);
	MOV(FP, R8);
	JUMPA(INDD(R1, 2));
	JUMP(ERROR);
	
	/* call func body */ 
	CALLA(INDD(R1, 2));
	/* drop the parameters and env and num of params ... */
	MOV(R1, STARG(0));
	ADD(R1, IMM(2));	
	DROP(R1);
	JUMP(END);


Removed:

/**** > var ****/
/**** R1 = Accumulator, R2 = Num of loops, R3 = Index****/
VAR_GREATERTHAN:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	PUSH(R4);
	MOV(R1, 0);
	MOV(R2, 0);
	MOV(R2, FPARG(NUMOFARGS));
	ADD(R2, 2);
	MOV(R3, 2); 	
VAR_GREATERTHAN_LOOP:
	CMP(R2, R3);
	JUMP_EQ(VAR_GREATERTHAN_END);
	CMP(R3, 2);
	JUMP_NE(VAR_GREATERTHAN_LOOP2);
	MOV(R4, FPARG(R3));
	MOV(R1, INDD(R4, 1));
	ADD(R3, 1);
	JUMP(VAR_GREATERTHAN_LOOP);
VAR_GREATERTHAN_LOOP2:
	MOV(R4, FPARG(R3));
	CMP(R1, INDD(R4, 1));
	JUMP_LE(VAR_GREATERTHAN_END);
	ADD(R3, 1);
	MOV(R1, INDD(R4, 1));
	JUMP(VAR_GREATERTHAN_LOOP);
VAR_GREATERTHAN_END:
	CMP(R2, R3);
	POP(R4);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(CHECK_BOOL_RESULT);



/**** < var ****/
/**** R1 = Accumulator, R2 = Num of loops, R3 = Index****/
VAR_LESSTHAN:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	PUSH(R4);
	MOV(R1, 0);
	MOV(R2, 0);
	MOV(R2, FPARG(NUMOFARGS));
	ADD(R2, 2);
	MOV(R3, 2); 	
VAR_LESSTHAN_LOOP:
	CMP(R2, R3);
	JUMP_EQ(VAR_LESSTHAN_END);
	CMP(R3, 2);
	JUMP_NE(VAR_LESSTHAN_LOOP2);
	MOV(R4, FPARG(R3)); /**** Scheme int ****/
	MOV(R1, INDD(R4, 1)); /**** Scheme int number ****/ 	
	ADD(R3, 1);
	JUMP(VAR_LESSTHAN_LOOP);
VAR_LESSTHAN_LOOP2:
	MOV(R4, FPARG(R3)); /**** Scheme int ****/
	CMP(R1, INDD(R4, 1)); /**** Scheme int number ****/  
	JUMP_GE(VAR_LESSTHAN_END);
	ADD(R3, 1);
	MOV(R1, INDD(R4, 1));
	JUMP(VAR_LESSTHAN_LOOP);
VAR_LESSTHAN_END:
	CMP(R2, R3);
	POP(R4);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(CHECK_BOOL_RESULT);


/**** = var ****/
/**** R1 = Accumulator, R2 = Num of loops, R3 = Index****/
VAR_EQUAL:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	PUSH(R4);
	MOV(R1, 0);
	MOV(R2, 0);
	MOV(R2, FPARG(NUMOFARGS));
	ADD(R2, 2);
	MOV(R3, 2); 	
VAR_EQUAL_LOOP:
	CMP(R2, R3);
	JUMP_EQ(VAR_EQUAL_END);
	CMP(R3, 2);
	JUMP_NE(VAR_EQUAL_LOOP2);
	MOV(R4, FPARG(R3)); 
	MOV(R1, INDD(R4, 1)); 	
	ADD(R3, 1);
	JUMP(VAR_EQUAL_LOOP);
VAR_EQUAL_LOOP2:
	MOV(R4, FPARG(R3));
	CMP(R1, INDD(R4, 1)); 
	JUMP_NE(VAR_EQUAL_END);
	ADD(R3, 1);
	JUMP(VAR_EQUAL_LOOP);
VAR_EQUAL_END:
	CMP(R2, R3);
	POP(R4);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(CHECK_BOOL_RESULT);




/** TODO: Check for fractions/rationals what happens **/
EQ:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	PUSH(R4);
	PUSH(R5);	
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R2, FPARG(3));
	CMP(INDD(R1, 0), INDD(R2, 0));
	JUMP_NE(EQ_RETURN_FALSE);	
	CMP(INDD(R1, 0), T_PAIR);
	JUMP_EQ(EQ_ADDRESS);
	CMP(INDD(R1, 0), T_STRING);
	JUMP_EQ(EQ_ADDRESS);	
	CMP(INDD(R1, 0), T_VECTOR);
	JUMP_EQ(EQ_ADDRESS);		
	CMP(INDD(R1, 0), T_CLOSURE);
	JUMP_EQ(EQ_ADDRESS);	
	CMP(INDD(R1, 0), T_INTEGER);
	JUMP_EQ(EQ_VALUE);
	CMP(INDD(R1, 0), T_CHAR);
	JUMP_EQ(EQ_VALUE);
	CMP(INDD(R1, 0), T_SYMBOL);
	JUMP_EQ(EQ_VALUE);	
	CMP(INDD(R1, 0), T_BOOL);
	JUMP_EQ(EQ_VALUE);		
	CMP(INDD(R1, 0), T_VOID);
	JUMP_EQ(EQ_RETURN_TRUE);	
	CMP(INDD(R1, 0), T_NIL);
	JUMP_EQ(EQ_RETURN_TRUE);		
	JUMP(EQ_RETURN_FALSE);
EQ_VALUE:		
	CMP(INDD(R1, 1), INDD(R2, 1));
	JUMP_EQ(EQ_RETURN_TRUE);
	JUMP(EQ_RETURN_FALSE);
EQ_ADDRESS:	
	CMP(R1, R2);
	JUMP_EQ(EQ_RETURN_TRUE);
	JUMP(EQ_RETURN_FALSE);
EQ_RETURN_FALSE:
	MOV(R0, SOB_FALSE);
	JUMP(EQ_END);
EQ_RETURN_TRUE:
	MOV(R0, SOB_TRUE);
	JUMP(EQ_END);	
EQ_END:
	POP(R5);
	POP(R4);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(END);



	
/**** / var ****/
/**** R1 = Accumulator, R2 = Num of loops, R3 = Index****/
VAR_DIV:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	PUSH(R4);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, 1);
	MOV(R2, FPARG(NUMOFARGS));
	CMP(R2, 1);
	JUMP_NE(VAR_DIV_MORE_THAN_ONE_ARG);
	MOV(R1, 1);
	DIV(R1, INDD(FPARG(2), 1));
	JUMP(VAR_DIV_END);
VAR_DIV_MORE_THAN_ONE_ARG:
	ADD(R2, 2);
	MOV(R3, 2); 	
VAR_DIV_LOOP:
	CMP(R2, R3);
	JUMP_EQ(VAR_DIV_END);
	CMP(R3, 2);
	JUMP_NE(VAR_DIV_LOOP2);
	MOV(R4, FPARG(R3));
	MOV(R1, INDD(R4, 1));	
	ADD(R3, 1);
	JUMP(VAR_DIV_LOOP);
VAR_DIV_LOOP2:
	MOV(R4, FPARG(R3));
	DIV(R1, INDD(R4, 1));
	ADD(R3, 1);
	JUMP(VAR_DIV_LOOP);
VAR_DIV_END:
	PUSH(R1);
	CALL(MAKE_SOB_INTEGER);
	DROP(1); 
	POP(R4);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(END);
	



/**** * var ****/
/**** R1 = Accumulator, R2 = Num of loops, R3 = Index****/
VAR_MUL:
	PUSH(FP);
	MOV(FP, SP);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, 1);
	MOV(R2, FPARG(NUMOFARGS));
	ADD(R2, 2);
	MOV(R3, 2); 	
VAR_MUL_LOOP:
	CMP(R2, R3);
	JUMP_EQ(VAR_MUL_END);
	MOV(R4, FPARG(R3));
	MUL(R1, INDD(R4, 1));
	ADD(R3, 1);
	JUMP(VAR_MUL_LOOP);
VAR_MUL_END:
	PUSH(R1);
	CALL(MAKE_SOB_INTEGER);
	DROP(1); 
	JUMP(END);





/**** - var ****/
/**** R1 = Accumulator, R2 = Num of loops, R3 = Index****/
VAR_MIN:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	PUSH(R4);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R2, FPARG(NUMOFARGS));
	CMP(R2, 1);
	JUMP_NE(VAR_MIN_MORE_THAN_ONE_ARG);
	MOV(R1, 0);
	SUB(R1, INDD(FPARG(2), 1));
	JUMP(VAR_MIN_END);
VAR_MIN_MORE_THAN_ONE_ARG:
	ADD(R2, 2);
	MOV(R3, 2); 	
VAR_MIN_LOOP:
	CMP(R2, R3);
	JUMP_EQ(VAR_MIN_END);
	CMP(R3, 2);
	JUMP_NE(VAR_MIN_LOOP2);
	MOV(R4, FPARG(R3)); 
	MOV(R1, INDD(R4, 1)); 
	ADD(R3, 1);
	JUMP(VAR_MIN_LOOP);
VAR_MIN_LOOP2:
	MOV(R4, FPARG(R3)); 
	SUB(R1, INDD(R4, 1)); 
	ADD(R3, 1);
	JUMP(VAR_MIN_LOOP);
VAR_MIN_END:
	PUSH(R1);
	CALL(MAKE_SOB_INTEGER);
	DROP(1); 
	POP(R4);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(END);


/**** + var ****/
/**** R1 = Accumulator, R2 = Num of loops, R3 = Index****/
VAR_PLUS:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	PUSH(R4);
	MOV(R1, 0);
	MOV(R2, 0);
	MOV(R2, FPARG(NUMOFARGS));
	ADD(R2, 2);
	MOV(R3, 2); 	
VAR_PLUS_LOOP:
	CMP(R2, R3);
	JUMP_EQ(VAR_PLUS_END);
	MOV(R4, FPARG(R3));
	ADD(R1, INDD(R4, 1));
	ADD(R3, 1);
	JUMP(VAR_PLUS_LOOP);
VAR_PLUS_END:
	PUSH(R1);
	CALL(MAKE_SOB_INTEGER);
	DROP(1); 
	POP(R4);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(END);

