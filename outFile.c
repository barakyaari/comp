#include <stdio.h>
#include <stdlib.h>
#define DO_SHOW 1
#include "arch/cisc.h"
#include "arch/debug_macros.h"
int main() {
#define TRUE 5
#define FALSE 3
#define SOB_NIL 2
#define SOB_VOID 1
#define LOC_ENV 0
#define NUMOFARGS 1
#define SYM_TAB_START 1309 
START_MACHINE;
JUMP(LETS_START);
#include "arch/char.lib"
#include "arch/io.lib"
#include "arch/scheme.lib"
#include "arch/math.lib"
#include "arch/string.lib"
#include "arch/system.lib"
#include "arch/project_proc.lib"
ERROR:
HALT;
LETS_START:
PUSH(0);
PUSH(0);
PUSH(0);
PUSH(FP);
MOV(FP, SP);
MOV(IND(0), IMM(1159));
MOV(IND(IMM(1)), IMM(937610));
MOV(IND(IMM(2)), IMM(722689));
MOV(IND(IMM(3)), IMM(741553));
MOV(IND(IMM(4)), IMM(0));
MOV(IND(IMM(5)), IMM(741553));
MOV(IND(IMM(6)), IMM(1));
MOV(IND(IMM(10)), IMM(799345));
MOV(IND(IMM(11)), IMM(3));
MOV(IND(IMM(12)), IMM(109));
MOV(IND(IMM(13)), IMM(97));
MOV(IND(IMM(14)), IMM(112));
MOV(IND(IMM(15)), IMM(799345));
MOV(IND(IMM(16)), IMM(6));
MOV(IND(IMM(17)), IMM(97));
MOV(IND(IMM(18)), IMM(112));
MOV(IND(IMM(19)), IMM(112));
MOV(IND(IMM(20)), IMM(101));
MOV(IND(IMM(21)), IMM(110));
MOV(IND(IMM(22)), IMM(100));
MOV(IND(IMM(23)), IMM(799345));
MOV(IND(IMM(24)), IMM(6));
MOV(IND(IMM(25)), IMM(99));
MOV(IND(IMM(26)), IMM(97));
MOV(IND(IMM(27)), IMM(97));
MOV(IND(IMM(28)), IMM(97));
MOV(IND(IMM(29)), IMM(97));
MOV(IND(IMM(30)), IMM(114));
MOV(IND(IMM(31)), IMM(799345));
MOV(IND(IMM(32)), IMM(6));
MOV(IND(IMM(33)), IMM(99));
MOV(IND(IMM(34)), IMM(100));
MOV(IND(IMM(35)), IMM(100));
MOV(IND(IMM(36)), IMM(100));
MOV(IND(IMM(37)), IMM(100));
MOV(IND(IMM(38)), IMM(114));
MOV(IND(IMM(39)), IMM(799345));
MOV(IND(IMM(40)), IMM(6));
MOV(IND(IMM(41)), IMM(99));
MOV(IND(IMM(42)), IMM(97));
MOV(IND(IMM(43)), IMM(100));
MOV(IND(IMM(44)), IMM(100));
MOV(IND(IMM(45)), IMM(100));
MOV(IND(IMM(46)), IMM(114));
MOV(IND(IMM(47)), IMM(799345));
MOV(IND(IMM(48)), IMM(6));
MOV(IND(IMM(49)), IMM(99));
MOV(IND(IMM(50)), IMM(97));
MOV(IND(IMM(51)), IMM(97));
MOV(IND(IMM(52)), IMM(100));
MOV(IND(IMM(53)), IMM(100));
MOV(IND(IMM(54)), IMM(114));
MOV(IND(IMM(55)), IMM(799345));
MOV(IND(IMM(56)), IMM(6));
MOV(IND(IMM(57)), IMM(99));
MOV(IND(IMM(58)), IMM(97));
MOV(IND(IMM(59)), IMM(97));
MOV(IND(IMM(60)), IMM(97));
MOV(IND(IMM(61)), IMM(100));
MOV(IND(IMM(62)), IMM(114));
MOV(IND(IMM(63)), IMM(799345));
MOV(IND(IMM(64)), IMM(5));
MOV(IND(IMM(65)), IMM(99));
MOV(IND(IMM(66)), IMM(97));
MOV(IND(IMM(67)), IMM(97));
MOV(IND(IMM(68)), IMM(97));
MOV(IND(IMM(69)), IMM(114));
MOV(IND(IMM(70)), IMM(799345));
MOV(IND(IMM(71)), IMM(5));
MOV(IND(IMM(72)), IMM(99));
MOV(IND(IMM(73)), IMM(100));
MOV(IND(IMM(74)), IMM(100));
MOV(IND(IMM(75)), IMM(100));
MOV(IND(IMM(76)), IMM(114));
MOV(IND(IMM(77)), IMM(799345));
MOV(IND(IMM(78)), IMM(5));
MOV(IND(IMM(79)), IMM(99));
MOV(IND(IMM(80)), IMM(97));
MOV(IND(IMM(81)), IMM(100));
MOV(IND(IMM(82)), IMM(100));
MOV(IND(IMM(83)), IMM(114));
MOV(IND(IMM(84)), IMM(799345));
MOV(IND(IMM(85)), IMM(5));
MOV(IND(IMM(86)), IMM(99));
MOV(IND(IMM(87)), IMM(97));
MOV(IND(IMM(88)), IMM(97));
MOV(IND(IMM(89)), IMM(100));
MOV(IND(IMM(90)), IMM(114));
MOV(IND(IMM(91)), IMM(799345));
MOV(IND(IMM(92)), IMM(4));
MOV(IND(IMM(93)), IMM(99));
MOV(IND(IMM(94)), IMM(100));
MOV(IND(IMM(95)), IMM(100));
MOV(IND(IMM(96)), IMM(114));
MOV(IND(IMM(97)), IMM(799345));
MOV(IND(IMM(98)), IMM(4));
MOV(IND(IMM(99)), IMM(99));
MOV(IND(IMM(100)), IMM(97));
MOV(IND(IMM(101)), IMM(100));
MOV(IND(IMM(102)), IMM(114));
MOV(IND(IMM(103)), IMM(799345));
MOV(IND(IMM(104)), IMM(4));
MOV(IND(IMM(105)), IMM(99));
MOV(IND(IMM(106)), IMM(97));
MOV(IND(IMM(107)), IMM(97));
MOV(IND(IMM(108)), IMM(114));
MOV(IND(IMM(109)), IMM(799345));
MOV(IND(IMM(110)), IMM(3));
MOV(IND(IMM(111)), IMM(101));
MOV(IND(IMM(112)), IMM(113));
MOV(IND(IMM(113)), IMM(63));
MOV(IND(IMM(114)), IMM(799345));
MOV(IND(IMM(115)), IMM(14));
MOV(IND(IMM(116)), IMM(115));
MOV(IND(IMM(117)), IMM(116));
MOV(IND(IMM(118)), IMM(114));
MOV(IND(IMM(119)), IMM(105));
MOV(IND(IMM(120)), IMM(110));
MOV(IND(IMM(121)), IMM(103));
MOV(IND(IMM(122)), IMM(45));
MOV(IND(IMM(123)), IMM(62));
MOV(IND(IMM(124)), IMM(115));
MOV(IND(IMM(125)), IMM(121));
MOV(IND(IMM(126)), IMM(109));
MOV(IND(IMM(127)), IMM(98));
MOV(IND(IMM(128)), IMM(111));
MOV(IND(IMM(129)), IMM(108));
MOV(IND(IMM(130)), IMM(799345));
MOV(IND(IMM(131)), IMM(14));
MOV(IND(IMM(132)), IMM(115));
MOV(IND(IMM(133)), IMM(121));
MOV(IND(IMM(134)), IMM(109));
MOV(IND(IMM(135)), IMM(98));
MOV(IND(IMM(136)), IMM(111));
MOV(IND(IMM(137)), IMM(108));
MOV(IND(IMM(138)), IMM(45));
MOV(IND(IMM(139)), IMM(62));
MOV(IND(IMM(140)), IMM(115));
MOV(IND(IMM(141)), IMM(116));
MOV(IND(IMM(142)), IMM(114));
MOV(IND(IMM(143)), IMM(105));
MOV(IND(IMM(144)), IMM(110));
MOV(IND(IMM(145)), IMM(103));
MOV(IND(IMM(146)), IMM(799345));
MOV(IND(IMM(147)), IMM(6));
MOV(IND(IMM(148)), IMM(108));
MOV(IND(IMM(149)), IMM(101));
MOV(IND(IMM(150)), IMM(110));
MOV(IND(IMM(151)), IMM(103));
MOV(IND(IMM(152)), IMM(116));
MOV(IND(IMM(153)), IMM(104));
MOV(IND(IMM(154)), IMM(799345));
MOV(IND(IMM(155)), IMM(5));
MOV(IND(IMM(156)), IMM(97));
MOV(IND(IMM(157)), IMM(112));
MOV(IND(IMM(158)), IMM(112));
MOV(IND(IMM(159)), IMM(108));
MOV(IND(IMM(160)), IMM(121));
MOV(IND(IMM(161)), IMM(799345));
MOV(IND(IMM(162)), IMM(6));
MOV(IND(IMM(163)), IMM(118));
MOV(IND(IMM(164)), IMM(101));
MOV(IND(IMM(165)), IMM(99));
MOV(IND(IMM(166)), IMM(116));
MOV(IND(IMM(167)), IMM(111));
MOV(IND(IMM(168)), IMM(114));
MOV(IND(IMM(169)), IMM(799345));
MOV(IND(IMM(170)), IMM(4));
MOV(IND(IMM(171)), IMM(108));
MOV(IND(IMM(172)), IMM(105));
MOV(IND(IMM(173)), IMM(115));
MOV(IND(IMM(174)), IMM(116));
MOV(IND(IMM(175)), IMM(799345));
MOV(IND(IMM(176)), IMM(8));
MOV(IND(IMM(177)), IMM(115));
MOV(IND(IMM(178)), IMM(101));
MOV(IND(IMM(179)), IMM(116));
MOV(IND(IMM(180)), IMM(45));
MOV(IND(IMM(181)), IMM(99));
MOV(IND(IMM(182)), IMM(97));
MOV(IND(IMM(183)), IMM(114));
MOV(IND(IMM(184)), IMM(33));
MOV(IND(IMM(185)), IMM(799345));
MOV(IND(IMM(186)), IMM(8));
MOV(IND(IMM(187)), IMM(115));
MOV(IND(IMM(188)), IMM(101));
MOV(IND(IMM(189)), IMM(116));
MOV(IND(IMM(190)), IMM(45));
MOV(IND(IMM(191)), IMM(99));
MOV(IND(IMM(192)), IMM(100));
MOV(IND(IMM(193)), IMM(114));
MOV(IND(IMM(194)), IMM(33));
MOV(IND(IMM(195)), IMM(799345));
MOV(IND(IMM(196)), IMM(3));
MOV(IND(IMM(197)), IMM(99));
MOV(IND(IMM(198)), IMM(100));
MOV(IND(IMM(199)), IMM(114));
MOV(IND(IMM(200)), IMM(799345));
MOV(IND(IMM(201)), IMM(3));
MOV(IND(IMM(202)), IMM(99));
MOV(IND(IMM(203)), IMM(97));
MOV(IND(IMM(204)), IMM(114));
MOV(IND(IMM(205)), IMM(799345));
MOV(IND(IMM(206)), IMM(4));
MOV(IND(IMM(207)), IMM(99));
MOV(IND(IMM(208)), IMM(111));
MOV(IND(IMM(209)), IMM(110));
MOV(IND(IMM(210)), IMM(115));
MOV(IND(IMM(211)), IMM(799345));
MOV(IND(IMM(212)), IMM(11));
MOV(IND(IMM(213)), IMM(109));
MOV(IND(IMM(214)), IMM(97));
MOV(IND(IMM(215)), IMM(107));
MOV(IND(IMM(216)), IMM(101));
MOV(IND(IMM(217)), IMM(45));
MOV(IND(IMM(218)), IMM(118));
MOV(IND(IMM(219)), IMM(101));
MOV(IND(IMM(220)), IMM(99));
MOV(IND(IMM(221)), IMM(116));
MOV(IND(IMM(222)), IMM(111));
MOV(IND(IMM(223)), IMM(114));
MOV(IND(IMM(224)), IMM(799345));
MOV(IND(IMM(225)), IMM(11));
MOV(IND(IMM(226)), IMM(118));
MOV(IND(IMM(227)), IMM(101));
MOV(IND(IMM(228)), IMM(99));
MOV(IND(IMM(229)), IMM(116));
MOV(IND(IMM(230)), IMM(111));
MOV(IND(IMM(231)), IMM(114));
MOV(IND(IMM(232)), IMM(45));
MOV(IND(IMM(233)), IMM(115));
MOV(IND(IMM(234)), IMM(101));
MOV(IND(IMM(235)), IMM(116));
MOV(IND(IMM(236)), IMM(33));
MOV(IND(IMM(237)), IMM(799345));
MOV(IND(IMM(238)), IMM(10));
MOV(IND(IMM(239)), IMM(118));
MOV(IND(IMM(240)), IMM(101));
MOV(IND(IMM(241)), IMM(99));
MOV(IND(IMM(242)), IMM(116));
MOV(IND(IMM(243)), IMM(111));
MOV(IND(IMM(244)), IMM(114));
MOV(IND(IMM(245)), IMM(45));
MOV(IND(IMM(246)), IMM(114));
MOV(IND(IMM(247)), IMM(101));
MOV(IND(IMM(248)), IMM(102));
MOV(IND(IMM(249)), IMM(799345));
MOV(IND(IMM(250)), IMM(13));
MOV(IND(IMM(251)), IMM(118));
MOV(IND(IMM(252)), IMM(101));
MOV(IND(IMM(253)), IMM(99));
MOV(IND(IMM(254)), IMM(116));
MOV(IND(IMM(255)), IMM(111));
MOV(IND(IMM(256)), IMM(114));
MOV(IND(IMM(257)), IMM(45));
MOV(IND(IMM(258)), IMM(108));
MOV(IND(IMM(259)), IMM(101));
MOV(IND(IMM(260)), IMM(110));
MOV(IND(IMM(261)), IMM(103));
MOV(IND(IMM(262)), IMM(116));
MOV(IND(IMM(263)), IMM(104));
MOV(IND(IMM(264)), IMM(799345));
MOV(IND(IMM(265)), IMM(11));
MOV(IND(IMM(266)), IMM(109));
MOV(IND(IMM(267)), IMM(97));
MOV(IND(IMM(268)), IMM(107));
MOV(IND(IMM(269)), IMM(101));
MOV(IND(IMM(270)), IMM(45));
MOV(IND(IMM(271)), IMM(115));
MOV(IND(IMM(272)), IMM(116));
MOV(IND(IMM(273)), IMM(114));
MOV(IND(IMM(274)), IMM(105));
MOV(IND(IMM(275)), IMM(110));
MOV(IND(IMM(276)), IMM(103));
MOV(IND(IMM(277)), IMM(799345));
MOV(IND(IMM(278)), IMM(11));
MOV(IND(IMM(279)), IMM(115));
MOV(IND(IMM(280)), IMM(116));
MOV(IND(IMM(281)), IMM(114));
MOV(IND(IMM(282)), IMM(105));
MOV(IND(IMM(283)), IMM(110));
MOV(IND(IMM(284)), IMM(103));
MOV(IND(IMM(285)), IMM(45));
MOV(IND(IMM(286)), IMM(115));
MOV(IND(IMM(287)), IMM(101));
MOV(IND(IMM(288)), IMM(116));
MOV(IND(IMM(289)), IMM(33));
MOV(IND(IMM(290)), IMM(799345));
MOV(IND(IMM(291)), IMM(10));
MOV(IND(IMM(292)), IMM(115));
MOV(IND(IMM(293)), IMM(116));
MOV(IND(IMM(294)), IMM(114));
MOV(IND(IMM(295)), IMM(105));
MOV(IND(IMM(296)), IMM(110));
MOV(IND(IMM(297)), IMM(103));
MOV(IND(IMM(298)), IMM(45));
MOV(IND(IMM(299)), IMM(114));
MOV(IND(IMM(300)), IMM(101));
MOV(IND(IMM(301)), IMM(102));
MOV(IND(IMM(302)), IMM(799345));
MOV(IND(IMM(303)), IMM(13));
MOV(IND(IMM(304)), IMM(115));
MOV(IND(IMM(305)), IMM(116));
MOV(IND(IMM(306)), IMM(114));
MOV(IND(IMM(307)), IMM(105));
MOV(IND(IMM(308)), IMM(110));
MOV(IND(IMM(309)), IMM(103));
MOV(IND(IMM(310)), IMM(45));
MOV(IND(IMM(311)), IMM(108));
MOV(IND(IMM(312)), IMM(101));
MOV(IND(IMM(313)), IMM(110));
MOV(IND(IMM(314)), IMM(103));
MOV(IND(IMM(315)), IMM(116));
MOV(IND(IMM(316)), IMM(104));
MOV(IND(IMM(317)), IMM(799345));
MOV(IND(IMM(318)), IMM(13));
MOV(IND(IMM(319)), IMM(105));
MOV(IND(IMM(320)), IMM(110));
MOV(IND(IMM(321)), IMM(116));
MOV(IND(IMM(322)), IMM(101));
MOV(IND(IMM(323)), IMM(103));
MOV(IND(IMM(324)), IMM(101));
MOV(IND(IMM(325)), IMM(114));
MOV(IND(IMM(326)), IMM(45));
MOV(IND(IMM(327)), IMM(62));
MOV(IND(IMM(328)), IMM(99));
MOV(IND(IMM(329)), IMM(104));
MOV(IND(IMM(330)), IMM(97));
MOV(IND(IMM(331)), IMM(114));
MOV(IND(IMM(332)), IMM(799345));
MOV(IND(IMM(333)), IMM(13));
MOV(IND(IMM(334)), IMM(99));
MOV(IND(IMM(335)), IMM(104));
MOV(IND(IMM(336)), IMM(97));
MOV(IND(IMM(337)), IMM(114));
MOV(IND(IMM(338)), IMM(45));
MOV(IND(IMM(339)), IMM(62));
MOV(IND(IMM(340)), IMM(105));
MOV(IND(IMM(341)), IMM(110));
MOV(IND(IMM(342)), IMM(116));
MOV(IND(IMM(343)), IMM(101));
MOV(IND(IMM(344)), IMM(103));
MOV(IND(IMM(345)), IMM(101));
MOV(IND(IMM(346)), IMM(114));
MOV(IND(IMM(347)), IMM(799345));
MOV(IND(IMM(348)), IMM(10));
MOV(IND(IMM(349)), IMM(112));
MOV(IND(IMM(350)), IMM(114));
MOV(IND(IMM(351)), IMM(111));
MOV(IND(IMM(352)), IMM(99));
MOV(IND(IMM(353)), IMM(101));
MOV(IND(IMM(354)), IMM(100));
MOV(IND(IMM(355)), IMM(117));
MOV(IND(IMM(356)), IMM(114));
MOV(IND(IMM(357)), IMM(101));
MOV(IND(IMM(358)), IMM(63));
MOV(IND(IMM(359)), IMM(799345));
MOV(IND(IMM(360)), IMM(7));
MOV(IND(IMM(361)), IMM(118));
MOV(IND(IMM(362)), IMM(101));
MOV(IND(IMM(363)), IMM(99));
MOV(IND(IMM(364)), IMM(116));
MOV(IND(IMM(365)), IMM(111));
MOV(IND(IMM(366)), IMM(114));
MOV(IND(IMM(367)), IMM(63));
MOV(IND(IMM(368)), IMM(799345));
MOV(IND(IMM(369)), IMM(5));
MOV(IND(IMM(370)), IMM(122));
MOV(IND(IMM(371)), IMM(101));
MOV(IND(IMM(372)), IMM(114));
MOV(IND(IMM(373)), IMM(111));
MOV(IND(IMM(374)), IMM(63));
MOV(IND(IMM(375)), IMM(799345));
MOV(IND(IMM(376)), IMM(7));
MOV(IND(IMM(377)), IMM(115));
MOV(IND(IMM(378)), IMM(116));
MOV(IND(IMM(379)), IMM(114));
MOV(IND(IMM(380)), IMM(105));
MOV(IND(IMM(381)), IMM(110));
MOV(IND(IMM(382)), IMM(103));
MOV(IND(IMM(383)), IMM(63));
MOV(IND(IMM(384)), IMM(799345));
MOV(IND(IMM(385)), IMM(5));
MOV(IND(IMM(386)), IMM(112));
MOV(IND(IMM(387)), IMM(97));
MOV(IND(IMM(388)), IMM(105));
MOV(IND(IMM(389)), IMM(114));
MOV(IND(IMM(390)), IMM(63));
MOV(IND(IMM(391)), IMM(799345));
MOV(IND(IMM(392)), IMM(5));
MOV(IND(IMM(393)), IMM(110));
MOV(IND(IMM(394)), IMM(117));
MOV(IND(IMM(395)), IMM(108));
MOV(IND(IMM(396)), IMM(108));
MOV(IND(IMM(397)), IMM(63));
MOV(IND(IMM(398)), IMM(799345));
MOV(IND(IMM(399)), IMM(5));
MOV(IND(IMM(400)), IMM(99));
MOV(IND(IMM(401)), IMM(104));
MOV(IND(IMM(402)), IMM(97));
MOV(IND(IMM(403)), IMM(114));
MOV(IND(IMM(404)), IMM(63));
MOV(IND(IMM(405)), IMM(799345));
MOV(IND(IMM(406)), IMM(7));
MOV(IND(IMM(407)), IMM(115));
MOV(IND(IMM(408)), IMM(121));
MOV(IND(IMM(409)), IMM(109));
MOV(IND(IMM(410)), IMM(98));
MOV(IND(IMM(411)), IMM(111));
MOV(IND(IMM(412)), IMM(108));
MOV(IND(IMM(413)), IMM(63));
MOV(IND(IMM(414)), IMM(799345));
MOV(IND(IMM(415)), IMM(8));
MOV(IND(IMM(416)), IMM(98));
MOV(IND(IMM(417)), IMM(111));
MOV(IND(IMM(418)), IMM(111));
MOV(IND(IMM(419)), IMM(108));
MOV(IND(IMM(420)), IMM(101));
MOV(IND(IMM(421)), IMM(97));
MOV(IND(IMM(422)), IMM(110));
MOV(IND(IMM(423)), IMM(63));
MOV(IND(IMM(424)), IMM(799345));
MOV(IND(IMM(425)), IMM(8));
MOV(IND(IMM(426)), IMM(105));
MOV(IND(IMM(427)), IMM(110));
MOV(IND(IMM(428)), IMM(116));
MOV(IND(IMM(429)), IMM(101));
MOV(IND(IMM(430)), IMM(103));
MOV(IND(IMM(431)), IMM(101));
MOV(IND(IMM(432)), IMM(114));
MOV(IND(IMM(433)), IMM(63));
MOV(IND(IMM(434)), IMM(799345));
MOV(IND(IMM(435)), IMM(7));
MOV(IND(IMM(436)), IMM(110));
MOV(IND(IMM(437)), IMM(117));
MOV(IND(IMM(438)), IMM(109));
MOV(IND(IMM(439)), IMM(98));
MOV(IND(IMM(440)), IMM(101));
MOV(IND(IMM(441)), IMM(114));
MOV(IND(IMM(442)), IMM(63));
MOV(IND(IMM(443)), IMM(799345));
MOV(IND(IMM(444)), IMM(1));
MOV(IND(IMM(445)), IMM(61));
MOV(IND(IMM(446)), IMM(799345));
MOV(IND(IMM(447)), IMM(1));
MOV(IND(IMM(448)), IMM(62));
MOV(IND(IMM(449)), IMM(799345));
MOV(IND(IMM(450)), IMM(1));
MOV(IND(IMM(451)), IMM(60));
MOV(IND(IMM(452)), IMM(799345));
MOV(IND(IMM(453)), IMM(1));
MOV(IND(IMM(454)), IMM(47));
MOV(IND(IMM(455)), IMM(799345));
MOV(IND(IMM(456)), IMM(1));
MOV(IND(IMM(457)), IMM(42));
MOV(IND(IMM(458)), IMM(799345));
MOV(IND(IMM(459)), IMM(1));
MOV(IND(IMM(460)), IMM(45));
MOV(IND(IMM(461)), IMM(799345));
MOV(IND(IMM(462)), IMM(1));
MOV(IND(IMM(463)), IMM(43));
MOV(IND(IMM(1)), IMM(937610));
MOV(IND(IMM(2)), IMM(722689));
MOV(IND(IMM(3)), IMM(741553));
MOV(IND(IMM(4)), IMM(0));
MOV(IND(IMM(5)), IMM(741553));
MOV(IND(IMM(6)), IMM(1));
MOV(IND(IMM(774)), IMM(945311));
MOV(IND(IMM(775)), IMM(1));
MOV(IND(IMM(776)), IMM(945311));
MOV(IND(IMM(777)), IMM(2));
MOV(IND(IMM(778)), IMM(945311));
MOV(IND(IMM(779)), IMM(3));
MOV(IND(IMM(780)), IMM(335728));
MOV(IND(IMM(781)), IMM(3));
MOV(IND(IMM(782)), IMM(774));
MOV(IND(IMM(783)), IMM(776));
MOV(IND(IMM(784)), IMM(778));
MOV(IND(IMM(1)), IMM(937610));
MOV(IND(IMM(2)), IMM(722689));
MOV(IND(IMM(3)), IMM(741553));
MOV(IND(IMM(4)), IMM(0));
MOV(IND(IMM(5)), IMM(741553));
MOV(IND(IMM(6)), IMM(1));
MOV(IND(IMM(1)), IMM(937610));
MOV(IND(IMM(2)), IMM(722689));
MOV(IND(IMM(3)), IMM(741553));
MOV(IND(IMM(4)), IMM(0));
MOV(IND(IMM(5)), IMM(741553));
MOV(IND(IMM(6)), IMM(1));
MOV(IND(IMM(1115)), IMM(885397));
MOV(IND(IMM(1116)), IMM(778));
MOV(IND(IMM(1117)), IMM(2));
MOV(IND(IMM(1118)), IMM(885397));
MOV(IND(IMM(1119)), IMM(776));
MOV(IND(IMM(1120)), IMM(1115));
MOV(IND(IMM(1121)), IMM(885397));
MOV(IND(IMM(1122)), IMM(778));
MOV(IND(IMM(1123)), IMM(2));
MOV(IND(IMM(1124)), IMM(885397));
MOV(IND(IMM(1125)), IMM(778));
MOV(IND(IMM(1126)), IMM(2));
MOV(IND(IMM(1127)), IMM(885397));
MOV(IND(IMM(1128)), IMM(774));
MOV(IND(IMM(1129)), IMM(1118));
MOV(IND(IMM(1130)), IMM(885397));
MOV(IND(IMM(1131)), IMM(776));
MOV(IND(IMM(1132)), IMM(1115));
MOV(IND(IMM(1133)), IMM(335728));
MOV(IND(IMM(1134)), IMM(4));
MOV(IND(IMM(1135)), IMM(774));
MOV(IND(IMM(1136)), IMM(1127));
MOV(IND(IMM(1137)), IMM(5));
MOV(IND(IMM(1138)), IMM(3));
MOV(INDD(484, 0), IMM(368031));
MOV(INDD(484, 1), IMM(487));
MOV(INDD(484, 2), IMM(489));
MOV(INDD(484, 3), IMM(10));
MOV(R0, 0);MOV(INDD(484, 4), R0);
MOV(INDD(489, 0), IMM(368031));
MOV(INDD(489, 1), IMM(492));
MOV(INDD(489, 2), IMM(494));
MOV(INDD(489, 3), IMM(15));
MOV(R0, 0);MOV(INDD(489, 4), R0);
MOV(INDD(494, 0), IMM(368031));
MOV(INDD(494, 1), IMM(497));
MOV(INDD(494, 2), IMM(499));
MOV(INDD(494, 3), IMM(23));
MOV(R0, 0);MOV(INDD(494, 4), R0);
MOV(INDD(499, 0), IMM(368031));
MOV(INDD(499, 1), IMM(502));
MOV(INDD(499, 2), IMM(504));
MOV(INDD(499, 3), IMM(31));
MOV(R0, 0);MOV(INDD(499, 4), R0);
MOV(INDD(504, 0), IMM(368031));
MOV(INDD(504, 1), IMM(507));
MOV(INDD(504, 2), IMM(509));
MOV(INDD(504, 3), IMM(39));
MOV(R0, 0);MOV(INDD(504, 4), R0);
MOV(INDD(509, 0), IMM(368031));
MOV(INDD(509, 1), IMM(512));
MOV(INDD(509, 2), IMM(514));
MOV(INDD(509, 3), IMM(47));
MOV(R0, 0);MOV(INDD(509, 4), R0);
MOV(INDD(514, 0), IMM(368031));
MOV(INDD(514, 1), IMM(517));
MOV(INDD(514, 2), IMM(519));
MOV(INDD(514, 3), IMM(55));
MOV(R0, 0);MOV(INDD(514, 4), R0);
MOV(INDD(519, 0), IMM(368031));
MOV(INDD(519, 1), IMM(522));
MOV(INDD(519, 2), IMM(524));
MOV(INDD(519, 3), IMM(63));
MOV(R0, 0);MOV(INDD(519, 4), R0);
MOV(INDD(524, 0), IMM(368031));
MOV(INDD(524, 1), IMM(527));
MOV(INDD(524, 2), IMM(529));
MOV(INDD(524, 3), IMM(70));
MOV(R0, 0);MOV(INDD(524, 4), R0);
MOV(INDD(529, 0), IMM(368031));
MOV(INDD(529, 1), IMM(532));
MOV(INDD(529, 2), IMM(534));
MOV(INDD(529, 3), IMM(77));
MOV(R0, 0);MOV(INDD(529, 4), R0);
MOV(INDD(534, 0), IMM(368031));
MOV(INDD(534, 1), IMM(537));
MOV(INDD(534, 2), IMM(539));
MOV(INDD(534, 3), IMM(84));
MOV(R0, 0);MOV(INDD(534, 4), R0);
MOV(INDD(539, 0), IMM(368031));
MOV(INDD(539, 1), IMM(542));
MOV(INDD(539, 2), IMM(544));
MOV(INDD(539, 3), IMM(91));
MOV(R0, 0);MOV(INDD(539, 4), R0);
MOV(INDD(544, 0), IMM(368031));
MOV(INDD(544, 1), IMM(547));
MOV(INDD(544, 2), IMM(549));
MOV(INDD(544, 3), IMM(97));
MOV(R0, 0);MOV(INDD(544, 4), R0);
MOV(INDD(549, 0), IMM(368031));
MOV(INDD(549, 1), IMM(552));
MOV(INDD(549, 2), IMM(554));
MOV(INDD(549, 3), IMM(103));
MOV(R0, 0);MOV(INDD(549, 4), R0);
MOV(INDD(554, 0), IMM(368031));
MOV(INDD(554, 1), IMM(557));
MOV(INDD(554, 2), IMM(559));
MOV(INDD(554, 3), IMM(109));
PUSH(LABEL(EQ)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(554, 4), R0);
MOV(INDD(559, 0), IMM(368031));
MOV(INDD(559, 1), IMM(562));
MOV(INDD(559, 2), IMM(564));
MOV(INDD(559, 3), IMM(114));
PUSH(LABEL(STR_TO_SYMBOL)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(559, 4), R0);
MOV(INDD(564, 0), IMM(368031));
MOV(INDD(564, 1), IMM(567));
MOV(INDD(564, 2), IMM(569));
MOV(INDD(564, 3), IMM(130));
PUSH(LABEL(SYMBOL_TO_STR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(564, 4), R0);
MOV(INDD(569, 0), IMM(368031));
MOV(INDD(569, 1), IMM(572));
MOV(INDD(569, 2), IMM(574));
MOV(INDD(569, 3), IMM(146));
PUSH(LABEL(LIST_LENGTH)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(569, 4), R0);
MOV(INDD(574, 0), IMM(368031));
MOV(INDD(574, 1), IMM(577));
MOV(INDD(574, 2), IMM(579));
MOV(INDD(574, 3), IMM(154));
PUSH(LABEL(APPLY)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(574, 4), R0);
MOV(INDD(579, 0), IMM(368031));
MOV(INDD(579, 1), IMM(582));
MOV(INDD(579, 2), IMM(584));
MOV(INDD(579, 3), IMM(161));
PUSH(LABEL(VECTOR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(579, 4), R0);
MOV(INDD(584, 0), IMM(368031));
MOV(INDD(584, 1), IMM(587));
MOV(INDD(584, 2), IMM(589));
MOV(INDD(584, 3), IMM(169));
PUSH(LABEL(LIST)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(584, 4), R0);
MOV(INDD(589, 0), IMM(368031));
MOV(INDD(589, 1), IMM(592));
MOV(INDD(589, 2), IMM(594));
MOV(INDD(589, 3), IMM(175));
PUSH(LABEL(SET_CAR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(589, 4), R0);
MOV(INDD(594, 0), IMM(368031));
MOV(INDD(594, 1), IMM(597));
MOV(INDD(594, 2), IMM(599));
MOV(INDD(594, 3), IMM(185));
PUSH(LABEL(SET_CDR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(594, 4), R0);
MOV(INDD(599, 0), IMM(368031));
MOV(INDD(599, 1), IMM(602));
MOV(INDD(599, 2), IMM(604));
MOV(INDD(599, 3), IMM(195));
PUSH(LABEL(CDR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(599, 4), R0);
MOV(INDD(604, 0), IMM(368031));
MOV(INDD(604, 1), IMM(607));
MOV(INDD(604, 2), IMM(609));
MOV(INDD(604, 3), IMM(200));
PUSH(LABEL(CAR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(604, 4), R0);
MOV(INDD(609, 0), IMM(368031));
MOV(INDD(609, 1), IMM(612));
MOV(INDD(609, 2), IMM(614));
MOV(INDD(609, 3), IMM(205));
PUSH(LABEL(CONS)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(609, 4), R0);
MOV(INDD(614, 0), IMM(368031));
MOV(INDD(614, 1), IMM(617));
MOV(INDD(614, 2), IMM(619));
MOV(INDD(614, 3), IMM(211));
PUSH(LABEL(MAKE_VECTOR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(614, 4), R0);
MOV(INDD(619, 0), IMM(368031));
MOV(INDD(619, 1), IMM(622));
MOV(INDD(619, 2), IMM(624));
MOV(INDD(619, 3), IMM(224));
PUSH(LABEL(VEC_SET)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(619, 4), R0);
MOV(INDD(624, 0), IMM(368031));
MOV(INDD(624, 1), IMM(627));
MOV(INDD(624, 2), IMM(629));
MOV(INDD(624, 3), IMM(237));
PUSH(LABEL(VEC_REF)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(624, 4), R0);
MOV(INDD(629, 0), IMM(368031));
MOV(INDD(629, 1), IMM(632));
MOV(INDD(629, 2), IMM(634));
MOV(INDD(629, 3), IMM(249));
PUSH(LABEL(VEC_LENGTH)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(629, 4), R0);
MOV(INDD(634, 0), IMM(368031));
MOV(INDD(634, 1), IMM(637));
MOV(INDD(634, 2), IMM(639));
MOV(INDD(634, 3), IMM(264));
PUSH(LABEL(MAKE_STRING)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(634, 4), R0);
MOV(INDD(639, 0), IMM(368031));
MOV(INDD(639, 1), IMM(642));
MOV(INDD(639, 2), IMM(644));
MOV(INDD(639, 3), IMM(277));
PUSH(LABEL(STR_SET)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(639, 4), R0);
MOV(INDD(644, 0), IMM(368031));
MOV(INDD(644, 1), IMM(647));
MOV(INDD(644, 2), IMM(649));
MOV(INDD(644, 3), IMM(290));
PUSH(LABEL(STR_REF)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(644, 4), R0);
MOV(INDD(649, 0), IMM(368031));
MOV(INDD(649, 1), IMM(652));
MOV(INDD(649, 2), IMM(654));
MOV(INDD(649, 3), IMM(302));
PUSH(LABEL(STR_LENGTH)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(649, 4), R0);
MOV(INDD(654, 0), IMM(368031));
MOV(INDD(654, 1), IMM(657));
MOV(INDD(654, 2), IMM(659));
MOV(INDD(654, 3), IMM(317));
PUSH(LABEL(INT_TO_CHAR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(654, 4), R0);
MOV(INDD(659, 0), IMM(368031));
MOV(INDD(659, 1), IMM(662));
MOV(INDD(659, 2), IMM(664));
MOV(INDD(659, 3), IMM(332));
PUSH(LABEL(CHAR_TO_INT)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(659, 4), R0);
MOV(INDD(664, 0), IMM(368031));
MOV(INDD(664, 1), IMM(667));
MOV(INDD(664, 2), IMM(669));
MOV(INDD(664, 3), IMM(347));
PUSH(LABEL(ISPROCEDURE)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(664, 4), R0);
MOV(INDD(669, 0), IMM(368031));
MOV(INDD(669, 1), IMM(672));
MOV(INDD(669, 2), IMM(674));
MOV(INDD(669, 3), IMM(359));
PUSH(LABEL(ISVECTOR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(669, 4), R0);
MOV(INDD(674, 0), IMM(368031));
MOV(INDD(674, 1), IMM(677));
MOV(INDD(674, 2), IMM(679));
MOV(INDD(674, 3), IMM(368));
PUSH(LABEL(ISZERO)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(674, 4), R0);
MOV(INDD(679, 0), IMM(368031));
MOV(INDD(679, 1), IMM(682));
MOV(INDD(679, 2), IMM(684));
MOV(INDD(679, 3), IMM(375));
PUSH(LABEL(ISSTRING)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(679, 4), R0);
MOV(INDD(684, 0), IMM(368031));
MOV(INDD(684, 1), IMM(687));
MOV(INDD(684, 2), IMM(689));
MOV(INDD(684, 3), IMM(384));
PUSH(LABEL(ISPAIR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(684, 4), R0);
MOV(INDD(689, 0), IMM(368031));
MOV(INDD(689, 1), IMM(692));
MOV(INDD(689, 2), IMM(694));
MOV(INDD(689, 3), IMM(391));
PUSH(LABEL(ISNULL)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(689, 4), R0);
MOV(INDD(694, 0), IMM(368031));
MOV(INDD(694, 1), IMM(697));
MOV(INDD(694, 2), IMM(699));
MOV(INDD(694, 3), IMM(398));
PUSH(LABEL(ISCHAR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(694, 4), R0);
MOV(INDD(699, 0), IMM(368031));
MOV(INDD(699, 1), IMM(702));
MOV(INDD(699, 2), IMM(704));
MOV(INDD(699, 3), IMM(405));
PUSH(LABEL(ISSYMBOL)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(699, 4), R0);
MOV(INDD(704, 0), IMM(368031));
MOV(INDD(704, 1), IMM(707));
MOV(INDD(704, 2), IMM(709));
MOV(INDD(704, 3), IMM(414));
PUSH(LABEL(ISBOOLEAN)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(704, 4), R0);
MOV(INDD(709, 0), IMM(368031));
MOV(INDD(709, 1), IMM(712));
MOV(INDD(709, 2), IMM(714));
MOV(INDD(709, 3), IMM(424));
PUSH(LABEL(ISINTEGER)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(709, 4), R0);
MOV(INDD(714, 0), IMM(368031));
MOV(INDD(714, 1), IMM(717));
MOV(INDD(714, 2), IMM(719));
MOV(INDD(714, 3), IMM(434));
PUSH(LABEL(ISNUMBER)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(714, 4), R0);
MOV(INDD(719, 0), IMM(368031));
MOV(INDD(719, 1), IMM(722));
MOV(INDD(719, 2), IMM(724));
MOV(INDD(719, 3), IMM(443));
PUSH(LABEL(VAR_EQUAL)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(719, 4), R0);
MOV(INDD(724, 0), IMM(368031));
MOV(INDD(724, 1), IMM(727));
MOV(INDD(724, 2), IMM(729));
MOV(INDD(724, 3), IMM(446));
PUSH(LABEL(VAR_GREATERTHAN)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(724, 4), R0);
MOV(INDD(729, 0), IMM(368031));
MOV(INDD(729, 1), IMM(732));
MOV(INDD(729, 2), IMM(734));
MOV(INDD(729, 3), IMM(449));
PUSH(LABEL(VAR_LESSTHAN)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(729, 4), R0);
MOV(INDD(734, 0), IMM(368031));
MOV(INDD(734, 1), IMM(737));
MOV(INDD(734, 2), IMM(739));
MOV(INDD(734, 3), IMM(452));
PUSH(LABEL(VAR_DIV)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(734, 4), R0);
MOV(INDD(739, 0), IMM(368031));
MOV(INDD(739, 1), IMM(742));
MOV(INDD(739, 2), IMM(744));
MOV(INDD(739, 3), IMM(455));
PUSH(LABEL(VAR_MUL)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(739, 4), R0);
MOV(INDD(744, 0), IMM(368031));
MOV(INDD(744, 1), IMM(747));
MOV(INDD(744, 2), IMM(749));
MOV(INDD(744, 3), IMM(458));
PUSH(LABEL(VAR_MIN)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(744, 4), R0);
MOV(INDD(749, 0), IMM(368031));
MOV(INDD(749, 1), IMM(752));
MOV(INDD(749, 2), IMM(754));
MOV(INDD(749, 3), IMM(461));
PUSH(LABEL(VAR_PLUS)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(749, 4), R0);
MOV(INDD(825, 0), IMM(368031));
MOV(INDD(825, 1), IMM(828));
MOV(INDD(825, 2), IMM(830));
MOV(INDD(825, 3), IMM(10));
MOV(R0, 0);MOV(INDD(825, 4), R0);
MOV(INDD(830, 0), IMM(368031));
MOV(INDD(830, 1), IMM(833));
MOV(INDD(830, 2), IMM(835));
MOV(INDD(830, 3), IMM(15));
MOV(R0, 0);MOV(INDD(830, 4), R0);
MOV(INDD(835, 0), IMM(368031));
MOV(INDD(835, 1), IMM(838));
MOV(INDD(835, 2), IMM(840));
MOV(INDD(835, 3), IMM(23));
MOV(R0, 0);MOV(INDD(835, 4), R0);
MOV(INDD(840, 0), IMM(368031));
MOV(INDD(840, 1), IMM(843));
MOV(INDD(840, 2), IMM(845));
MOV(INDD(840, 3), IMM(31));
MOV(R0, 0);MOV(INDD(840, 4), R0);
MOV(INDD(845, 0), IMM(368031));
MOV(INDD(845, 1), IMM(848));
MOV(INDD(845, 2), IMM(850));
MOV(INDD(845, 3), IMM(39));
MOV(R0, 0);MOV(INDD(845, 4), R0);
MOV(INDD(850, 0), IMM(368031));
MOV(INDD(850, 1), IMM(853));
MOV(INDD(850, 2), IMM(855));
MOV(INDD(850, 3), IMM(47));
MOV(R0, 0);MOV(INDD(850, 4), R0);
MOV(INDD(855, 0), IMM(368031));
MOV(INDD(855, 1), IMM(858));
MOV(INDD(855, 2), IMM(860));
MOV(INDD(855, 3), IMM(55));
MOV(R0, 0);MOV(INDD(855, 4), R0);
MOV(INDD(860, 0), IMM(368031));
MOV(INDD(860, 1), IMM(863));
MOV(INDD(860, 2), IMM(865));
MOV(INDD(860, 3), IMM(63));
MOV(R0, 0);MOV(INDD(860, 4), R0);
MOV(INDD(865, 0), IMM(368031));
MOV(INDD(865, 1), IMM(868));
MOV(INDD(865, 2), IMM(870));
MOV(INDD(865, 3), IMM(70));
MOV(R0, 0);MOV(INDD(865, 4), R0);
MOV(INDD(870, 0), IMM(368031));
MOV(INDD(870, 1), IMM(873));
MOV(INDD(870, 2), IMM(875));
MOV(INDD(870, 3), IMM(77));
MOV(R0, 0);MOV(INDD(870, 4), R0);
MOV(INDD(875, 0), IMM(368031));
MOV(INDD(875, 1), IMM(878));
MOV(INDD(875, 2), IMM(880));
MOV(INDD(875, 3), IMM(84));
MOV(R0, 0);MOV(INDD(875, 4), R0);
MOV(INDD(880, 0), IMM(368031));
MOV(INDD(880, 1), IMM(883));
MOV(INDD(880, 2), IMM(885));
MOV(INDD(880, 3), IMM(91));
MOV(R0, 0);MOV(INDD(880, 4), R0);
MOV(INDD(885, 0), IMM(368031));
MOV(INDD(885, 1), IMM(888));
MOV(INDD(885, 2), IMM(890));
MOV(INDD(885, 3), IMM(97));
MOV(R0, 0);MOV(INDD(885, 4), R0);
MOV(INDD(890, 0), IMM(368031));
MOV(INDD(890, 1), IMM(893));
MOV(INDD(890, 2), IMM(895));
MOV(INDD(890, 3), IMM(103));
MOV(R0, 0);MOV(INDD(890, 4), R0);
MOV(INDD(895, 0), IMM(368031));
MOV(INDD(895, 1), IMM(898));
MOV(INDD(895, 2), IMM(900));
MOV(INDD(895, 3), IMM(109));
PUSH(LABEL(EQ)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(895, 4), R0);
MOV(INDD(900, 0), IMM(368031));
MOV(INDD(900, 1), IMM(903));
MOV(INDD(900, 2), IMM(905));
MOV(INDD(900, 3), IMM(114));
PUSH(LABEL(STR_TO_SYMBOL)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(900, 4), R0);
MOV(INDD(905, 0), IMM(368031));
MOV(INDD(905, 1), IMM(908));
MOV(INDD(905, 2), IMM(910));
MOV(INDD(905, 3), IMM(130));
PUSH(LABEL(SYMBOL_TO_STR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(905, 4), R0);
MOV(INDD(910, 0), IMM(368031));
MOV(INDD(910, 1), IMM(913));
MOV(INDD(910, 2), IMM(915));
MOV(INDD(910, 3), IMM(146));
PUSH(LABEL(LIST_LENGTH)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(910, 4), R0);
MOV(INDD(915, 0), IMM(368031));
MOV(INDD(915, 1), IMM(918));
MOV(INDD(915, 2), IMM(920));
MOV(INDD(915, 3), IMM(154));
PUSH(LABEL(APPLY)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(915, 4), R0);
MOV(INDD(920, 0), IMM(368031));
MOV(INDD(920, 1), IMM(923));
MOV(INDD(920, 2), IMM(925));
MOV(INDD(920, 3), IMM(161));
PUSH(LABEL(VECTOR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(920, 4), R0);
MOV(INDD(925, 0), IMM(368031));
MOV(INDD(925, 1), IMM(928));
MOV(INDD(925, 2), IMM(930));
MOV(INDD(925, 3), IMM(169));
PUSH(LABEL(LIST)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(925, 4), R0);
MOV(INDD(930, 0), IMM(368031));
MOV(INDD(930, 1), IMM(933));
MOV(INDD(930, 2), IMM(935));
MOV(INDD(930, 3), IMM(175));
PUSH(LABEL(SET_CAR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(930, 4), R0);
MOV(INDD(935, 0), IMM(368031));
MOV(INDD(935, 1), IMM(938));
MOV(INDD(935, 2), IMM(940));
MOV(INDD(935, 3), IMM(185));
PUSH(LABEL(SET_CDR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(935, 4), R0);
MOV(INDD(940, 0), IMM(368031));
MOV(INDD(940, 1), IMM(943));
MOV(INDD(940, 2), IMM(945));
MOV(INDD(940, 3), IMM(195));
PUSH(LABEL(CDR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(940, 4), R0);
MOV(INDD(945, 0), IMM(368031));
MOV(INDD(945, 1), IMM(948));
MOV(INDD(945, 2), IMM(950));
MOV(INDD(945, 3), IMM(200));
PUSH(LABEL(CAR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(945, 4), R0);
MOV(INDD(950, 0), IMM(368031));
MOV(INDD(950, 1), IMM(953));
MOV(INDD(950, 2), IMM(955));
MOV(INDD(950, 3), IMM(205));
PUSH(LABEL(CONS)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(950, 4), R0);
MOV(INDD(955, 0), IMM(368031));
MOV(INDD(955, 1), IMM(958));
MOV(INDD(955, 2), IMM(960));
MOV(INDD(955, 3), IMM(211));
PUSH(LABEL(MAKE_VECTOR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(955, 4), R0);
MOV(INDD(960, 0), IMM(368031));
MOV(INDD(960, 1), IMM(963));
MOV(INDD(960, 2), IMM(965));
MOV(INDD(960, 3), IMM(224));
PUSH(LABEL(VEC_SET)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(960, 4), R0);
MOV(INDD(965, 0), IMM(368031));
MOV(INDD(965, 1), IMM(968));
MOV(INDD(965, 2), IMM(970));
MOV(INDD(965, 3), IMM(237));
PUSH(LABEL(VEC_REF)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(965, 4), R0);
MOV(INDD(970, 0), IMM(368031));
MOV(INDD(970, 1), IMM(973));
MOV(INDD(970, 2), IMM(975));
MOV(INDD(970, 3), IMM(249));
PUSH(LABEL(VEC_LENGTH)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(970, 4), R0);
MOV(INDD(975, 0), IMM(368031));
MOV(INDD(975, 1), IMM(978));
MOV(INDD(975, 2), IMM(980));
MOV(INDD(975, 3), IMM(264));
PUSH(LABEL(MAKE_STRING)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(975, 4), R0);
MOV(INDD(980, 0), IMM(368031));
MOV(INDD(980, 1), IMM(983));
MOV(INDD(980, 2), IMM(985));
MOV(INDD(980, 3), IMM(277));
PUSH(LABEL(STR_SET)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(980, 4), R0);
MOV(INDD(985, 0), IMM(368031));
MOV(INDD(985, 1), IMM(988));
MOV(INDD(985, 2), IMM(990));
MOV(INDD(985, 3), IMM(290));
PUSH(LABEL(STR_REF)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(985, 4), R0);
MOV(INDD(990, 0), IMM(368031));
MOV(INDD(990, 1), IMM(993));
MOV(INDD(990, 2), IMM(995));
MOV(INDD(990, 3), IMM(302));
PUSH(LABEL(STR_LENGTH)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(990, 4), R0);
MOV(INDD(995, 0), IMM(368031));
MOV(INDD(995, 1), IMM(998));
MOV(INDD(995, 2), IMM(1000));
MOV(INDD(995, 3), IMM(317));
PUSH(LABEL(INT_TO_CHAR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(995, 4), R0);
MOV(INDD(1000, 0), IMM(368031));
MOV(INDD(1000, 1), IMM(1003));
MOV(INDD(1000, 2), IMM(1005));
MOV(INDD(1000, 3), IMM(332));
PUSH(LABEL(CHAR_TO_INT)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1000, 4), R0);
MOV(INDD(1005, 0), IMM(368031));
MOV(INDD(1005, 1), IMM(1008));
MOV(INDD(1005, 2), IMM(1010));
MOV(INDD(1005, 3), IMM(347));
PUSH(LABEL(ISPROCEDURE)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1005, 4), R0);
MOV(INDD(1010, 0), IMM(368031));
MOV(INDD(1010, 1), IMM(1013));
MOV(INDD(1010, 2), IMM(1015));
MOV(INDD(1010, 3), IMM(359));
PUSH(LABEL(ISVECTOR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1010, 4), R0);
MOV(INDD(1015, 0), IMM(368031));
MOV(INDD(1015, 1), IMM(1018));
MOV(INDD(1015, 2), IMM(1020));
MOV(INDD(1015, 3), IMM(368));
PUSH(LABEL(ISZERO)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1015, 4), R0);
MOV(INDD(1020, 0), IMM(368031));
MOV(INDD(1020, 1), IMM(1023));
MOV(INDD(1020, 2), IMM(1025));
MOV(INDD(1020, 3), IMM(375));
PUSH(LABEL(ISSTRING)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1020, 4), R0);
MOV(INDD(1025, 0), IMM(368031));
MOV(INDD(1025, 1), IMM(1028));
MOV(INDD(1025, 2), IMM(1030));
MOV(INDD(1025, 3), IMM(384));
PUSH(LABEL(ISPAIR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1025, 4), R0);
MOV(INDD(1030, 0), IMM(368031));
MOV(INDD(1030, 1), IMM(1033));
MOV(INDD(1030, 2), IMM(1035));
MOV(INDD(1030, 3), IMM(391));
PUSH(LABEL(ISNULL)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1030, 4), R0);
MOV(INDD(1035, 0), IMM(368031));
MOV(INDD(1035, 1), IMM(1038));
MOV(INDD(1035, 2), IMM(1040));
MOV(INDD(1035, 3), IMM(398));
PUSH(LABEL(ISCHAR)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1035, 4), R0);
MOV(INDD(1040, 0), IMM(368031));
MOV(INDD(1040, 1), IMM(1043));
MOV(INDD(1040, 2), IMM(1045));
MOV(INDD(1040, 3), IMM(405));
PUSH(LABEL(ISSYMBOL)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1040, 4), R0);
MOV(INDD(1045, 0), IMM(368031));
MOV(INDD(1045, 1), IMM(1048));
MOV(INDD(1045, 2), IMM(1050));
MOV(INDD(1045, 3), IMM(414));
PUSH(LABEL(ISBOOLEAN)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1045, 4), R0);
MOV(INDD(1050, 0), IMM(368031));
MOV(INDD(1050, 1), IMM(1053));
MOV(INDD(1050, 2), IMM(1055));
MOV(INDD(1050, 3), IMM(424));
PUSH(LABEL(ISINTEGER)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1050, 4), R0);
MOV(INDD(1055, 0), IMM(368031));
MOV(INDD(1055, 1), IMM(1058));
MOV(INDD(1055, 2), IMM(1060));
MOV(INDD(1055, 3), IMM(434));
PUSH(LABEL(ISNUMBER)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1055, 4), R0);
MOV(INDD(1060, 0), IMM(368031));
MOV(INDD(1060, 1), IMM(1063));
MOV(INDD(1060, 2), IMM(1065));
MOV(INDD(1060, 3), IMM(443));
PUSH(LABEL(VAR_EQUAL)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1060, 4), R0);
MOV(INDD(1065, 0), IMM(368031));
MOV(INDD(1065, 1), IMM(1068));
MOV(INDD(1065, 2), IMM(1070));
MOV(INDD(1065, 3), IMM(446));
PUSH(LABEL(VAR_GREATERTHAN)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1065, 4), R0);
MOV(INDD(1070, 0), IMM(368031));
MOV(INDD(1070, 1), IMM(1073));
MOV(INDD(1070, 2), IMM(1075));
MOV(INDD(1070, 3), IMM(449));
PUSH(LABEL(VAR_LESSTHAN)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1070, 4), R0);
MOV(INDD(1075, 0), IMM(368031));
MOV(INDD(1075, 1), IMM(1078));
MOV(INDD(1075, 2), IMM(1080));
MOV(INDD(1075, 3), IMM(452));
PUSH(LABEL(VAR_DIV)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1075, 4), R0);
MOV(INDD(1080, 0), IMM(368031));
MOV(INDD(1080, 1), IMM(1083));
MOV(INDD(1080, 2), IMM(1085));
MOV(INDD(1080, 3), IMM(455));
PUSH(LABEL(VAR_MUL)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1080, 4), R0);
MOV(INDD(1085, 0), IMM(368031));
MOV(INDD(1085, 1), IMM(1088));
MOV(INDD(1085, 2), IMM(1090));
MOV(INDD(1085, 3), IMM(458));
PUSH(LABEL(VAR_MIN)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1085, 4), R0);
MOV(INDD(1090, 0), IMM(368031));
MOV(INDD(1090, 1), IMM(1093));
MOV(INDD(1090, 2), IMM(1095));
MOV(INDD(1090, 3), IMM(461));
PUSH(LABEL(VAR_PLUS)) // Push code of label;
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1090, 4), R0);
MOV(INDD(1090, 2), 2);


/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop58:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit58);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop58);
LabelEnvLoopExit58: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop58:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit58);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop58);
LabelparamsoopExit58: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody58)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd58);
LabelClosureBody58:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop52:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit52);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop52);
LabelTailExit52:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd58:

MOV(ADDR(553), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop57:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit57);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop57);
LabelEnvLoopExit57: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop57:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit57);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop57);
LabelparamsoopExit57: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody57)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd57);
LabelClosureBody57:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop51:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit51);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop51);
LabelTailExit51:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd57:

MOV(ADDR(548), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop56:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit56);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop56);
LabelEnvLoopExit56: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop56:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit56);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop56);
LabelparamsoopExit56: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody56)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd56);
LabelClosureBody56:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop50:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit50);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop50);
LabelTailExit50:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd56:

MOV(ADDR(543), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop55:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit55);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop55);
LabelEnvLoopExit55: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop55:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit55);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop55);
LabelparamsoopExit55: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody55)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd55);
LabelClosureBody55:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop49:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit49);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop49);
LabelTailExit49:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd55:

MOV(ADDR(538), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop54:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit54);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop54);
LabelEnvLoopExit54: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop54:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit54);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop54);
LabelparamsoopExit54: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody54)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd54);
LabelClosureBody54:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop48:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit48);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop48);
LabelTailExit48:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd54:

MOV(ADDR(533), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop53:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit53);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop53);
LabelEnvLoopExit53: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop53:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit53);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop53);
LabelparamsoopExit53: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody53)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd53);
LabelClosureBody53:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop47:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit47);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop47);
LabelTailExit47:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd53:

MOV(ADDR(528), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop52:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit52);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop52);
LabelEnvLoopExit52: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop52:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit52);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop52);
LabelparamsoopExit52: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody52)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd52);
LabelClosureBody52:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop46:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit46);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop46);
LabelTailExit46:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd52:

MOV(ADDR(523), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop51:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit51);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop51);
LabelEnvLoopExit51: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop51:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit51);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop51);
LabelparamsoopExit51: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody51)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd51);
LabelClosureBody51:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop45:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit45);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop45);
LabelTailExit45:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd51:

MOV(ADDR(518), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop50:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit50);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop50);
LabelEnvLoopExit50: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop50:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit50);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop50);
LabelparamsoopExit50: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody50)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd50);
LabelClosureBody50:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop44:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit44);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop44);
LabelTailExit44:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd50:

MOV(ADDR(513), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop49:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit49);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop49);
LabelEnvLoopExit49: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop49:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit49);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop49);
LabelparamsoopExit49: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody49)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd49);
LabelClosureBody49:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop43:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit43);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop43);
LabelTailExit43:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd49:

MOV(ADDR(508), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop48:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit48);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop48);
LabelEnvLoopExit48: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop48:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit48);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop48);
LabelparamsoopExit48: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody48)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd48);
LabelClosureBody48:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop42:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit42);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop42);
LabelTailExit42:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd48:

MOV(ADDR(503), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop47:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit47);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop47);
LabelEnvLoopExit47: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop47:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit47);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop47);
LabelparamsoopExit47: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody47)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd47);
LabelClosureBody47:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop41:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit41);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop41);
LabelTailExit41:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd47:

MOV(ADDR(498), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop43:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit43);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop43);
LabelEnvLoopExit43: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop43:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit43);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop43);
LabelparamsoopExit43: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody43)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd43);
LabelClosureBody43:
PUSH(FP);
MOV(FP, SP);
/* - Lambda Var Body -*/
POP(R1);  // Old FP
POP(R2);  // Return addr
POP(R3);  // Env
POP(R4);  // args count
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */
/* In constants .. */
MOV(R0,IMM(3));
PUSH(R0);
/* In constants .. */
MOV(R0,IMM(3));
PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(2));
/* Compile function and add it's code: */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 1; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop44:
CMP(R5,IMM(1));
JUMP_GE(LabelEnvLoopExit44);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop44);
LabelEnvLoopExit44: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop44:
CMP(R5,IMM(3));
JUMP_GE(LabelparamsoopExit44);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop44);
LabelparamsoopExit44: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody44)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd44);
LabelClosureBody44:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* CodeGen:*/
/* --- set! pvar: -- */
MOV(R10, IMM(0));
ADD(R10,IMM(2));
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(IND(R0),FPARG(R10));

MOV(FPARG(2), R0);
MOV(R0, SOB_VOID);

/* --- set! pvar: -- */
MOV(R10, IMM(1));
ADD(R10,IMM(2));
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(IND(R0),FPARG(R10));

MOV(FPARG(3), R0);
MOV(R0, SOB_VOID);



/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 2; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop45:
CMP(R5,IMM(2));
JUMP_GE(LabelEnvLoopExit45);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop45);
LabelEnvLoopExit45: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop45:
CMP(R5,IMM(4));
JUMP_GE(LabelparamsoopExit45);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop45);
LabelparamsoopExit45: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody45)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd45);
LabelClosureBody45:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* CodeGen:*/
/* - If Expression - */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(693)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

CMP(R0, FALSE);
JUMP_EQ(LabelIf3Else9);
/* --- P-Var: --- */
MOV(R0, FPARG(3));

JUMP(LabelIf3Exit9);
LabelIf3Else9:


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(2)) // Push Num of args;

/* The Compiled Function: */
MOV(R1, FPARG(IMM(0)));
MOV(R1,INDD(R1,IMM(0)));
MOV(R1,INDD(R1,IMM(0)));
MOV(R0,IND(R1));
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(2));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(613)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(3)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop39:
CMP(R4, IMM(5));
JUMP_EQ(LabelTailExit39);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop39);
LabelTailExit39:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

LabelIf3Exit9:
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd45:

MOV(R1, IMM(0));
ADD(R1,IMM(2));
MOV(IND(FPARG(R1)),R0);



/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 2; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop46:
CMP(R5,IMM(2));
JUMP_GE(LabelEnvLoopExit46);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop46);
LabelEnvLoopExit46: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop46:
CMP(R5,IMM(4));
JUMP_GE(LabelparamsoopExit46);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop46);
LabelparamsoopExit46: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody46)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd46);
LabelClosureBody46:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* CodeGen:*/
/* - If Expression - */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(693)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

CMP(R0, FALSE);
JUMP_EQ(LabelIf3Else10);
/* --- P-Var: --- */
MOV(R0, FPARG(2));

JUMP(LabelIf3Exit10);
LabelIf3Else10:


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(2)) // Push Num of args;

/* The Compiled Function: */
MOV(R1, FPARG(IMM(0)));
MOV(R1,INDD(R1,IMM(0)));
MOV(R1,INDD(R1,IMM(1)));
MOV(R0,IND(R1));
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(2));
/* Compile function and add it's code: */
MOV(R1, FPARG(IMM(0)));
MOV(R1,INDD(R1,IMM(0)));
MOV(R1,INDD(R1,IMM(0)));
MOV(R0,IND(R1));
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(3)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop40:
CMP(R4, IMM(5));
JUMP_EQ(LabelTailExit40);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop40);
LabelTailExit40:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

LabelIf3Exit10:
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd46:

MOV(R1, IMM(1));
ADD(R1,IMM(2));
MOV(IND(FPARG(R1)),R0);

/* - If Expression - */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(693)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

CMP(R0, FALSE);
JUMP_EQ(LabelIf3Else8);
/* In constants .. */
MOV(R0,IMM(2));
JUMP(LabelIf3Exit8);
LabelIf3Else8:


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(2));
/* Compile function and add it's code: */
MOV(R10, IMM(1));
ADD(R10,IMM(2));
MOV(R0,IND(FPARG(R10)));
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(3)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop38:
CMP(R4, IMM(5));
JUMP_EQ(LabelTailExit38);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop38);
LabelTailExit38:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

LabelIf3Exit8:

/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd44:
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(3)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop37:
CMP(R4, IMM(5));
JUMP_EQ(LabelTailExit37);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop37);
LabelTailExit37:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
LabelClosureEnd43:

MOV(ADDR(493), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* --- Define: -- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop38:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit38);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop38);
LabelEnvLoopExit38: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop38:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit38);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop38);
LabelparamsoopExit38: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody38)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd38);
LabelClosureBody38:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 1; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop41:
CMP(R5,IMM(1));
JUMP_GE(LabelEnvLoopExit41);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop41);
LabelEnvLoopExit41: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop41:
CMP(R5,IMM(3));
JUMP_GE(LabelparamsoopExit41);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop41);
LabelparamsoopExit41: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody41)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd41);
LabelClosureBody41:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 2; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop42:
CMP(R5,IMM(2));
JUMP_GE(LabelEnvLoopExit42);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop42);
LabelEnvLoopExit42: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop42:
CMP(R5,IMM(3));
JUMP_GE(LabelparamsoopExit42);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop42);
LabelparamsoopExit42: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody42)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd42);
LabelClosureBody42:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(2));
/* Compile function and add it's code: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(3)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop36:
CMP(R4, IMM(5));
JUMP_EQ(LabelTailExit36);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop36);
LabelTailExit36:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd42:

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop35:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit35);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop35);
LabelTailExit35:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd41:

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 1; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop39:
CMP(R5,IMM(1));
JUMP_GE(LabelEnvLoopExit39);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop39);
LabelEnvLoopExit39: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop39:
CMP(R5,IMM(3));
JUMP_GE(LabelparamsoopExit39);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop39);
LabelparamsoopExit39: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody39)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd39);
LabelClosureBody39:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 2; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop40:
CMP(R5,IMM(2));
JUMP_GE(LabelEnvLoopExit40);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop40);
LabelEnvLoopExit40: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop40:
CMP(R5,IMM(3));
JUMP_GE(LabelparamsoopExit40);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop40);
LabelparamsoopExit40: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody40)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd40);
LabelClosureBody40:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(2));
/* Compile function and add it's code: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(3)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop34:
CMP(R4, IMM(5));
JUMP_EQ(LabelTailExit34);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop34);
LabelTailExit34:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd40:

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop33:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit33);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop33);
LabelTailExit33:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd39:
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop32:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit32);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop32);
LabelTailExit32:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd38:

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 0; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop30:
CMP(R5,IMM(0));
JUMP_GE(LabelEnvLoopExit30);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop30);
LabelEnvLoopExit30: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop30:
CMP(R5,IMM(2));
JUMP_GE(LabelparamsoopExit30);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop30);
LabelparamsoopExit30: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody30)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd30);
LabelClosureBody30:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 1; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop36:
CMP(R5,IMM(1));
JUMP_GE(LabelEnvLoopExit36);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop36);
LabelEnvLoopExit36: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop36:
CMP(R5,IMM(3));
JUMP_GE(LabelparamsoopExit36);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop36);
LabelparamsoopExit36: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody36)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd36);
LabelClosureBody36:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 2; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop37:
CMP(R5,IMM(2));
JUMP_GE(LabelEnvLoopExit37);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop37);
LabelEnvLoopExit37: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop37:
CMP(R5,IMM(3));
JUMP_GE(LabelparamsoopExit37);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop37);
LabelparamsoopExit37: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody37)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd37);
LabelClosureBody37:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* CodeGen:*/
/* - If Expression - */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(693)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

CMP(R0, FALSE);
JUMP_EQ(LabelIf3Else7);
/* In constants .. */
MOV(R0,IMM(2));
JUMP(LabelIf3Exit7);
LabelIf3Else7:


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(2)) // Push Num of args;

/* The Compiled Function: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(2));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(613)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(3)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop31:
CMP(R4, IMM(5));
JUMP_EQ(LabelTailExit31);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop31);
LabelTailExit31:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

LabelIf3Exit7:
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd37:
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd36:

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- P-Var: --- */
MOV(R0, FPARG(2));
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 1; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop31:
CMP(R5,IMM(1));
JUMP_GE(LabelEnvLoopExit31);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop31);
LabelEnvLoopExit31: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop31:
CMP(R5,IMM(3));
JUMP_GE(LabelparamsoopExit31);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop31);
LabelparamsoopExit31: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody31)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd31);
LabelClosureBody31:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 2; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop34:
CMP(R5,IMM(2));
JUMP_GE(LabelEnvLoopExit34);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop34);
LabelEnvLoopExit34: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop34:
CMP(R5,IMM(3));
JUMP_GE(LabelparamsoopExit34);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop34);
LabelparamsoopExit34: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody34)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd34);
LabelClosureBody34:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 3; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop35:
CMP(R5,IMM(3));
JUMP_GE(LabelEnvLoopExit35);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop35);
LabelEnvLoopExit35: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop35:
CMP(R5,IMM(3));
JUMP_GE(LabelparamsoopExit35);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop35);
LabelparamsoopExit35: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody35)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd35);
LabelClosureBody35:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* CodeGen:*/
/* - If Expression - */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(693)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

CMP(R0, FALSE);
JUMP_EQ(LabelIf3Else6);
/* In constants .. */
MOV(R0,IMM(2));
JUMP(LabelIf3Exit6);
LabelIf3Else6:


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);
/* --- F-Var: --- */
MOV(R1, IMM(603)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
PUSH(IMM(2)) // Push Num of args;

/* The Compiled Function: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(2)) // Push Num of args;

/* The Compiled Function: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */


/* ---------------------------------------------- */
/*                  Applic Code: */
/* ---------------------------------------------- */
/* Compiled params, in reverse order: */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);
/* --- F-Var: --- */
MOV(R1, IMM(608)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
PUSH(IMM(2)) // Push Num of args;

/* The Compiled Function: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
PUSH(IMM(2)) // Push Num of args;

/* The Compiled Function: */
/* --- F-Var: --- */
MOV(R1, IMM(578)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(2));
/* Compile function and add it's code: */
/* --- F-Var: --- */
MOV(R1, IMM(613)); // Value of Free var bucket.Address
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(3)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop30:
CMP(R4, IMM(5));
JUMP_EQ(LabelTailExit30);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop30);
LabelTailExit30:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

LabelIf3Exit6:
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd35:
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd34:

PUSH(R0);
PUSH(IMM(1)) // Push Num of args;

/* The Compiled Function: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(1));
/* Compile function and add it's code: */


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 2; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop32:
CMP(R5,IMM(2));
JUMP_GE(LabelEnvLoopExit32);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop32);
LabelEnvLoopExit32: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop32:
CMP(R5,IMM(3));
JUMP_GE(LabelparamsoopExit32);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop32);
LabelparamsoopExit32: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody32)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd32);
LabelClosureBody32:
PUSH(FP);
MOV(FP, SP);
/* -- createLambdaSimpleBody -- */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* CodeGen:*/


/* ---------------------------------------------- */
/*               Lambda Code: */
/* ---------------------------------------------- */
/* Malloc 3 for: closure, env and the body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

MOV(R10,R0); /* R10 holds Addr of malloc */
MOV(INDD(R10,0), IMM(T_CLOSURE)); /* set T_Closure to location 0 */
/* Malloc(env.size()+1): */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
MOV(R2,R0); /* R2 -> new env addr */
MOV(R3, FPARG(0)); /* R3 = old env adress */
/*Clone the new environment:
for (i = 1, j = 0; j < 3; j++, i++) /* R4 = i, R5 = jMOV(INDD(R2, IMM(i)), INDD(R3, IMM(j)) */;
MOV(R4, IMM(1));
MOV(R5, IMM(0));
LabelEnvLoop33:
CMP(R5,IMM(3));
JUMP_GE(LabelEnvLoopExit33);
MOV(INDD(R2, R4), INDD(R3, R5));
INCR(R4);
INCR(R5);
JUMP(LabelEnvLoop33);
LabelEnvLoopExit33: 
/* Clone the parameters (If needed) - Malloc(params.length): ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

MOV(R3, R0); // R3 -> params.addr.. 
/* Loop through parameters and clone them (R5 = 2, R6 is the loop counter): */
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
Labelparamsoop33:
CMP(R5,IMM(3));
JUMP_GE(LabelparamsoopExit33);
MOV(INDD(R3, R6), FPARG(R5));
//R2[0] -> new parameters
INCR(R5);
INCR(R6);
JUMP(Labelparamsoop33);
LabelparamsoopExit33: 
MOV(INDD(R10, 1), R2); // Parameters copied. the new env is at 1.
MOV(INDD(R10, IMM(2)), LABEL(LabelClosureBody33)); // Append the body
MOV(R0, R10);
JUMP(LabelClosureEnd33);
LabelClosureBody33:
PUSH(FP);
MOV(FP, SP);
/* - LabmdaOpt-Body: -*/
POP(R1);  // Old FP
POP(R2);  // Return addr
POP(R3);  // Env
POP(R4);  // args count
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R6,IMM(0));
MOV(R5,R0);
LabelOptCopy2:
CMP(R6, IMM(1));
JUMP_EQ(LabelOptCopyExit2);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(LabelOptCopy2);
LabelOptCopyExit2:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
/* - Inserting to stack - */
PUSH(R8);
MOV(R6, IMM(0));
LabelOptCopy22:
CMP(R6, IMM(-1));
JUMP_EQ(LabelOptCopy2Exit2);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(LabelOptCopy22);
LabelOptCopy2Exit2:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);


/* ---------------------------------------------- */
/*                  Tail Applic Code: */
/* ---------------------------------------------- */
/* --- P-Var: --- */
MOV(R0, FPARG(3));

PUSH(R0);
/* --- P-Var: --- */
MOV(R0, FPARG(2));

PUSH(R0);
 // Compile params and push (in reverse).
/* push number of args. */
PUSH(IMM(2));
/* Compile function and add it's code: */
/* --- B-Var: --- */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(3)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop29:
CMP(R4, IMM(5));
JUMP_EQ(LabelTailExit29);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop29);
LabelTailExit29:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
LabelClosureEnd33:
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd32:
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop28:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit28);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop28);
LabelTailExit28:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd31:
CMP(INDD(R0,0), IMM(T_CLOSURE)); // Check for errors
JUMP_NE(ERROR);
PUSH(INDD(R0,1)); // Push Environment
PUSH(FPARG(-1)); // Push Ret addr (from current frame)
MOV(R4, IMM(0)); // R4 will be the index
MOV(R6, IMM(2)); // R6 = Old STARG.offset
MOV(R8,FPARG(-2)); // R8 = old FP
MOV(R12,FPARG(1)); // R12 = Old argsCount
MOV(R13,STARG(1)); // R13 = New argsCount
MOV(R5, R12); // R5 = Old FPARG.offset
ADD(R5, IMM(1));
LabelTailLoop27:
CMP(R4, IMM(4));
JUMP_EQ(LabelTailExit27);
MOV(FPARG(R5), STARG(R6));
ADD(R4, IMM(1));
SUB(R5, IMM(1));
SUB(R6, IMM(1));
JUMP(LabelTailLoop27);
LabelTailExit27:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* CodeGen-End*/

POP(FP);
RETURN;
LabelClosureEnd30:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0, IMM(1)));
CALLA(INDD(R0, IMM(2)));
MOV(R5,STARG(IMM(0))) // R5 = Number of args to drop;
ADD(R5, IMM(2)) // R5 = R5 + env + numOfArgs;
DROP(R5);

MOV(ADDR(488), R0);
MOV(R0, SOB_VOID);


CALL(PRINT_R0_VALUE);



/* In constants .. */
MOV(R0,IMM(1133));

CALL(PRINT_R0_VALUE);

POP(FP);
DROP(IMM(3));
PROG_ENDING:
STOP_MACHINE;
return 0;
}
