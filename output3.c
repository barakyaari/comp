#include <stdio.h>
#include <stdlib.h>
#include "arch/cisc.h"
int main() {
#define SOB_TRUE 5
#define SOB_FALSE 3
#define SOB_NIL 2
#define SOB_VOID 1
#define LOC_ENV 0
#define LOC_NUM_ARGS 1
#define SYM_TAB_START 1413 
START_MACHINE;
JUMP(LETS_START);
#include "arch/char.lib"
#include "arch/io.lib"
#include "arch/scheme.lib"
#include "arch/math.lib"
#include "arch/string.lib"
#include "arch/system.lib"
#include "arch/project_proc.lib"
ERROR:
HALT;
LETS_START:
PUSH(0);
PUSH(0);
PUSH(0);
PUSH(FP);
MOV(FP, SP);
MOV(IND(0), IMM(2209));
MOV(IND(IMM(1)), IMM(937610));
MOV(IND(IMM(2)), IMM(722689));
MOV(IND(IMM(3)), IMM(741553));
MOV(IND(IMM(4)), IMM(0));
MOV(IND(IMM(5)), IMM(741553));
MOV(IND(IMM(6)), IMM(1));
MOV(IND(IMM(10)), IMM(799345));
MOV(IND(IMM(11)), IMM(5));
MOV(IND(IMM(12)), IMM(109));
MOV(IND(IMM(13)), IMM(97));
MOV(IND(IMM(14)), IMM(116));
MOV(IND(IMM(15)), IMM(99));
MOV(IND(IMM(16)), IMM(104));
MOV(IND(IMM(17)), IMM(799345));
MOV(IND(IMM(18)), IMM(3));
MOV(IND(IMM(19)), IMM(109));
MOV(IND(IMM(20)), IMM(105));
MOV(IND(IMM(21)), IMM(110));
MOV(IND(IMM(22)), IMM(799345));
MOV(IND(IMM(23)), IMM(3));
MOV(IND(IMM(24)), IMM(109));
MOV(IND(IMM(25)), IMM(97));
MOV(IND(IMM(26)), IMM(120));
MOV(IND(IMM(27)), IMM(799345));
MOV(IND(IMM(28)), IMM(9));
MOV(IND(IMM(29)), IMM(108));
MOV(IND(IMM(30)), IMM(105));
MOV(IND(IMM(31)), IMM(115));
MOV(IND(IMM(32)), IMM(116));
MOV(IND(IMM(33)), IMM(45));
MOV(IND(IMM(34)), IMM(115));
MOV(IND(IMM(35)), IMM(101));
MOV(IND(IMM(36)), IMM(116));
MOV(IND(IMM(37)), IMM(33));
MOV(IND(IMM(38)), IMM(799345));
MOV(IND(IMM(39)), IMM(14));
MOV(IND(IMM(40)), IMM(115));
MOV(IND(IMM(41)), IMM(116));
MOV(IND(IMM(42)), IMM(114));
MOV(IND(IMM(43)), IMM(105));
MOV(IND(IMM(44)), IMM(110));
MOV(IND(IMM(45)), IMM(103));
MOV(IND(IMM(46)), IMM(45));
MOV(IND(IMM(47)), IMM(114));
MOV(IND(IMM(48)), IMM(101));
MOV(IND(IMM(49)), IMM(118));
MOV(IND(IMM(50)), IMM(101));
MOV(IND(IMM(51)), IMM(114));
MOV(IND(IMM(52)), IMM(115));
MOV(IND(IMM(53)), IMM(101));
MOV(IND(IMM(54)), IMM(799345));
MOV(IND(IMM(55)), IMM(7));
MOV(IND(IMM(56)), IMM(114));
MOV(IND(IMM(57)), IMM(101));
MOV(IND(IMM(58)), IMM(118));
MOV(IND(IMM(59)), IMM(101));
MOV(IND(IMM(60)), IMM(114));
MOV(IND(IMM(61)), IMM(115));
MOV(IND(IMM(62)), IMM(101));
MOV(IND(IMM(63)), IMM(799345));
MOV(IND(IMM(64)), IMM(13));
MOV(IND(IMM(65)), IMM(118));
MOV(IND(IMM(66)), IMM(101));
MOV(IND(IMM(67)), IMM(99));
MOV(IND(IMM(68)), IMM(116));
MOV(IND(IMM(69)), IMM(111));
MOV(IND(IMM(70)), IMM(114));
MOV(IND(IMM(71)), IMM(45));
MOV(IND(IMM(72)), IMM(97));
MOV(IND(IMM(73)), IMM(112));
MOV(IND(IMM(74)), IMM(112));
MOV(IND(IMM(75)), IMM(101));
MOV(IND(IMM(76)), IMM(110));
MOV(IND(IMM(77)), IMM(100));
MOV(IND(IMM(78)), IMM(799345));
MOV(IND(IMM(79)), IMM(6));
MOV(IND(IMM(80)), IMM(97));
MOV(IND(IMM(81)), IMM(112));
MOV(IND(IMM(82)), IMM(112));
MOV(IND(IMM(83)), IMM(101));
MOV(IND(IMM(84)), IMM(110));
MOV(IND(IMM(85)), IMM(100));
MOV(IND(IMM(86)), IMM(799345));
MOV(IND(IMM(87)), IMM(13));
MOV(IND(IMM(88)), IMM(115));
MOV(IND(IMM(89)), IMM(116));
MOV(IND(IMM(90)), IMM(114));
MOV(IND(IMM(91)), IMM(105));
MOV(IND(IMM(92)), IMM(110));
MOV(IND(IMM(93)), IMM(103));
MOV(IND(IMM(94)), IMM(45));
MOV(IND(IMM(95)), IMM(97));
MOV(IND(IMM(96)), IMM(112));
MOV(IND(IMM(97)), IMM(112));
MOV(IND(IMM(98)), IMM(101));
MOV(IND(IMM(99)), IMM(110));
MOV(IND(IMM(100)), IMM(100));
MOV(IND(IMM(101)), IMM(799345));
MOV(IND(IMM(102)), IMM(5));
MOV(IND(IMM(103)), IMM(118));
MOV(IND(IMM(104)), IMM(111));
MOV(IND(IMM(105)), IMM(105));
MOV(IND(IMM(106)), IMM(100));
MOV(IND(IMM(107)), IMM(63));
MOV(IND(IMM(108)), IMM(799345));
MOV(IND(IMM(109)), IMM(4));
MOV(IND(IMM(110)), IMM(118));
MOV(IND(IMM(111)), IMM(111));
MOV(IND(IMM(112)), IMM(105));
MOV(IND(IMM(113)), IMM(100));
MOV(IND(IMM(114)), IMM(799345));
MOV(IND(IMM(115)), IMM(4));
MOV(IND(IMM(116)), IMM(97));
MOV(IND(IMM(117)), IMM(115));
MOV(IND(IMM(118)), IMM(115));
MOV(IND(IMM(119)), IMM(113));
MOV(IND(IMM(120)), IMM(799345));
MOV(IND(IMM(121)), IMM(5));
MOV(IND(IMM(122)), IMM(97));
MOV(IND(IMM(123)), IMM(115));
MOV(IND(IMM(124)), IMM(115));
MOV(IND(IMM(125)), IMM(111));
MOV(IND(IMM(126)), IMM(99));
MOV(IND(IMM(127)), IMM(799345));
MOV(IND(IMM(128)), IMM(10));
MOV(IND(IMM(129)), IMM(94));
MOV(IND(IMM(130)), IMM(97));
MOV(IND(IMM(131)), IMM(115));
MOV(IND(IMM(132)), IMM(115));
MOV(IND(IMM(133)), IMM(111));
MOV(IND(IMM(134)), IMM(99));
MOV(IND(IMM(135)), IMM(105));
MOV(IND(IMM(136)), IMM(97));
MOV(IND(IMM(137)), IMM(116));
MOV(IND(IMM(138)), IMM(101));
MOV(IND(IMM(139)), IMM(799345));
MOV(IND(IMM(140)), IMM(9));
MOV(IND(IMM(141)), IMM(98));
MOV(IND(IMM(142)), IMM(111));
MOV(IND(IMM(143)), IMM(111));
MOV(IND(IMM(144)), IMM(108));
MOV(IND(IMM(145)), IMM(101));
MOV(IND(IMM(146)), IMM(97));
MOV(IND(IMM(147)), IMM(110));
MOV(IND(IMM(148)), IMM(61));
MOV(IND(IMM(149)), IMM(63));
MOV(IND(IMM(150)), IMM(799345));
MOV(IND(IMM(151)), IMM(6));
MOV(IND(IMM(152)), IMM(101));
MOV(IND(IMM(153)), IMM(113));
MOV(IND(IMM(154)), IMM(117));
MOV(IND(IMM(155)), IMM(97));
MOV(IND(IMM(156)), IMM(108));
MOV(IND(IMM(157)), IMM(63));
MOV(IND(IMM(158)), IMM(799345));
MOV(IND(IMM(159)), IMM(6));
MOV(IND(IMM(160)), IMM(109));
MOV(IND(IMM(161)), IMM(101));
MOV(IND(IMM(162)), IMM(109));
MOV(IND(IMM(163)), IMM(98));
MOV(IND(IMM(164)), IMM(101));
MOV(IND(IMM(165)), IMM(114));
MOV(IND(IMM(166)), IMM(799345));
MOV(IND(IMM(167)), IMM(12));
MOV(IND(IMM(168)), IMM(118));
MOV(IND(IMM(169)), IMM(101));
MOV(IND(IMM(170)), IMM(99));
MOV(IND(IMM(171)), IMM(116));
MOV(IND(IMM(172)), IMM(111));
MOV(IND(IMM(173)), IMM(114));
MOV(IND(IMM(174)), IMM(45));
MOV(IND(IMM(175)), IMM(62));
MOV(IND(IMM(176)), IMM(108));
MOV(IND(IMM(177)), IMM(105));
MOV(IND(IMM(178)), IMM(115));
MOV(IND(IMM(179)), IMM(116));
MOV(IND(IMM(180)), IMM(799345));
MOV(IND(IMM(181)), IMM(9));
MOV(IND(IMM(182)), IMM(115));
MOV(IND(IMM(183)), IMM(116));
MOV(IND(IMM(184)), IMM(114));
MOV(IND(IMM(185)), IMM(105));
MOV(IND(IMM(186)), IMM(110));
MOV(IND(IMM(187)), IMM(103));
MOV(IND(IMM(188)), IMM(62));
MOV(IND(IMM(189)), IMM(61));
MOV(IND(IMM(190)), IMM(63));
MOV(IND(IMM(191)), IMM(799345));
MOV(IND(IMM(192)), IMM(9));
MOV(IND(IMM(193)), IMM(115));
MOV(IND(IMM(194)), IMM(116));
MOV(IND(IMM(195)), IMM(114));
MOV(IND(IMM(196)), IMM(105));
MOV(IND(IMM(197)), IMM(110));
MOV(IND(IMM(198)), IMM(103));
MOV(IND(IMM(199)), IMM(60));
MOV(IND(IMM(200)), IMM(61));
MOV(IND(IMM(201)), IMM(63));
MOV(IND(IMM(202)), IMM(799345));
MOV(IND(IMM(203)), IMM(8));
MOV(IND(IMM(204)), IMM(115));
MOV(IND(IMM(205)), IMM(116));
MOV(IND(IMM(206)), IMM(114));
MOV(IND(IMM(207)), IMM(105));
MOV(IND(IMM(208)), IMM(110));
MOV(IND(IMM(209)), IMM(103));
MOV(IND(IMM(210)), IMM(62));
MOV(IND(IMM(211)), IMM(63));
MOV(IND(IMM(212)), IMM(799345));
MOV(IND(IMM(213)), IMM(8));
MOV(IND(IMM(214)), IMM(115));
MOV(IND(IMM(215)), IMM(116));
MOV(IND(IMM(216)), IMM(114));
MOV(IND(IMM(217)), IMM(105));
MOV(IND(IMM(218)), IMM(110));
MOV(IND(IMM(219)), IMM(103));
MOV(IND(IMM(220)), IMM(60));
MOV(IND(IMM(221)), IMM(63));
MOV(IND(IMM(222)), IMM(799345));
MOV(IND(IMM(223)), IMM(8));
MOV(IND(IMM(224)), IMM(115));
MOV(IND(IMM(225)), IMM(116));
MOV(IND(IMM(226)), IMM(114));
MOV(IND(IMM(227)), IMM(105));
MOV(IND(IMM(228)), IMM(110));
MOV(IND(IMM(229)), IMM(103));
MOV(IND(IMM(230)), IMM(61));
MOV(IND(IMM(231)), IMM(63));
MOV(IND(IMM(232)), IMM(799345));
MOV(IND(IMM(233)), IMM(16));
MOV(IND(IMM(234)), IMM(98));
MOV(IND(IMM(235)), IMM(105));
MOV(IND(IMM(236)), IMM(110));
MOV(IND(IMM(237)), IMM(97));
MOV(IND(IMM(238)), IMM(114));
MOV(IND(IMM(239)), IMM(121));
MOV(IND(IMM(240)), IMM(45));
MOV(IND(IMM(241)), IMM(115));
MOV(IND(IMM(242)), IMM(116));
MOV(IND(IMM(243)), IMM(114));
MOV(IND(IMM(244)), IMM(105));
MOV(IND(IMM(245)), IMM(110));
MOV(IND(IMM(246)), IMM(103));
MOV(IND(IMM(247)), IMM(62));
MOV(IND(IMM(248)), IMM(61));
MOV(IND(IMM(249)), IMM(63));
MOV(IND(IMM(250)), IMM(799345));
MOV(IND(IMM(251)), IMM(16));
MOV(IND(IMM(252)), IMM(98));
MOV(IND(IMM(253)), IMM(105));
MOV(IND(IMM(254)), IMM(110));
MOV(IND(IMM(255)), IMM(97));
MOV(IND(IMM(256)), IMM(114));
MOV(IND(IMM(257)), IMM(121));
MOV(IND(IMM(258)), IMM(45));
MOV(IND(IMM(259)), IMM(115));
MOV(IND(IMM(260)), IMM(116));
MOV(IND(IMM(261)), IMM(114));
MOV(IND(IMM(262)), IMM(105));
MOV(IND(IMM(263)), IMM(110));
MOV(IND(IMM(264)), IMM(103));
MOV(IND(IMM(265)), IMM(60));
MOV(IND(IMM(266)), IMM(61));
MOV(IND(IMM(267)), IMM(63));
MOV(IND(IMM(268)), IMM(799345));
MOV(IND(IMM(269)), IMM(15));
MOV(IND(IMM(270)), IMM(98));
MOV(IND(IMM(271)), IMM(105));
MOV(IND(IMM(272)), IMM(110));
MOV(IND(IMM(273)), IMM(97));
MOV(IND(IMM(274)), IMM(114));
MOV(IND(IMM(275)), IMM(121));
MOV(IND(IMM(276)), IMM(45));
MOV(IND(IMM(277)), IMM(115));
MOV(IND(IMM(278)), IMM(116));
MOV(IND(IMM(279)), IMM(114));
MOV(IND(IMM(280)), IMM(105));
MOV(IND(IMM(281)), IMM(110));
MOV(IND(IMM(282)), IMM(103));
MOV(IND(IMM(283)), IMM(62));
MOV(IND(IMM(284)), IMM(63));
MOV(IND(IMM(285)), IMM(799345));
MOV(IND(IMM(286)), IMM(15));
MOV(IND(IMM(287)), IMM(98));
MOV(IND(IMM(288)), IMM(105));
MOV(IND(IMM(289)), IMM(110));
MOV(IND(IMM(290)), IMM(97));
MOV(IND(IMM(291)), IMM(114));
MOV(IND(IMM(292)), IMM(121));
MOV(IND(IMM(293)), IMM(45));
MOV(IND(IMM(294)), IMM(115));
MOV(IND(IMM(295)), IMM(116));
MOV(IND(IMM(296)), IMM(114));
MOV(IND(IMM(297)), IMM(105));
MOV(IND(IMM(298)), IMM(110));
MOV(IND(IMM(299)), IMM(103));
MOV(IND(IMM(300)), IMM(60));
MOV(IND(IMM(301)), IMM(63));
MOV(IND(IMM(302)), IMM(799345));
MOV(IND(IMM(303)), IMM(15));
MOV(IND(IMM(304)), IMM(98));
MOV(IND(IMM(305)), IMM(105));
MOV(IND(IMM(306)), IMM(110));
MOV(IND(IMM(307)), IMM(97));
MOV(IND(IMM(308)), IMM(114));
MOV(IND(IMM(309)), IMM(121));
MOV(IND(IMM(310)), IMM(45));
MOV(IND(IMM(311)), IMM(115));
MOV(IND(IMM(312)), IMM(116));
MOV(IND(IMM(313)), IMM(114));
MOV(IND(IMM(314)), IMM(105));
MOV(IND(IMM(315)), IMM(110));
MOV(IND(IMM(316)), IMM(103));
MOV(IND(IMM(317)), IMM(61));
MOV(IND(IMM(318)), IMM(63));
MOV(IND(IMM(319)), IMM(799345));
MOV(IND(IMM(320)), IMM(12));
MOV(IND(IMM(321)), IMM(108));
MOV(IND(IMM(322)), IMM(105));
MOV(IND(IMM(323)), IMM(115));
MOV(IND(IMM(324)), IMM(116));
MOV(IND(IMM(325)), IMM(45));
MOV(IND(IMM(326)), IMM(62));
MOV(IND(IMM(327)), IMM(118));
MOV(IND(IMM(328)), IMM(101));
MOV(IND(IMM(329)), IMM(99));
MOV(IND(IMM(330)), IMM(116));
MOV(IND(IMM(331)), IMM(111));
MOV(IND(IMM(332)), IMM(114));
MOV(IND(IMM(333)), IMM(799345));
MOV(IND(IMM(334)), IMM(9));
MOV(IND(IMM(335)), IMM(112));
MOV(IND(IMM(336)), IMM(111));
MOV(IND(IMM(337)), IMM(115));
MOV(IND(IMM(338)), IMM(105));
MOV(IND(IMM(339)), IMM(116));
MOV(IND(IMM(340)), IMM(105));
MOV(IND(IMM(341)), IMM(118));
MOV(IND(IMM(342)), IMM(101));
MOV(IND(IMM(343)), IMM(63));
MOV(IND(IMM(344)), IMM(799345));
MOV(IND(IMM(345)), IMM(9));
MOV(IND(IMM(346)), IMM(110));
MOV(IND(IMM(347)), IMM(101));
MOV(IND(IMM(348)), IMM(103));
MOV(IND(IMM(349)), IMM(97));
MOV(IND(IMM(350)), IMM(116));
MOV(IND(IMM(351)), IMM(105));
MOV(IND(IMM(352)), IMM(118));
MOV(IND(IMM(353)), IMM(101));
MOV(IND(IMM(354)), IMM(63));
MOV(IND(IMM(355)), IMM(799345));
MOV(IND(IMM(356)), IMM(7));
MOV(IND(IMM(357)), IMM(109));
MOV(IND(IMM(358)), IMM(101));
MOV(IND(IMM(359)), IMM(109));
MOV(IND(IMM(360)), IMM(98));
MOV(IND(IMM(361)), IMM(101));
MOV(IND(IMM(362)), IMM(114));
MOV(IND(IMM(363)), IMM(63));
MOV(IND(IMM(364)), IMM(799345));
MOV(IND(IMM(365)), IMM(5));
MOV(IND(IMM(366)), IMM(108));
MOV(IND(IMM(367)), IMM(105));
MOV(IND(IMM(368)), IMM(115));
MOV(IND(IMM(369)), IMM(116));
MOV(IND(IMM(370)), IMM(63));
MOV(IND(IMM(371)), IMM(799345));
MOV(IND(IMM(372)), IMM(8));
MOV(IND(IMM(373)), IMM(108));
MOV(IND(IMM(374)), IMM(105));
MOV(IND(IMM(375)), IMM(115));
MOV(IND(IMM(376)), IMM(116));
MOV(IND(IMM(377)), IMM(45));
MOV(IND(IMM(378)), IMM(114));
MOV(IND(IMM(379)), IMM(101));
MOV(IND(IMM(380)), IMM(102));
MOV(IND(IMM(381)), IMM(799345));
MOV(IND(IMM(382)), IMM(4));
MOV(IND(IMM(383)), IMM(111));
MOV(IND(IMM(384)), IMM(100));
MOV(IND(IMM(385)), IMM(100));
MOV(IND(IMM(386)), IMM(63));
MOV(IND(IMM(387)), IMM(799345));
MOV(IND(IMM(388)), IMM(9));
MOV(IND(IMM(389)), IMM(114));
MOV(IND(IMM(390)), IMM(101));
MOV(IND(IMM(391)), IMM(109));
MOV(IND(IMM(392)), IMM(97));
MOV(IND(IMM(393)), IMM(105));
MOV(IND(IMM(394)), IMM(110));
MOV(IND(IMM(395)), IMM(100));
MOV(IND(IMM(396)), IMM(101));
MOV(IND(IMM(397)), IMM(114));
MOV(IND(IMM(398)), IMM(799345));
MOV(IND(IMM(399)), IMM(5));
MOV(IND(IMM(400)), IMM(101));
MOV(IND(IMM(401)), IMM(118));
MOV(IND(IMM(402)), IMM(101));
MOV(IND(IMM(403)), IMM(110));
MOV(IND(IMM(404)), IMM(63));
MOV(IND(IMM(405)), IMM(799345));
MOV(IND(IMM(406)), IMM(15));
MOV(IND(IMM(407)), IMM(115));
MOV(IND(IMM(408)), IMM(116));
MOV(IND(IMM(409)), IMM(114));
MOV(IND(IMM(410)), IMM(105));
MOV(IND(IMM(411)), IMM(110));
MOV(IND(IMM(412)), IMM(103));
MOV(IND(IMM(413)), IMM(45));
MOV(IND(IMM(414)), IMM(100));
MOV(IND(IMM(415)), IMM(111));
MOV(IND(IMM(416)), IMM(119));
MOV(IND(IMM(417)), IMM(110));
MOV(IND(IMM(418)), IMM(99));
MOV(IND(IMM(419)), IMM(97));
MOV(IND(IMM(420)), IMM(115));
MOV(IND(IMM(421)), IMM(101));
MOV(IND(IMM(422)), IMM(799345));
MOV(IND(IMM(423)), IMM(12));
MOV(IND(IMM(424)), IMM(115));
MOV(IND(IMM(425)), IMM(116));
MOV(IND(IMM(426)), IMM(114));
MOV(IND(IMM(427)), IMM(105));
MOV(IND(IMM(428)), IMM(110));
MOV(IND(IMM(429)), IMM(103));
MOV(IND(IMM(430)), IMM(45));
MOV(IND(IMM(431)), IMM(62));
MOV(IND(IMM(432)), IMM(108));
MOV(IND(IMM(433)), IMM(105));
MOV(IND(IMM(434)), IMM(115));
MOV(IND(IMM(435)), IMM(116));
MOV(IND(IMM(436)), IMM(799345));
MOV(IND(IMM(437)), IMM(12));
MOV(IND(IMM(438)), IMM(108));
MOV(IND(IMM(439)), IMM(105));
MOV(IND(IMM(440)), IMM(115));
MOV(IND(IMM(441)), IMM(116));
MOV(IND(IMM(442)), IMM(45));
MOV(IND(IMM(443)), IMM(62));
MOV(IND(IMM(444)), IMM(115));
MOV(IND(IMM(445)), IMM(116));
MOV(IND(IMM(446)), IMM(114));
MOV(IND(IMM(447)), IMM(105));
MOV(IND(IMM(448)), IMM(110));
MOV(IND(IMM(449)), IMM(103));
MOV(IND(IMM(450)), IMM(799345));
MOV(IND(IMM(451)), IMM(13));
MOV(IND(IMM(452)), IMM(115));
MOV(IND(IMM(453)), IMM(116));
MOV(IND(IMM(454)), IMM(114));
MOV(IND(IMM(455)), IMM(105));
MOV(IND(IMM(456)), IMM(110));
MOV(IND(IMM(457)), IMM(103));
MOV(IND(IMM(458)), IMM(45));
MOV(IND(IMM(459)), IMM(117));
MOV(IND(IMM(460)), IMM(112));
MOV(IND(IMM(461)), IMM(99));
MOV(IND(IMM(462)), IMM(97));
MOV(IND(IMM(463)), IMM(115));
MOV(IND(IMM(464)), IMM(101));
MOV(IND(IMM(465)), IMM(799345));
MOV(IND(IMM(466)), IMM(10));
MOV(IND(IMM(467)), IMM(99));
MOV(IND(IMM(468)), IMM(104));
MOV(IND(IMM(469)), IMM(97));
MOV(IND(IMM(470)), IMM(114));
MOV(IND(IMM(471)), IMM(45));
MOV(IND(IMM(472)), IMM(99));
MOV(IND(IMM(473)), IMM(105));
MOV(IND(IMM(474)), IMM(62));
MOV(IND(IMM(475)), IMM(61));
MOV(IND(IMM(476)), IMM(63));
MOV(IND(IMM(477)), IMM(799345));
MOV(IND(IMM(478)), IMM(9));
MOV(IND(IMM(479)), IMM(99));
MOV(IND(IMM(480)), IMM(104));
MOV(IND(IMM(481)), IMM(97));
MOV(IND(IMM(482)), IMM(114));
MOV(IND(IMM(483)), IMM(45));
MOV(IND(IMM(484)), IMM(99));
MOV(IND(IMM(485)), IMM(105));
MOV(IND(IMM(486)), IMM(62));
MOV(IND(IMM(487)), IMM(63));
MOV(IND(IMM(488)), IMM(799345));
MOV(IND(IMM(489)), IMM(9));
MOV(IND(IMM(490)), IMM(99));
MOV(IND(IMM(491)), IMM(104));
MOV(IND(IMM(492)), IMM(97));
MOV(IND(IMM(493)), IMM(114));
MOV(IND(IMM(494)), IMM(45));
MOV(IND(IMM(495)), IMM(99));
MOV(IND(IMM(496)), IMM(105));
MOV(IND(IMM(497)), IMM(61));
MOV(IND(IMM(498)), IMM(63));
MOV(IND(IMM(499)), IMM(799345));
MOV(IND(IMM(500)), IMM(9));
MOV(IND(IMM(501)), IMM(99));
MOV(IND(IMM(502)), IMM(104));
MOV(IND(IMM(503)), IMM(97));
MOV(IND(IMM(504)), IMM(114));
MOV(IND(IMM(505)), IMM(45));
MOV(IND(IMM(506)), IMM(99));
MOV(IND(IMM(507)), IMM(105));
MOV(IND(IMM(508)), IMM(60));
MOV(IND(IMM(509)), IMM(63));
MOV(IND(IMM(510)), IMM(799345));
MOV(IND(IMM(511)), IMM(10));
MOV(IND(IMM(512)), IMM(99));
MOV(IND(IMM(513)), IMM(104));
MOV(IND(IMM(514)), IMM(97));
MOV(IND(IMM(515)), IMM(114));
MOV(IND(IMM(516)), IMM(45));
MOV(IND(IMM(517)), IMM(99));
MOV(IND(IMM(518)), IMM(105));
MOV(IND(IMM(519)), IMM(60));
MOV(IND(IMM(520)), IMM(61));
MOV(IND(IMM(521)), IMM(63));
MOV(IND(IMM(522)), IMM(799345));
MOV(IND(IMM(523)), IMM(13));
MOV(IND(IMM(524)), IMM(99));
MOV(IND(IMM(525)), IMM(104));
MOV(IND(IMM(526)), IMM(97));
MOV(IND(IMM(527)), IMM(114));
MOV(IND(IMM(528)), IMM(45));
MOV(IND(IMM(529)), IMM(100));
MOV(IND(IMM(530)), IMM(111));
MOV(IND(IMM(531)), IMM(119));
MOV(IND(IMM(532)), IMM(110));
MOV(IND(IMM(533)), IMM(99));
MOV(IND(IMM(534)), IMM(97));
MOV(IND(IMM(535)), IMM(115));
MOV(IND(IMM(536)), IMM(101));
MOV(IND(IMM(537)), IMM(799345));
MOV(IND(IMM(538)), IMM(11));
MOV(IND(IMM(539)), IMM(99));
MOV(IND(IMM(540)), IMM(104));
MOV(IND(IMM(541)), IMM(97));
MOV(IND(IMM(542)), IMM(114));
MOV(IND(IMM(543)), IMM(45));
MOV(IND(IMM(544)), IMM(117));
MOV(IND(IMM(545)), IMM(112));
MOV(IND(IMM(546)), IMM(99));
MOV(IND(IMM(547)), IMM(97));
MOV(IND(IMM(548)), IMM(115));
MOV(IND(IMM(549)), IMM(101));
MOV(IND(IMM(550)), IMM(799345));
MOV(IND(IMM(551)), IMM(15));
MOV(IND(IMM(552)), IMM(99));
MOV(IND(IMM(553)), IMM(104));
MOV(IND(IMM(554)), IMM(97));
MOV(IND(IMM(555)), IMM(114));
MOV(IND(IMM(556)), IMM(45));
MOV(IND(IMM(557)), IMM(108));
MOV(IND(IMM(558)), IMM(111));
MOV(IND(IMM(559)), IMM(119));
MOV(IND(IMM(560)), IMM(101));
MOV(IND(IMM(561)), IMM(114));
MOV(IND(IMM(562)), IMM(99));
MOV(IND(IMM(563)), IMM(97));
MOV(IND(IMM(564)), IMM(115));
MOV(IND(IMM(565)), IMM(101));
MOV(IND(IMM(566)), IMM(63));
MOV(IND(IMM(567)), IMM(799345));
MOV(IND(IMM(568)), IMM(15));
MOV(IND(IMM(569)), IMM(99));
MOV(IND(IMM(570)), IMM(104));
MOV(IND(IMM(571)), IMM(97));
MOV(IND(IMM(572)), IMM(114));
MOV(IND(IMM(573)), IMM(45));
MOV(IND(IMM(574)), IMM(117));
MOV(IND(IMM(575)), IMM(112));
MOV(IND(IMM(576)), IMM(112));
MOV(IND(IMM(577)), IMM(101));
MOV(IND(IMM(578)), IMM(114));
MOV(IND(IMM(579)), IMM(99));
MOV(IND(IMM(580)), IMM(97));
MOV(IND(IMM(581)), IMM(115));
MOV(IND(IMM(582)), IMM(101));
MOV(IND(IMM(583)), IMM(63));
MOV(IND(IMM(584)), IMM(799345));
MOV(IND(IMM(585)), IMM(6));
MOV(IND(IMM(586)), IMM(99));
MOV(IND(IMM(587)), IMM(104));
MOV(IND(IMM(588)), IMM(97));
MOV(IND(IMM(589)), IMM(114));
MOV(IND(IMM(590)), IMM(62));
MOV(IND(IMM(591)), IMM(63));
MOV(IND(IMM(592)), IMM(799345));
MOV(IND(IMM(593)), IMM(7));
MOV(IND(IMM(594)), IMM(99));
MOV(IND(IMM(595)), IMM(104));
MOV(IND(IMM(596)), IMM(97));
MOV(IND(IMM(597)), IMM(114));
MOV(IND(IMM(598)), IMM(62));
MOV(IND(IMM(599)), IMM(61));
MOV(IND(IMM(600)), IMM(63));
MOV(IND(IMM(601)), IMM(799345));
MOV(IND(IMM(602)), IMM(6));
MOV(IND(IMM(603)), IMM(99));
MOV(IND(IMM(604)), IMM(104));
MOV(IND(IMM(605)), IMM(97));
MOV(IND(IMM(606)), IMM(114));
MOV(IND(IMM(607)), IMM(60));
MOV(IND(IMM(608)), IMM(63));
MOV(IND(IMM(609)), IMM(799345));
MOV(IND(IMM(610)), IMM(7));
MOV(IND(IMM(611)), IMM(99));
MOV(IND(IMM(612)), IMM(104));
MOV(IND(IMM(613)), IMM(97));
MOV(IND(IMM(614)), IMM(114));
MOV(IND(IMM(615)), IMM(60));
MOV(IND(IMM(616)), IMM(61));
MOV(IND(IMM(617)), IMM(63));
MOV(IND(IMM(618)), IMM(799345));
MOV(IND(IMM(619)), IMM(6));
MOV(IND(IMM(620)), IMM(99));
MOV(IND(IMM(621)), IMM(104));
MOV(IND(IMM(622)), IMM(97));
MOV(IND(IMM(623)), IMM(114));
MOV(IND(IMM(624)), IMM(61));
MOV(IND(IMM(625)), IMM(63));
MOV(IND(IMM(626)), IMM(799345));
MOV(IND(IMM(627)), IMM(8));
MOV(IND(IMM(628)), IMM(94));
MOV(IND(IMM(629)), IMM(99));
MOV(IND(IMM(630)), IMM(104));
MOV(IND(IMM(631)), IMM(97));
MOV(IND(IMM(632)), IMM(114));
MOV(IND(IMM(633)), IMM(45));
MOV(IND(IMM(634)), IMM(111));
MOV(IND(IMM(635)), IMM(112));
MOV(IND(IMM(636)), IMM(799345));
MOV(IND(IMM(637)), IMM(26));
MOV(IND(IMM(638)), IMM(94));
MOV(IND(IMM(639)), IMM(118));
MOV(IND(IMM(640)), IMM(97));
MOV(IND(IMM(641)), IMM(114));
MOV(IND(IMM(642)), IMM(105));
MOV(IND(IMM(643)), IMM(97));
MOV(IND(IMM(644)), IMM(100));
MOV(IND(IMM(645)), IMM(105));
MOV(IND(IMM(646)), IMM(99));
MOV(IND(IMM(647)), IMM(45));
MOV(IND(IMM(648)), IMM(108));
MOV(IND(IMM(649)), IMM(101));
MOV(IND(IMM(650)), IMM(102));
MOV(IND(IMM(651)), IMM(116));
MOV(IND(IMM(652)), IMM(45));
MOV(IND(IMM(653)), IMM(102));
MOV(IND(IMM(654)), IMM(114));
MOV(IND(IMM(655)), IMM(111));
MOV(IND(IMM(656)), IMM(109));
MOV(IND(IMM(657)), IMM(45));
MOV(IND(IMM(658)), IMM(98));
MOV(IND(IMM(659)), IMM(105));
MOV(IND(IMM(660)), IMM(110));
MOV(IND(IMM(661)), IMM(97));
MOV(IND(IMM(662)), IMM(114));
MOV(IND(IMM(663)), IMM(121));
MOV(IND(IMM(664)), IMM(799345));
MOV(IND(IMM(665)), IMM(27));
MOV(IND(IMM(666)), IMM(94));
MOV(IND(IMM(667)), IMM(118));
MOV(IND(IMM(668)), IMM(97));
MOV(IND(IMM(669)), IMM(114));
MOV(IND(IMM(670)), IMM(105));
MOV(IND(IMM(671)), IMM(97));
MOV(IND(IMM(672)), IMM(100));
MOV(IND(IMM(673)), IMM(105));
MOV(IND(IMM(674)), IMM(99));
MOV(IND(IMM(675)), IMM(45));
MOV(IND(IMM(676)), IMM(114));
MOV(IND(IMM(677)), IMM(105));
MOV(IND(IMM(678)), IMM(103));
MOV(IND(IMM(679)), IMM(104));
MOV(IND(IMM(680)), IMM(116));
MOV(IND(IMM(681)), IMM(45));
MOV(IND(IMM(682)), IMM(102));
MOV(IND(IMM(683)), IMM(114));
MOV(IND(IMM(684)), IMM(111));
MOV(IND(IMM(685)), IMM(109));
MOV(IND(IMM(686)), IMM(45));
MOV(IND(IMM(687)), IMM(98));
MOV(IND(IMM(688)), IMM(105));
MOV(IND(IMM(689)), IMM(110));
MOV(IND(IMM(690)), IMM(97));
MOV(IND(IMM(691)), IMM(114));
MOV(IND(IMM(692)), IMM(121));
MOV(IND(IMM(693)), IMM(799345));
MOV(IND(IMM(694)), IMM(6));
MOV(IND(IMM(695)), IMM(99));
MOV(IND(IMM(696)), IMM(100));
MOV(IND(IMM(697)), IMM(100));
MOV(IND(IMM(698)), IMM(100));
MOV(IND(IMM(699)), IMM(100));
MOV(IND(IMM(700)), IMM(114));
MOV(IND(IMM(701)), IMM(799345));
MOV(IND(IMM(702)), IMM(6));
MOV(IND(IMM(703)), IMM(99));
MOV(IND(IMM(704)), IMM(100));
MOV(IND(IMM(705)), IMM(100));
MOV(IND(IMM(706)), IMM(100));
MOV(IND(IMM(707)), IMM(97));
MOV(IND(IMM(708)), IMM(114));
MOV(IND(IMM(709)), IMM(799345));
MOV(IND(IMM(710)), IMM(6));
MOV(IND(IMM(711)), IMM(99));
MOV(IND(IMM(712)), IMM(100));
MOV(IND(IMM(713)), IMM(100));
MOV(IND(IMM(714)), IMM(97));
MOV(IND(IMM(715)), IMM(100));
MOV(IND(IMM(716)), IMM(114));
MOV(IND(IMM(717)), IMM(799345));
MOV(IND(IMM(718)), IMM(6));
MOV(IND(IMM(719)), IMM(99));
MOV(IND(IMM(720)), IMM(100));
MOV(IND(IMM(721)), IMM(100));
MOV(IND(IMM(722)), IMM(97));
MOV(IND(IMM(723)), IMM(97));
MOV(IND(IMM(724)), IMM(114));
MOV(IND(IMM(725)), IMM(799345));
MOV(IND(IMM(726)), IMM(6));
MOV(IND(IMM(727)), IMM(99));
MOV(IND(IMM(728)), IMM(100));
MOV(IND(IMM(729)), IMM(97));
MOV(IND(IMM(730)), IMM(100));
MOV(IND(IMM(731)), IMM(100));
MOV(IND(IMM(732)), IMM(114));
MOV(IND(IMM(733)), IMM(799345));
MOV(IND(IMM(734)), IMM(6));
MOV(IND(IMM(735)), IMM(99));
MOV(IND(IMM(736)), IMM(100));
MOV(IND(IMM(737)), IMM(97));
MOV(IND(IMM(738)), IMM(100));
MOV(IND(IMM(739)), IMM(97));
MOV(IND(IMM(740)), IMM(114));
MOV(IND(IMM(741)), IMM(799345));
MOV(IND(IMM(742)), IMM(6));
MOV(IND(IMM(743)), IMM(99));
MOV(IND(IMM(744)), IMM(100));
MOV(IND(IMM(745)), IMM(97));
MOV(IND(IMM(746)), IMM(97));
MOV(IND(IMM(747)), IMM(100));
MOV(IND(IMM(748)), IMM(114));
MOV(IND(IMM(749)), IMM(799345));
MOV(IND(IMM(750)), IMM(6));
MOV(IND(IMM(751)), IMM(99));
MOV(IND(IMM(752)), IMM(100));
MOV(IND(IMM(753)), IMM(97));
MOV(IND(IMM(754)), IMM(97));
MOV(IND(IMM(755)), IMM(97));
MOV(IND(IMM(756)), IMM(114));
MOV(IND(IMM(757)), IMM(799345));
MOV(IND(IMM(758)), IMM(6));
MOV(IND(IMM(759)), IMM(99));
MOV(IND(IMM(760)), IMM(97));
MOV(IND(IMM(761)), IMM(100));
MOV(IND(IMM(762)), IMM(100));
MOV(IND(IMM(763)), IMM(100));
MOV(IND(IMM(764)), IMM(114));
MOV(IND(IMM(765)), IMM(799345));
MOV(IND(IMM(766)), IMM(6));
MOV(IND(IMM(767)), IMM(99));
MOV(IND(IMM(768)), IMM(97));
MOV(IND(IMM(769)), IMM(100));
MOV(IND(IMM(770)), IMM(100));
MOV(IND(IMM(771)), IMM(97));
MOV(IND(IMM(772)), IMM(114));
MOV(IND(IMM(773)), IMM(799345));
MOV(IND(IMM(774)), IMM(6));
MOV(IND(IMM(775)), IMM(99));
MOV(IND(IMM(776)), IMM(97));
MOV(IND(IMM(777)), IMM(100));
MOV(IND(IMM(778)), IMM(97));
MOV(IND(IMM(779)), IMM(100));
MOV(IND(IMM(780)), IMM(114));
MOV(IND(IMM(781)), IMM(799345));
MOV(IND(IMM(782)), IMM(6));
MOV(IND(IMM(783)), IMM(99));
MOV(IND(IMM(784)), IMM(97));
MOV(IND(IMM(785)), IMM(100));
MOV(IND(IMM(786)), IMM(97));
MOV(IND(IMM(787)), IMM(97));
MOV(IND(IMM(788)), IMM(114));
MOV(IND(IMM(789)), IMM(799345));
MOV(IND(IMM(790)), IMM(6));
MOV(IND(IMM(791)), IMM(99));
MOV(IND(IMM(792)), IMM(97));
MOV(IND(IMM(793)), IMM(97));
MOV(IND(IMM(794)), IMM(100));
MOV(IND(IMM(795)), IMM(100));
MOV(IND(IMM(796)), IMM(114));
MOV(IND(IMM(797)), IMM(799345));
MOV(IND(IMM(798)), IMM(6));
MOV(IND(IMM(799)), IMM(99));
MOV(IND(IMM(800)), IMM(97));
MOV(IND(IMM(801)), IMM(97));
MOV(IND(IMM(802)), IMM(100));
MOV(IND(IMM(803)), IMM(97));
MOV(IND(IMM(804)), IMM(114));
MOV(IND(IMM(805)), IMM(799345));
MOV(IND(IMM(806)), IMM(6));
MOV(IND(IMM(807)), IMM(99));
MOV(IND(IMM(808)), IMM(97));
MOV(IND(IMM(809)), IMM(97));
MOV(IND(IMM(810)), IMM(97));
MOV(IND(IMM(811)), IMM(100));
MOV(IND(IMM(812)), IMM(114));
MOV(IND(IMM(813)), IMM(799345));
MOV(IND(IMM(814)), IMM(6));
MOV(IND(IMM(815)), IMM(99));
MOV(IND(IMM(816)), IMM(97));
MOV(IND(IMM(817)), IMM(97));
MOV(IND(IMM(818)), IMM(97));
MOV(IND(IMM(819)), IMM(97));
MOV(IND(IMM(820)), IMM(114));
MOV(IND(IMM(821)), IMM(799345));
MOV(IND(IMM(822)), IMM(5));
MOV(IND(IMM(823)), IMM(99));
MOV(IND(IMM(824)), IMM(100));
MOV(IND(IMM(825)), IMM(100));
MOV(IND(IMM(826)), IMM(100));
MOV(IND(IMM(827)), IMM(114));
MOV(IND(IMM(828)), IMM(799345));
MOV(IND(IMM(829)), IMM(5));
MOV(IND(IMM(830)), IMM(99));
MOV(IND(IMM(831)), IMM(100));
MOV(IND(IMM(832)), IMM(100));
MOV(IND(IMM(833)), IMM(97));
MOV(IND(IMM(834)), IMM(114));
MOV(IND(IMM(835)), IMM(799345));
MOV(IND(IMM(836)), IMM(5));
MOV(IND(IMM(837)), IMM(99));
MOV(IND(IMM(838)), IMM(100));
MOV(IND(IMM(839)), IMM(97));
MOV(IND(IMM(840)), IMM(100));
MOV(IND(IMM(841)), IMM(114));
MOV(IND(IMM(842)), IMM(799345));
MOV(IND(IMM(843)), IMM(5));
MOV(IND(IMM(844)), IMM(99));
MOV(IND(IMM(845)), IMM(100));
MOV(IND(IMM(846)), IMM(97));
MOV(IND(IMM(847)), IMM(97));
MOV(IND(IMM(848)), IMM(114));
MOV(IND(IMM(849)), IMM(799345));
MOV(IND(IMM(850)), IMM(5));
MOV(IND(IMM(851)), IMM(99));
MOV(IND(IMM(852)), IMM(97));
MOV(IND(IMM(853)), IMM(100));
MOV(IND(IMM(854)), IMM(100));
MOV(IND(IMM(855)), IMM(114));
MOV(IND(IMM(856)), IMM(799345));
MOV(IND(IMM(857)), IMM(5));
MOV(IND(IMM(858)), IMM(99));
MOV(IND(IMM(859)), IMM(97));
MOV(IND(IMM(860)), IMM(100));
MOV(IND(IMM(861)), IMM(97));
MOV(IND(IMM(862)), IMM(114));
MOV(IND(IMM(863)), IMM(799345));
MOV(IND(IMM(864)), IMM(5));
MOV(IND(IMM(865)), IMM(99));
MOV(IND(IMM(866)), IMM(97));
MOV(IND(IMM(867)), IMM(97));
MOV(IND(IMM(868)), IMM(100));
MOV(IND(IMM(869)), IMM(114));
MOV(IND(IMM(870)), IMM(799345));
MOV(IND(IMM(871)), IMM(5));
MOV(IND(IMM(872)), IMM(99));
MOV(IND(IMM(873)), IMM(97));
MOV(IND(IMM(874)), IMM(97));
MOV(IND(IMM(875)), IMM(97));
MOV(IND(IMM(876)), IMM(114));
MOV(IND(IMM(877)), IMM(799345));
MOV(IND(IMM(878)), IMM(4));
MOV(IND(IMM(879)), IMM(99));
MOV(IND(IMM(880)), IMM(100));
MOV(IND(IMM(881)), IMM(100));
MOV(IND(IMM(882)), IMM(114));
MOV(IND(IMM(883)), IMM(799345));
MOV(IND(IMM(884)), IMM(4));
MOV(IND(IMM(885)), IMM(99));
MOV(IND(IMM(886)), IMM(100));
MOV(IND(IMM(887)), IMM(97));
MOV(IND(IMM(888)), IMM(114));
MOV(IND(IMM(889)), IMM(799345));
MOV(IND(IMM(890)), IMM(4));
MOV(IND(IMM(891)), IMM(99));
MOV(IND(IMM(892)), IMM(97));
MOV(IND(IMM(893)), IMM(100));
MOV(IND(IMM(894)), IMM(114));
MOV(IND(IMM(895)), IMM(799345));
MOV(IND(IMM(896)), IMM(4));
MOV(IND(IMM(897)), IMM(99));
MOV(IND(IMM(898)), IMM(97));
MOV(IND(IMM(899)), IMM(97));
MOV(IND(IMM(900)), IMM(114));
MOV(IND(IMM(901)), IMM(799345));
MOV(IND(IMM(902)), IMM(7));
MOV(IND(IMM(903)), IMM(99));
MOV(IND(IMM(904)), IMM(111));
MOV(IND(IMM(905)), IMM(109));
MOV(IND(IMM(906)), IMM(112));
MOV(IND(IMM(907)), IMM(111));
MOV(IND(IMM(908)), IMM(115));
MOV(IND(IMM(909)), IMM(101));
MOV(IND(IMM(910)), IMM(799345));
MOV(IND(IMM(911)), IMM(5));
MOV(IND(IMM(912)), IMM(102));
MOV(IND(IMM(913)), IMM(111));
MOV(IND(IMM(914)), IMM(108));
MOV(IND(IMM(915)), IMM(100));
MOV(IND(IMM(916)), IMM(114));
MOV(IND(IMM(917)), IMM(799345));
MOV(IND(IMM(918)), IMM(2));
MOV(IND(IMM(919)), IMM(60));
MOV(IND(IMM(920)), IMM(62));
MOV(IND(IMM(921)), IMM(799345));
MOV(IND(IMM(922)), IMM(2));
MOV(IND(IMM(923)), IMM(62));
MOV(IND(IMM(924)), IMM(61));
MOV(IND(IMM(925)), IMM(799345));
MOV(IND(IMM(926)), IMM(2));
MOV(IND(IMM(927)), IMM(60));
MOV(IND(IMM(928)), IMM(61));
MOV(IND(IMM(929)), IMM(799345));
MOV(IND(IMM(930)), IMM(5));
MOV(IND(IMM(931)), IMM(111));
MOV(IND(IMM(932)), IMM(114));
MOV(IND(IMM(933)), IMM(100));
MOV(IND(IMM(934)), IMM(101));
MOV(IND(IMM(935)), IMM(114));
MOV(IND(IMM(936)), IMM(799345));
MOV(IND(IMM(937)), IMM(6));
MOV(IND(IMM(938)), IMM(97));
MOV(IND(IMM(939)), IMM(110));
MOV(IND(IMM(940)), IMM(100));
MOV(IND(IMM(941)), IMM(109));
MOV(IND(IMM(942)), IMM(97));
MOV(IND(IMM(943)), IMM(112));
MOV(IND(IMM(944)), IMM(799345));
MOV(IND(IMM(945)), IMM(5));
MOV(IND(IMM(946)), IMM(111));
MOV(IND(IMM(947)), IMM(114));
MOV(IND(IMM(948)), IMM(109));
MOV(IND(IMM(949)), IMM(97));
MOV(IND(IMM(950)), IMM(112));
MOV(IND(IMM(951)), IMM(799345));
MOV(IND(IMM(952)), IMM(4));
MOV(IND(IMM(953)), IMM(115));
MOV(IND(IMM(954)), IMM(117));
MOV(IND(IMM(955)), IMM(98));
MOV(IND(IMM(956)), IMM(49));
MOV(IND(IMM(957)), IMM(799345));
MOV(IND(IMM(958)), IMM(4));
MOV(IND(IMM(959)), IMM(97));
MOV(IND(IMM(960)), IMM(100));
MOV(IND(IMM(961)), IMM(100));
MOV(IND(IMM(962)), IMM(49));
MOV(IND(IMM(963)), IMM(799345));
MOV(IND(IMM(964)), IMM(6));
MOV(IND(IMM(965)), IMM(98));
MOV(IND(IMM(966)), IMM(105));
MOV(IND(IMM(967)), IMM(110));
MOV(IND(IMM(968)), IMM(62));
MOV(IND(IMM(969)), IMM(61));
MOV(IND(IMM(970)), IMM(63));
MOV(IND(IMM(971)), IMM(799345));
MOV(IND(IMM(972)), IMM(3));
MOV(IND(IMM(973)), IMM(110));
MOV(IND(IMM(974)), IMM(111));
MOV(IND(IMM(975)), IMM(116));
MOV(IND(IMM(976)), IMM(799345));
MOV(IND(IMM(977)), IMM(6));
MOV(IND(IMM(978)), IMM(98));
MOV(IND(IMM(979)), IMM(105));
MOV(IND(IMM(980)), IMM(110));
MOV(IND(IMM(981)), IMM(60));
MOV(IND(IMM(982)), IMM(61));
MOV(IND(IMM(983)), IMM(63));
MOV(IND(IMM(984)), IMM(799345));
MOV(IND(IMM(985)), IMM(5));
MOV(IND(IMM(986)), IMM(98));
MOV(IND(IMM(987)), IMM(105));
MOV(IND(IMM(988)), IMM(110));
MOV(IND(IMM(989)), IMM(61));
MOV(IND(IMM(990)), IMM(63));
MOV(IND(IMM(991)), IMM(799345));
MOV(IND(IMM(992)), IMM(5));
MOV(IND(IMM(993)), IMM(98));
MOV(IND(IMM(994)), IMM(105));
MOV(IND(IMM(995)), IMM(110));
MOV(IND(IMM(996)), IMM(62));
MOV(IND(IMM(997)), IMM(63));
MOV(IND(IMM(998)), IMM(799345));
MOV(IND(IMM(999)), IMM(5));
MOV(IND(IMM(1000)), IMM(98));
MOV(IND(IMM(1001)), IMM(105));
MOV(IND(IMM(1002)), IMM(110));
MOV(IND(IMM(1003)), IMM(60));
MOV(IND(IMM(1004)), IMM(63));
MOV(IND(IMM(1005)), IMM(799345));
MOV(IND(IMM(1006)), IMM(4));
MOV(IND(IMM(1007)), IMM(98));
MOV(IND(IMM(1008)), IMM(105));
MOV(IND(IMM(1009)), IMM(110));
MOV(IND(IMM(1010)), IMM(47));
MOV(IND(IMM(1011)), IMM(799345));
MOV(IND(IMM(1012)), IMM(4));
MOV(IND(IMM(1013)), IMM(98));
MOV(IND(IMM(1014)), IMM(105));
MOV(IND(IMM(1015)), IMM(110));
MOV(IND(IMM(1016)), IMM(42));
MOV(IND(IMM(1017)), IMM(799345));
MOV(IND(IMM(1018)), IMM(4));
MOV(IND(IMM(1019)), IMM(98));
MOV(IND(IMM(1020)), IMM(105));
MOV(IND(IMM(1021)), IMM(110));
MOV(IND(IMM(1022)), IMM(45));
MOV(IND(IMM(1023)), IMM(799345));
MOV(IND(IMM(1024)), IMM(4));
MOV(IND(IMM(1025)), IMM(98));
MOV(IND(IMM(1026)), IMM(105));
MOV(IND(IMM(1027)), IMM(110));
MOV(IND(IMM(1028)), IMM(43));
MOV(IND(IMM(1029)), IMM(799345));
MOV(IND(IMM(1030)), IMM(2));
MOV(IND(IMM(1031)), IMM(89));
MOV(IND(IMM(1032)), IMM(109));
MOV(IND(IMM(1033)), IMM(799345));
MOV(IND(IMM(1034)), IMM(3));
MOV(IND(IMM(1035)), IMM(109));
MOV(IND(IMM(1036)), IMM(97));
MOV(IND(IMM(1037)), IMM(112));
MOV(IND(IMM(1038)), IMM(799345));
MOV(IND(IMM(1039)), IMM(8));
MOV(IND(IMM(1040)), IMM(115));
MOV(IND(IMM(1041)), IMM(101));
MOV(IND(IMM(1042)), IMM(116));
MOV(IND(IMM(1043)), IMM(45));
MOV(IND(IMM(1044)), IMM(99));
MOV(IND(IMM(1045)), IMM(97));
MOV(IND(IMM(1046)), IMM(114));
MOV(IND(IMM(1047)), IMM(33));
MOV(IND(IMM(1048)), IMM(799345));
MOV(IND(IMM(1049)), IMM(8));
MOV(IND(IMM(1050)), IMM(115));
MOV(IND(IMM(1051)), IMM(101));
MOV(IND(IMM(1052)), IMM(116));
MOV(IND(IMM(1053)), IMM(45));
MOV(IND(IMM(1054)), IMM(99));
MOV(IND(IMM(1055)), IMM(100));
MOV(IND(IMM(1056)), IMM(114));
MOV(IND(IMM(1057)), IMM(33));
MOV(IND(IMM(1058)), IMM(799345));
MOV(IND(IMM(1059)), IMM(3));
MOV(IND(IMM(1060)), IMM(101));
MOV(IND(IMM(1061)), IMM(113));
MOV(IND(IMM(1062)), IMM(63));
MOV(IND(IMM(1063)), IMM(799345));
MOV(IND(IMM(1064)), IMM(14));
MOV(IND(IMM(1065)), IMM(115));
MOV(IND(IMM(1066)), IMM(116));
MOV(IND(IMM(1067)), IMM(114));
MOV(IND(IMM(1068)), IMM(105));
MOV(IND(IMM(1069)), IMM(110));
MOV(IND(IMM(1070)), IMM(103));
MOV(IND(IMM(1071)), IMM(45));
MOV(IND(IMM(1072)), IMM(62));
MOV(IND(IMM(1073)), IMM(115));
MOV(IND(IMM(1074)), IMM(121));
MOV(IND(IMM(1075)), IMM(109));
MOV(IND(IMM(1076)), IMM(98));
MOV(IND(IMM(1077)), IMM(111));
MOV(IND(IMM(1078)), IMM(108));
MOV(IND(IMM(1079)), IMM(799345));
MOV(IND(IMM(1080)), IMM(14));
MOV(IND(IMM(1081)), IMM(115));
MOV(IND(IMM(1082)), IMM(121));
MOV(IND(IMM(1083)), IMM(109));
MOV(IND(IMM(1084)), IMM(98));
MOV(IND(IMM(1085)), IMM(111));
MOV(IND(IMM(1086)), IMM(108));
MOV(IND(IMM(1087)), IMM(45));
MOV(IND(IMM(1088)), IMM(62));
MOV(IND(IMM(1089)), IMM(115));
MOV(IND(IMM(1090)), IMM(116));
MOV(IND(IMM(1091)), IMM(114));
MOV(IND(IMM(1092)), IMM(105));
MOV(IND(IMM(1093)), IMM(110));
MOV(IND(IMM(1094)), IMM(103));
MOV(IND(IMM(1095)), IMM(799345));
MOV(IND(IMM(1096)), IMM(6));
MOV(IND(IMM(1097)), IMM(108));
MOV(IND(IMM(1098)), IMM(101));
MOV(IND(IMM(1099)), IMM(110));
MOV(IND(IMM(1100)), IMM(103));
MOV(IND(IMM(1101)), IMM(116));
MOV(IND(IMM(1102)), IMM(104));
MOV(IND(IMM(1103)), IMM(799345));
MOV(IND(IMM(1104)), IMM(5));
MOV(IND(IMM(1105)), IMM(97));
MOV(IND(IMM(1106)), IMM(112));
MOV(IND(IMM(1107)), IMM(112));
MOV(IND(IMM(1108)), IMM(108));
MOV(IND(IMM(1109)), IMM(121));
MOV(IND(IMM(1110)), IMM(799345));
MOV(IND(IMM(1111)), IMM(6));
MOV(IND(IMM(1112)), IMM(118));
MOV(IND(IMM(1113)), IMM(101));
MOV(IND(IMM(1114)), IMM(99));
MOV(IND(IMM(1115)), IMM(116));
MOV(IND(IMM(1116)), IMM(111));
MOV(IND(IMM(1117)), IMM(114));
MOV(IND(IMM(1118)), IMM(799345));
MOV(IND(IMM(1119)), IMM(4));
MOV(IND(IMM(1120)), IMM(108));
MOV(IND(IMM(1121)), IMM(105));
MOV(IND(IMM(1122)), IMM(115));
MOV(IND(IMM(1123)), IMM(116));
MOV(IND(IMM(1124)), IMM(799345));
MOV(IND(IMM(1125)), IMM(3));
MOV(IND(IMM(1126)), IMM(99));
MOV(IND(IMM(1127)), IMM(100));
MOV(IND(IMM(1128)), IMM(114));
MOV(IND(IMM(1129)), IMM(799345));
MOV(IND(IMM(1130)), IMM(3));
MOV(IND(IMM(1131)), IMM(99));
MOV(IND(IMM(1132)), IMM(97));
MOV(IND(IMM(1133)), IMM(114));
MOV(IND(IMM(1134)), IMM(799345));
MOV(IND(IMM(1135)), IMM(4));
MOV(IND(IMM(1136)), IMM(99));
MOV(IND(IMM(1137)), IMM(111));
MOV(IND(IMM(1138)), IMM(110));
MOV(IND(IMM(1139)), IMM(115));
MOV(IND(IMM(1140)), IMM(799345));
MOV(IND(IMM(1141)), IMM(11));
MOV(IND(IMM(1142)), IMM(109));
MOV(IND(IMM(1143)), IMM(97));
MOV(IND(IMM(1144)), IMM(107));
MOV(IND(IMM(1145)), IMM(101));
MOV(IND(IMM(1146)), IMM(45));
MOV(IND(IMM(1147)), IMM(118));
MOV(IND(IMM(1148)), IMM(101));
MOV(IND(IMM(1149)), IMM(99));
MOV(IND(IMM(1150)), IMM(116));
MOV(IND(IMM(1151)), IMM(111));
MOV(IND(IMM(1152)), IMM(114));
MOV(IND(IMM(1153)), IMM(799345));
MOV(IND(IMM(1154)), IMM(11));
MOV(IND(IMM(1155)), IMM(118));
MOV(IND(IMM(1156)), IMM(101));
MOV(IND(IMM(1157)), IMM(99));
MOV(IND(IMM(1158)), IMM(116));
MOV(IND(IMM(1159)), IMM(111));
MOV(IND(IMM(1160)), IMM(114));
MOV(IND(IMM(1161)), IMM(45));
MOV(IND(IMM(1162)), IMM(115));
MOV(IND(IMM(1163)), IMM(101));
MOV(IND(IMM(1164)), IMM(116));
MOV(IND(IMM(1165)), IMM(33));
MOV(IND(IMM(1166)), IMM(799345));
MOV(IND(IMM(1167)), IMM(10));
MOV(IND(IMM(1168)), IMM(118));
MOV(IND(IMM(1169)), IMM(101));
MOV(IND(IMM(1170)), IMM(99));
MOV(IND(IMM(1171)), IMM(116));
MOV(IND(IMM(1172)), IMM(111));
MOV(IND(IMM(1173)), IMM(114));
MOV(IND(IMM(1174)), IMM(45));
MOV(IND(IMM(1175)), IMM(114));
MOV(IND(IMM(1176)), IMM(101));
MOV(IND(IMM(1177)), IMM(102));
MOV(IND(IMM(1178)), IMM(799345));
MOV(IND(IMM(1179)), IMM(13));
MOV(IND(IMM(1180)), IMM(118));
MOV(IND(IMM(1181)), IMM(101));
MOV(IND(IMM(1182)), IMM(99));
MOV(IND(IMM(1183)), IMM(116));
MOV(IND(IMM(1184)), IMM(111));
MOV(IND(IMM(1185)), IMM(114));
MOV(IND(IMM(1186)), IMM(45));
MOV(IND(IMM(1187)), IMM(108));
MOV(IND(IMM(1188)), IMM(101));
MOV(IND(IMM(1189)), IMM(110));
MOV(IND(IMM(1190)), IMM(103));
MOV(IND(IMM(1191)), IMM(116));
MOV(IND(IMM(1192)), IMM(104));
MOV(IND(IMM(1193)), IMM(799345));
MOV(IND(IMM(1194)), IMM(11));
MOV(IND(IMM(1195)), IMM(109));
MOV(IND(IMM(1196)), IMM(97));
MOV(IND(IMM(1197)), IMM(107));
MOV(IND(IMM(1198)), IMM(101));
MOV(IND(IMM(1199)), IMM(45));
MOV(IND(IMM(1200)), IMM(115));
MOV(IND(IMM(1201)), IMM(116));
MOV(IND(IMM(1202)), IMM(114));
MOV(IND(IMM(1203)), IMM(105));
MOV(IND(IMM(1204)), IMM(110));
MOV(IND(IMM(1205)), IMM(103));
MOV(IND(IMM(1206)), IMM(799345));
MOV(IND(IMM(1207)), IMM(11));
MOV(IND(IMM(1208)), IMM(115));
MOV(IND(IMM(1209)), IMM(116));
MOV(IND(IMM(1210)), IMM(114));
MOV(IND(IMM(1211)), IMM(105));
MOV(IND(IMM(1212)), IMM(110));
MOV(IND(IMM(1213)), IMM(103));
MOV(IND(IMM(1214)), IMM(45));
MOV(IND(IMM(1215)), IMM(115));
MOV(IND(IMM(1216)), IMM(101));
MOV(IND(IMM(1217)), IMM(116));
MOV(IND(IMM(1218)), IMM(33));
MOV(IND(IMM(1219)), IMM(799345));
MOV(IND(IMM(1220)), IMM(10));
MOV(IND(IMM(1221)), IMM(115));
MOV(IND(IMM(1222)), IMM(116));
MOV(IND(IMM(1223)), IMM(114));
MOV(IND(IMM(1224)), IMM(105));
MOV(IND(IMM(1225)), IMM(110));
MOV(IND(IMM(1226)), IMM(103));
MOV(IND(IMM(1227)), IMM(45));
MOV(IND(IMM(1228)), IMM(114));
MOV(IND(IMM(1229)), IMM(101));
MOV(IND(IMM(1230)), IMM(102));
MOV(IND(IMM(1231)), IMM(799345));
MOV(IND(IMM(1232)), IMM(13));
MOV(IND(IMM(1233)), IMM(115));
MOV(IND(IMM(1234)), IMM(116));
MOV(IND(IMM(1235)), IMM(114));
MOV(IND(IMM(1236)), IMM(105));
MOV(IND(IMM(1237)), IMM(110));
MOV(IND(IMM(1238)), IMM(103));
MOV(IND(IMM(1239)), IMM(45));
MOV(IND(IMM(1240)), IMM(108));
MOV(IND(IMM(1241)), IMM(101));
MOV(IND(IMM(1242)), IMM(110));
MOV(IND(IMM(1243)), IMM(103));
MOV(IND(IMM(1244)), IMM(116));
MOV(IND(IMM(1245)), IMM(104));
MOV(IND(IMM(1246)), IMM(799345));
MOV(IND(IMM(1247)), IMM(13));
MOV(IND(IMM(1248)), IMM(105));
MOV(IND(IMM(1249)), IMM(110));
MOV(IND(IMM(1250)), IMM(116));
MOV(IND(IMM(1251)), IMM(101));
MOV(IND(IMM(1252)), IMM(103));
MOV(IND(IMM(1253)), IMM(101));
MOV(IND(IMM(1254)), IMM(114));
MOV(IND(IMM(1255)), IMM(45));
MOV(IND(IMM(1256)), IMM(62));
MOV(IND(IMM(1257)), IMM(99));
MOV(IND(IMM(1258)), IMM(104));
MOV(IND(IMM(1259)), IMM(97));
MOV(IND(IMM(1260)), IMM(114));
MOV(IND(IMM(1261)), IMM(799345));
MOV(IND(IMM(1262)), IMM(13));
MOV(IND(IMM(1263)), IMM(99));
MOV(IND(IMM(1264)), IMM(104));
MOV(IND(IMM(1265)), IMM(97));
MOV(IND(IMM(1266)), IMM(114));
MOV(IND(IMM(1267)), IMM(45));
MOV(IND(IMM(1268)), IMM(62));
MOV(IND(IMM(1269)), IMM(105));
MOV(IND(IMM(1270)), IMM(110));
MOV(IND(IMM(1271)), IMM(116));
MOV(IND(IMM(1272)), IMM(101));
MOV(IND(IMM(1273)), IMM(103));
MOV(IND(IMM(1274)), IMM(101));
MOV(IND(IMM(1275)), IMM(114));
MOV(IND(IMM(1276)), IMM(799345));
MOV(IND(IMM(1277)), IMM(1));
MOV(IND(IMM(1278)), IMM(61));
MOV(IND(IMM(1279)), IMM(799345));
MOV(IND(IMM(1280)), IMM(1));
MOV(IND(IMM(1281)), IMM(62));
MOV(IND(IMM(1282)), IMM(799345));
MOV(IND(IMM(1283)), IMM(1));
MOV(IND(IMM(1284)), IMM(60));
MOV(IND(IMM(1285)), IMM(799345));
MOV(IND(IMM(1286)), IMM(1));
MOV(IND(IMM(1287)), IMM(47));
MOV(IND(IMM(1288)), IMM(799345));
MOV(IND(IMM(1289)), IMM(1));
MOV(IND(IMM(1290)), IMM(42));
MOV(IND(IMM(1291)), IMM(799345));
MOV(IND(IMM(1292)), IMM(1));
MOV(IND(IMM(1293)), IMM(45));
MOV(IND(IMM(1294)), IMM(799345));
MOV(IND(IMM(1295)), IMM(1));
MOV(IND(IMM(1296)), IMM(43));
MOV(IND(IMM(1297)), IMM(799345));
MOV(IND(IMM(1298)), IMM(10));
MOV(IND(IMM(1299)), IMM(112));
MOV(IND(IMM(1300)), IMM(114));
MOV(IND(IMM(1301)), IMM(111));
MOV(IND(IMM(1302)), IMM(99));
MOV(IND(IMM(1303)), IMM(101));
MOV(IND(IMM(1304)), IMM(100));
MOV(IND(IMM(1305)), IMM(117));
MOV(IND(IMM(1306)), IMM(114));
MOV(IND(IMM(1307)), IMM(101));
MOV(IND(IMM(1308)), IMM(63));
MOV(IND(IMM(1309)), IMM(799345));
MOV(IND(IMM(1310)), IMM(7));
MOV(IND(IMM(1311)), IMM(118));
MOV(IND(IMM(1312)), IMM(101));
MOV(IND(IMM(1313)), IMM(99));
MOV(IND(IMM(1314)), IMM(116));
MOV(IND(IMM(1315)), IMM(111));
MOV(IND(IMM(1316)), IMM(114));
MOV(IND(IMM(1317)), IMM(63));
MOV(IND(IMM(1318)), IMM(799345));
MOV(IND(IMM(1319)), IMM(5));
MOV(IND(IMM(1320)), IMM(122));
MOV(IND(IMM(1321)), IMM(101));
MOV(IND(IMM(1322)), IMM(114));
MOV(IND(IMM(1323)), IMM(111));
MOV(IND(IMM(1324)), IMM(63));
MOV(IND(IMM(1325)), IMM(799345));
MOV(IND(IMM(1326)), IMM(7));
MOV(IND(IMM(1327)), IMM(115));
MOV(IND(IMM(1328)), IMM(121));
MOV(IND(IMM(1329)), IMM(109));
MOV(IND(IMM(1330)), IMM(98));
MOV(IND(IMM(1331)), IMM(111));
MOV(IND(IMM(1332)), IMM(108));
MOV(IND(IMM(1333)), IMM(63));
MOV(IND(IMM(1334)), IMM(799345));
MOV(IND(IMM(1335)), IMM(7));
MOV(IND(IMM(1336)), IMM(115));
MOV(IND(IMM(1337)), IMM(116));
MOV(IND(IMM(1338)), IMM(114));
MOV(IND(IMM(1339)), IMM(105));
MOV(IND(IMM(1340)), IMM(110));
MOV(IND(IMM(1341)), IMM(103));
MOV(IND(IMM(1342)), IMM(63));
MOV(IND(IMM(1343)), IMM(799345));
MOV(IND(IMM(1344)), IMM(5));
MOV(IND(IMM(1345)), IMM(112));
MOV(IND(IMM(1346)), IMM(97));
MOV(IND(IMM(1347)), IMM(105));
MOV(IND(IMM(1348)), IMM(114));
MOV(IND(IMM(1349)), IMM(63));
MOV(IND(IMM(1350)), IMM(799345));
MOV(IND(IMM(1351)), IMM(5));
MOV(IND(IMM(1352)), IMM(110));
MOV(IND(IMM(1353)), IMM(117));
MOV(IND(IMM(1354)), IMM(108));
MOV(IND(IMM(1355)), IMM(108));
MOV(IND(IMM(1356)), IMM(63));
MOV(IND(IMM(1357)), IMM(799345));
MOV(IND(IMM(1358)), IMM(5));
MOV(IND(IMM(1359)), IMM(99));
MOV(IND(IMM(1360)), IMM(104));
MOV(IND(IMM(1361)), IMM(97));
MOV(IND(IMM(1362)), IMM(114));
MOV(IND(IMM(1363)), IMM(63));
MOV(IND(IMM(1364)), IMM(799345));
MOV(IND(IMM(1365)), IMM(8));
MOV(IND(IMM(1366)), IMM(98));
MOV(IND(IMM(1367)), IMM(111));
MOV(IND(IMM(1368)), IMM(111));
MOV(IND(IMM(1369)), IMM(108));
MOV(IND(IMM(1370)), IMM(101));
MOV(IND(IMM(1371)), IMM(97));
MOV(IND(IMM(1372)), IMM(110));
MOV(IND(IMM(1373)), IMM(63));
MOV(IND(IMM(1374)), IMM(799345));
MOV(IND(IMM(1375)), IMM(8));
MOV(IND(IMM(1376)), IMM(105));
MOV(IND(IMM(1377)), IMM(110));
MOV(IND(IMM(1378)), IMM(116));
MOV(IND(IMM(1379)), IMM(101));
MOV(IND(IMM(1380)), IMM(103));
MOV(IND(IMM(1381)), IMM(101));
MOV(IND(IMM(1382)), IMM(114));
MOV(IND(IMM(1383)), IMM(63));
MOV(IND(IMM(1384)), IMM(799345));
MOV(IND(IMM(1385)), IMM(7));
MOV(IND(IMM(1386)), IMM(110));
MOV(IND(IMM(1387)), IMM(117));
MOV(IND(IMM(1388)), IMM(109));
MOV(IND(IMM(1389)), IMM(98));
MOV(IND(IMM(1390)), IMM(101));
MOV(IND(IMM(1391)), IMM(114));
MOV(IND(IMM(1392)), IMM(63));
MOV(IND(IMM(1)), IMM(937610));
MOV(IND(IMM(2)), IMM(722689));
MOV(IND(IMM(3)), IMM(741553));
MOV(IND(IMM(4)), IMM(0));
MOV(IND(IMM(5)), IMM(741553));
MOV(IND(IMM(6)), IMM(1));
MOV(IND(IMM(2173)), IMM(945311));
MOV(IND(IMM(2174)), IMM(-1));
MOV(IND(IMM(2175)), IMM(945311));
MOV(IND(IMM(2176)), IMM(0));
MOV(IND(IMM(2177)), IMM(945311));
MOV(IND(IMM(2178)), IMM(2));
MOV(IND(IMM(2179)), IMM(181048));
MOV(IND(IMM(2180)), IMM(122));
MOV(IND(IMM(2181)), IMM(181048));
MOV(IND(IMM(2182)), IMM(97));
MOV(IND(IMM(2183)), IMM(181048));
MOV(IND(IMM(2184)), IMM(90));
MOV(IND(IMM(2185)), IMM(181048));
MOV(IND(IMM(2186)), IMM(65));
MOV(IND(IMM(2187)), IMM(945311));
MOV(IND(IMM(2188)), IMM(1));
MOV(INDD(1413, 0), IMM(368031));
MOV(INDD(1413, 1), IMM(1416));
MOV(INDD(1413, 2), IMM(1418));
MOV(INDD(1413, 3), IMM(10));
MOV(R0, 0);MOV(INDD(1413, 4), R0);
MOV(INDD(1418, 0), IMM(368031));
MOV(INDD(1418, 1), IMM(1421));
MOV(INDD(1418, 2), IMM(1423));
MOV(INDD(1418, 3), IMM(17));
MOV(R0, 0);MOV(INDD(1418, 4), R0);
MOV(INDD(1423, 0), IMM(368031));
MOV(INDD(1423, 1), IMM(1426));
MOV(INDD(1423, 2), IMM(1428));
MOV(INDD(1423, 3), IMM(22));
MOV(R0, 0);MOV(INDD(1423, 4), R0);
MOV(INDD(1428, 0), IMM(368031));
MOV(INDD(1428, 1), IMM(1431));
MOV(INDD(1428, 2), IMM(1433));
MOV(INDD(1428, 3), IMM(27));
MOV(R0, 0);MOV(INDD(1428, 4), R0);
MOV(INDD(1433, 0), IMM(368031));
MOV(INDD(1433, 1), IMM(1436));
MOV(INDD(1433, 2), IMM(1438));
MOV(INDD(1433, 3), IMM(38));
MOV(R0, 0);MOV(INDD(1433, 4), R0);
MOV(INDD(1438, 0), IMM(368031));
MOV(INDD(1438, 1), IMM(1441));
MOV(INDD(1438, 2), IMM(1443));
MOV(INDD(1438, 3), IMM(54));
MOV(R0, 0);MOV(INDD(1438, 4), R0);
MOV(INDD(1443, 0), IMM(368031));
MOV(INDD(1443, 1), IMM(1446));
MOV(INDD(1443, 2), IMM(1448));
MOV(INDD(1443, 3), IMM(63));
MOV(R0, 0);MOV(INDD(1443, 4), R0);
MOV(INDD(1448, 0), IMM(368031));
MOV(INDD(1448, 1), IMM(1451));
MOV(INDD(1448, 2), IMM(1453));
MOV(INDD(1448, 3), IMM(78));
MOV(R0, 0);MOV(INDD(1448, 4), R0);
MOV(INDD(1453, 0), IMM(368031));
MOV(INDD(1453, 1), IMM(1456));
MOV(INDD(1453, 2), IMM(1458));
MOV(INDD(1453, 3), IMM(86));
MOV(R0, 0);MOV(INDD(1453, 4), R0);
MOV(INDD(1458, 0), IMM(368031));
MOV(INDD(1458, 1), IMM(1461));
MOV(INDD(1458, 2), IMM(1463));
MOV(INDD(1458, 3), IMM(101));
MOV(R0, 0);MOV(INDD(1458, 4), R0);
MOV(INDD(1463, 0), IMM(368031));
MOV(INDD(1463, 1), IMM(1466));
MOV(INDD(1463, 2), IMM(1468));
MOV(INDD(1463, 3), IMM(108));
MOV(R0, 0);MOV(INDD(1463, 4), R0);
MOV(INDD(1468, 0), IMM(368031));
MOV(INDD(1468, 1), IMM(1471));
MOV(INDD(1468, 2), IMM(1473));
MOV(INDD(1468, 3), IMM(114));
MOV(R0, 0);MOV(INDD(1468, 4), R0);
MOV(INDD(1473, 0), IMM(368031));
MOV(INDD(1473, 1), IMM(1476));
MOV(INDD(1473, 2), IMM(1478));
MOV(INDD(1473, 3), IMM(120));
MOV(R0, 0);MOV(INDD(1473, 4), R0);
MOV(INDD(1478, 0), IMM(368031));
MOV(INDD(1478, 1), IMM(1481));
MOV(INDD(1478, 2), IMM(1483));
MOV(INDD(1478, 3), IMM(127));
MOV(R0, 0);MOV(INDD(1478, 4), R0);
MOV(INDD(1483, 0), IMM(368031));
MOV(INDD(1483, 1), IMM(1486));
MOV(INDD(1483, 2), IMM(1488));
MOV(INDD(1483, 3), IMM(139));
MOV(R0, 0);MOV(INDD(1483, 4), R0);
MOV(INDD(1488, 0), IMM(368031));
MOV(INDD(1488, 1), IMM(1491));
MOV(INDD(1488, 2), IMM(1493));
MOV(INDD(1488, 3), IMM(150));
MOV(R0, 0);MOV(INDD(1488, 4), R0);
MOV(INDD(1493, 0), IMM(368031));
MOV(INDD(1493, 1), IMM(1496));
MOV(INDD(1493, 2), IMM(1498));
MOV(INDD(1493, 3), IMM(158));
MOV(R0, 0);MOV(INDD(1493, 4), R0);
MOV(INDD(1498, 0), IMM(368031));
MOV(INDD(1498, 1), IMM(1501));
MOV(INDD(1498, 2), IMM(1503));
MOV(INDD(1498, 3), IMM(166));
MOV(R0, 0);MOV(INDD(1498, 4), R0);
MOV(INDD(1503, 0), IMM(368031));
MOV(INDD(1503, 1), IMM(1506));
MOV(INDD(1503, 2), IMM(1508));
MOV(INDD(1503, 3), IMM(180));
MOV(R0, 0);MOV(INDD(1503, 4), R0);
MOV(INDD(1508, 0), IMM(368031));
MOV(INDD(1508, 1), IMM(1511));
MOV(INDD(1508, 2), IMM(1513));
MOV(INDD(1508, 3), IMM(191));
MOV(R0, 0);MOV(INDD(1508, 4), R0);
MOV(INDD(1513, 0), IMM(368031));
MOV(INDD(1513, 1), IMM(1516));
MOV(INDD(1513, 2), IMM(1518));
MOV(INDD(1513, 3), IMM(202));
MOV(R0, 0);MOV(INDD(1513, 4), R0);
MOV(INDD(1518, 0), IMM(368031));
MOV(INDD(1518, 1), IMM(1521));
MOV(INDD(1518, 2), IMM(1523));
MOV(INDD(1518, 3), IMM(212));
MOV(R0, 0);MOV(INDD(1518, 4), R0);
MOV(INDD(1523, 0), IMM(368031));
MOV(INDD(1523, 1), IMM(1526));
MOV(INDD(1523, 2), IMM(1528));
MOV(INDD(1523, 3), IMM(222));
MOV(R0, 0);MOV(INDD(1523, 4), R0);
MOV(INDD(1528, 0), IMM(368031));
MOV(INDD(1528, 1), IMM(1531));
MOV(INDD(1528, 2), IMM(1533));
MOV(INDD(1528, 3), IMM(232));
MOV(R0, 0);MOV(INDD(1528, 4), R0);
MOV(INDD(1533, 0), IMM(368031));
MOV(INDD(1533, 1), IMM(1536));
MOV(INDD(1533, 2), IMM(1538));
MOV(INDD(1533, 3), IMM(250));
MOV(R0, 0);MOV(INDD(1533, 4), R0);
MOV(INDD(1538, 0), IMM(368031));
MOV(INDD(1538, 1), IMM(1541));
MOV(INDD(1538, 2), IMM(1543));
MOV(INDD(1538, 3), IMM(268));
MOV(R0, 0);MOV(INDD(1538, 4), R0);
MOV(INDD(1543, 0), IMM(368031));
MOV(INDD(1543, 1), IMM(1546));
MOV(INDD(1543, 2), IMM(1548));
MOV(INDD(1543, 3), IMM(285));
MOV(R0, 0);MOV(INDD(1543, 4), R0);
MOV(INDD(1548, 0), IMM(368031));
MOV(INDD(1548, 1), IMM(1551));
MOV(INDD(1548, 2), IMM(1553));
MOV(INDD(1548, 3), IMM(302));
MOV(R0, 0);MOV(INDD(1548, 4), R0);
MOV(INDD(1553, 0), IMM(368031));
MOV(INDD(1553, 1), IMM(1556));
MOV(INDD(1553, 2), IMM(1558));
MOV(INDD(1553, 3), IMM(319));
MOV(R0, 0);MOV(INDD(1553, 4), R0);
MOV(INDD(1558, 0), IMM(368031));
MOV(INDD(1558, 1), IMM(1561));
MOV(INDD(1558, 2), IMM(1563));
MOV(INDD(1558, 3), IMM(333));
MOV(R0, 0);MOV(INDD(1558, 4), R0);
MOV(INDD(1563, 0), IMM(368031));
MOV(INDD(1563, 1), IMM(1566));
MOV(INDD(1563, 2), IMM(1568));
MOV(INDD(1563, 3), IMM(344));
MOV(R0, 0);MOV(INDD(1563, 4), R0);
MOV(INDD(1568, 0), IMM(368031));
MOV(INDD(1568, 1), IMM(1571));
MOV(INDD(1568, 2), IMM(1573));
MOV(INDD(1568, 3), IMM(355));
MOV(R0, 0);MOV(INDD(1568, 4), R0);
MOV(INDD(1573, 0), IMM(368031));
MOV(INDD(1573, 1), IMM(1576));
MOV(INDD(1573, 2), IMM(1578));
MOV(INDD(1573, 3), IMM(364));
MOV(R0, 0);MOV(INDD(1573, 4), R0);
MOV(INDD(1578, 0), IMM(368031));
MOV(INDD(1578, 1), IMM(1581));
MOV(INDD(1578, 2), IMM(1583));
MOV(INDD(1578, 3), IMM(371));
MOV(R0, 0);MOV(INDD(1578, 4), R0);
MOV(INDD(1583, 0), IMM(368031));
MOV(INDD(1583, 1), IMM(1586));
MOV(INDD(1583, 2), IMM(1588));
MOV(INDD(1583, 3), IMM(381));
MOV(R0, 0);MOV(INDD(1583, 4), R0);
MOV(INDD(1588, 0), IMM(368031));
MOV(INDD(1588, 1), IMM(1591));
MOV(INDD(1588, 2), IMM(1593));
MOV(INDD(1588, 3), IMM(387));
PUSH(LABEL(REMAINDER));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1588, 4), R0);
MOV(INDD(1593, 0), IMM(368031));
MOV(INDD(1593, 1), IMM(1596));
MOV(INDD(1593, 2), IMM(1598));
MOV(INDD(1593, 3), IMM(398));
MOV(R0, 0);MOV(INDD(1593, 4), R0);
MOV(INDD(1598, 0), IMM(368031));
MOV(INDD(1598, 1), IMM(1601));
MOV(INDD(1598, 2), IMM(1603));
MOV(INDD(1598, 3), IMM(405));
MOV(R0, 0);MOV(INDD(1598, 4), R0);
MOV(INDD(1603, 0), IMM(368031));
MOV(INDD(1603, 1), IMM(1606));
MOV(INDD(1603, 2), IMM(1608));
MOV(INDD(1603, 3), IMM(422));
MOV(R0, 0);MOV(INDD(1603, 4), R0);
MOV(INDD(1608, 0), IMM(368031));
MOV(INDD(1608, 1), IMM(1611));
MOV(INDD(1608, 2), IMM(1613));
MOV(INDD(1608, 3), IMM(436));
MOV(R0, 0);MOV(INDD(1608, 4), R0);
MOV(INDD(1613, 0), IMM(368031));
MOV(INDD(1613, 1), IMM(1616));
MOV(INDD(1613, 2), IMM(1618));
MOV(INDD(1613, 3), IMM(450));
MOV(R0, 0);MOV(INDD(1613, 4), R0);
MOV(INDD(1618, 0), IMM(368031));
MOV(INDD(1618, 1), IMM(1621));
MOV(INDD(1618, 2), IMM(1623));
MOV(INDD(1618, 3), IMM(465));
MOV(R0, 0);MOV(INDD(1618, 4), R0);
MOV(INDD(1623, 0), IMM(368031));
MOV(INDD(1623, 1), IMM(1626));
MOV(INDD(1623, 2), IMM(1628));
MOV(INDD(1623, 3), IMM(477));
MOV(R0, 0);MOV(INDD(1623, 4), R0);
MOV(INDD(1628, 0), IMM(368031));
MOV(INDD(1628, 1), IMM(1631));
MOV(INDD(1628, 2), IMM(1633));
MOV(INDD(1628, 3), IMM(488));
MOV(R0, 0);MOV(INDD(1628, 4), R0);
MOV(INDD(1633, 0), IMM(368031));
MOV(INDD(1633, 1), IMM(1636));
MOV(INDD(1633, 2), IMM(1638));
MOV(INDD(1633, 3), IMM(499));
MOV(R0, 0);MOV(INDD(1633, 4), R0);
MOV(INDD(1638, 0), IMM(368031));
MOV(INDD(1638, 1), IMM(1641));
MOV(INDD(1638, 2), IMM(1643));
MOV(INDD(1638, 3), IMM(510));
MOV(R0, 0);MOV(INDD(1638, 4), R0);
MOV(INDD(1643, 0), IMM(368031));
MOV(INDD(1643, 1), IMM(1646));
MOV(INDD(1643, 2), IMM(1648));
MOV(INDD(1643, 3), IMM(522));
MOV(R0, 0);MOV(INDD(1643, 4), R0);
MOV(INDD(1648, 0), IMM(368031));
MOV(INDD(1648, 1), IMM(1651));
MOV(INDD(1648, 2), IMM(1653));
MOV(INDD(1648, 3), IMM(537));
MOV(R0, 0);MOV(INDD(1648, 4), R0);
MOV(INDD(1653, 0), IMM(368031));
MOV(INDD(1653, 1), IMM(1656));
MOV(INDD(1653, 2), IMM(1658));
MOV(INDD(1653, 3), IMM(550));
MOV(R0, 0);MOV(INDD(1653, 4), R0);
MOV(INDD(1658, 0), IMM(368031));
MOV(INDD(1658, 1), IMM(1661));
MOV(INDD(1658, 2), IMM(1663));
MOV(INDD(1658, 3), IMM(567));
MOV(R0, 0);MOV(INDD(1658, 4), R0);
MOV(INDD(1663, 0), IMM(368031));
MOV(INDD(1663, 1), IMM(1666));
MOV(INDD(1663, 2), IMM(1668));
MOV(INDD(1663, 3), IMM(584));
MOV(R0, 0);MOV(INDD(1663, 4), R0);
MOV(INDD(1668, 0), IMM(368031));
MOV(INDD(1668, 1), IMM(1671));
MOV(INDD(1668, 2), IMM(1673));
MOV(INDD(1668, 3), IMM(592));
MOV(R0, 0);MOV(INDD(1668, 4), R0);
MOV(INDD(1673, 0), IMM(368031));
MOV(INDD(1673, 1), IMM(1676));
MOV(INDD(1673, 2), IMM(1678));
MOV(INDD(1673, 3), IMM(601));
MOV(R0, 0);MOV(INDD(1673, 4), R0);
MOV(INDD(1678, 0), IMM(368031));
MOV(INDD(1678, 1), IMM(1681));
MOV(INDD(1678, 2), IMM(1683));
MOV(INDD(1678, 3), IMM(609));
MOV(R0, 0);MOV(INDD(1678, 4), R0);
MOV(INDD(1683, 0), IMM(368031));
MOV(INDD(1683, 1), IMM(1686));
MOV(INDD(1683, 2), IMM(1688));
MOV(INDD(1683, 3), IMM(618));
MOV(R0, 0);MOV(INDD(1683, 4), R0);
MOV(INDD(1688, 0), IMM(368031));
MOV(INDD(1688, 1), IMM(1691));
MOV(INDD(1688, 2), IMM(1693));
MOV(INDD(1688, 3), IMM(626));
MOV(R0, 0);MOV(INDD(1688, 4), R0);
MOV(INDD(1693, 0), IMM(368031));
MOV(INDD(1693, 1), IMM(1696));
MOV(INDD(1693, 2), IMM(1698));
MOV(INDD(1693, 3), IMM(636));
MOV(R0, 0);MOV(INDD(1693, 4), R0);
MOV(INDD(1698, 0), IMM(368031));
MOV(INDD(1698, 1), IMM(1701));
MOV(INDD(1698, 2), IMM(1703));
MOV(INDD(1698, 3), IMM(664));
MOV(R0, 0);MOV(INDD(1698, 4), R0);
MOV(INDD(1703, 0), IMM(368031));
MOV(INDD(1703, 1), IMM(1706));
MOV(INDD(1703, 2), IMM(1708));
MOV(INDD(1703, 3), IMM(693));
MOV(R0, 0);MOV(INDD(1703, 4), R0);
MOV(INDD(1708, 0), IMM(368031));
MOV(INDD(1708, 1), IMM(1711));
MOV(INDD(1708, 2), IMM(1713));
MOV(INDD(1708, 3), IMM(701));
MOV(R0, 0);MOV(INDD(1708, 4), R0);
MOV(INDD(1713, 0), IMM(368031));
MOV(INDD(1713, 1), IMM(1716));
MOV(INDD(1713, 2), IMM(1718));
MOV(INDD(1713, 3), IMM(709));
MOV(R0, 0);MOV(INDD(1713, 4), R0);
MOV(INDD(1718, 0), IMM(368031));
MOV(INDD(1718, 1), IMM(1721));
MOV(INDD(1718, 2), IMM(1723));
MOV(INDD(1718, 3), IMM(717));
MOV(R0, 0);MOV(INDD(1718, 4), R0);
MOV(INDD(1723, 0), IMM(368031));
MOV(INDD(1723, 1), IMM(1726));
MOV(INDD(1723, 2), IMM(1728));
MOV(INDD(1723, 3), IMM(725));
MOV(R0, 0);MOV(INDD(1723, 4), R0);
MOV(INDD(1728, 0), IMM(368031));
MOV(INDD(1728, 1), IMM(1731));
MOV(INDD(1728, 2), IMM(1733));
MOV(INDD(1728, 3), IMM(733));
MOV(R0, 0);MOV(INDD(1728, 4), R0);
MOV(INDD(1733, 0), IMM(368031));
MOV(INDD(1733, 1), IMM(1736));
MOV(INDD(1733, 2), IMM(1738));
MOV(INDD(1733, 3), IMM(741));
MOV(R0, 0);MOV(INDD(1733, 4), R0);
MOV(INDD(1738, 0), IMM(368031));
MOV(INDD(1738, 1), IMM(1741));
MOV(INDD(1738, 2), IMM(1743));
MOV(INDD(1738, 3), IMM(749));
MOV(R0, 0);MOV(INDD(1738, 4), R0);
MOV(INDD(1743, 0), IMM(368031));
MOV(INDD(1743, 1), IMM(1746));
MOV(INDD(1743, 2), IMM(1748));
MOV(INDD(1743, 3), IMM(757));
MOV(R0, 0);MOV(INDD(1743, 4), R0);
MOV(INDD(1748, 0), IMM(368031));
MOV(INDD(1748, 1), IMM(1751));
MOV(INDD(1748, 2), IMM(1753));
MOV(INDD(1748, 3), IMM(765));
MOV(R0, 0);MOV(INDD(1748, 4), R0);
MOV(INDD(1753, 0), IMM(368031));
MOV(INDD(1753, 1), IMM(1756));
MOV(INDD(1753, 2), IMM(1758));
MOV(INDD(1753, 3), IMM(773));
MOV(R0, 0);MOV(INDD(1753, 4), R0);
MOV(INDD(1758, 0), IMM(368031));
MOV(INDD(1758, 1), IMM(1761));
MOV(INDD(1758, 2), IMM(1763));
MOV(INDD(1758, 3), IMM(781));
MOV(R0, 0);MOV(INDD(1758, 4), R0);
MOV(INDD(1763, 0), IMM(368031));
MOV(INDD(1763, 1), IMM(1766));
MOV(INDD(1763, 2), IMM(1768));
MOV(INDD(1763, 3), IMM(789));
MOV(R0, 0);MOV(INDD(1763, 4), R0);
MOV(INDD(1768, 0), IMM(368031));
MOV(INDD(1768, 1), IMM(1771));
MOV(INDD(1768, 2), IMM(1773));
MOV(INDD(1768, 3), IMM(797));
MOV(R0, 0);MOV(INDD(1768, 4), R0);
MOV(INDD(1773, 0), IMM(368031));
MOV(INDD(1773, 1), IMM(1776));
MOV(INDD(1773, 2), IMM(1778));
MOV(INDD(1773, 3), IMM(805));
MOV(R0, 0);MOV(INDD(1773, 4), R0);
MOV(INDD(1778, 0), IMM(368031));
MOV(INDD(1778, 1), IMM(1781));
MOV(INDD(1778, 2), IMM(1783));
MOV(INDD(1778, 3), IMM(813));
MOV(R0, 0);MOV(INDD(1778, 4), R0);
MOV(INDD(1783, 0), IMM(368031));
MOV(INDD(1783, 1), IMM(1786));
MOV(INDD(1783, 2), IMM(1788));
MOV(INDD(1783, 3), IMM(821));
MOV(R0, 0);MOV(INDD(1783, 4), R0);
MOV(INDD(1788, 0), IMM(368031));
MOV(INDD(1788, 1), IMM(1791));
MOV(INDD(1788, 2), IMM(1793));
MOV(INDD(1788, 3), IMM(828));
MOV(R0, 0);MOV(INDD(1788, 4), R0);
MOV(INDD(1793, 0), IMM(368031));
MOV(INDD(1793, 1), IMM(1796));
MOV(INDD(1793, 2), IMM(1798));
MOV(INDD(1793, 3), IMM(835));
MOV(R0, 0);MOV(INDD(1793, 4), R0);
MOV(INDD(1798, 0), IMM(368031));
MOV(INDD(1798, 1), IMM(1801));
MOV(INDD(1798, 2), IMM(1803));
MOV(INDD(1798, 3), IMM(842));
MOV(R0, 0);MOV(INDD(1798, 4), R0);
MOV(INDD(1803, 0), IMM(368031));
MOV(INDD(1803, 1), IMM(1806));
MOV(INDD(1803, 2), IMM(1808));
MOV(INDD(1803, 3), IMM(849));
MOV(R0, 0);MOV(INDD(1803, 4), R0);
MOV(INDD(1808, 0), IMM(368031));
MOV(INDD(1808, 1), IMM(1811));
MOV(INDD(1808, 2), IMM(1813));
MOV(INDD(1808, 3), IMM(856));
MOV(R0, 0);MOV(INDD(1808, 4), R0);
MOV(INDD(1813, 0), IMM(368031));
MOV(INDD(1813, 1), IMM(1816));
MOV(INDD(1813, 2), IMM(1818));
MOV(INDD(1813, 3), IMM(863));
MOV(R0, 0);MOV(INDD(1813, 4), R0);
MOV(INDD(1818, 0), IMM(368031));
MOV(INDD(1818, 1), IMM(1821));
MOV(INDD(1818, 2), IMM(1823));
MOV(INDD(1818, 3), IMM(870));
MOV(R0, 0);MOV(INDD(1818, 4), R0);
MOV(INDD(1823, 0), IMM(368031));
MOV(INDD(1823, 1), IMM(1826));
MOV(INDD(1823, 2), IMM(1828));
MOV(INDD(1823, 3), IMM(877));
MOV(R0, 0);MOV(INDD(1823, 4), R0);
MOV(INDD(1828, 0), IMM(368031));
MOV(INDD(1828, 1), IMM(1831));
MOV(INDD(1828, 2), IMM(1833));
MOV(INDD(1828, 3), IMM(883));
MOV(R0, 0);MOV(INDD(1828, 4), R0);
MOV(INDD(1833, 0), IMM(368031));
MOV(INDD(1833, 1), IMM(1836));
MOV(INDD(1833, 2), IMM(1838));
MOV(INDD(1833, 3), IMM(889));
MOV(R0, 0);MOV(INDD(1833, 4), R0);
MOV(INDD(1838, 0), IMM(368031));
MOV(INDD(1838, 1), IMM(1841));
MOV(INDD(1838, 2), IMM(1843));
MOV(INDD(1838, 3), IMM(895));
MOV(R0, 0);MOV(INDD(1838, 4), R0);
MOV(INDD(1843, 0), IMM(368031));
MOV(INDD(1843, 1), IMM(1846));
MOV(INDD(1843, 2), IMM(1848));
MOV(INDD(1843, 3), IMM(901));
MOV(R0, 0);MOV(INDD(1843, 4), R0);
MOV(INDD(1848, 0), IMM(368031));
MOV(INDD(1848, 1), IMM(1851));
MOV(INDD(1848, 2), IMM(1853));
MOV(INDD(1848, 3), IMM(910));
MOV(R0, 0);MOV(INDD(1848, 4), R0);
MOV(INDD(1853, 0), IMM(368031));
MOV(INDD(1853, 1), IMM(1856));
MOV(INDD(1853, 2), IMM(1858));
MOV(INDD(1853, 3), IMM(917));
MOV(R0, 0);MOV(INDD(1853, 4), R0);
MOV(INDD(1858, 0), IMM(368031));
MOV(INDD(1858, 1), IMM(1861));
MOV(INDD(1858, 2), IMM(1863));
MOV(INDD(1858, 3), IMM(921));
MOV(R0, 0);MOV(INDD(1858, 4), R0);
MOV(INDD(1863, 0), IMM(368031));
MOV(INDD(1863, 1), IMM(1866));
MOV(INDD(1863, 2), IMM(1868));
MOV(INDD(1863, 3), IMM(925));
MOV(R0, 0);MOV(INDD(1863, 4), R0);
MOV(INDD(1868, 0), IMM(368031));
MOV(INDD(1868, 1), IMM(1871));
MOV(INDD(1868, 2), IMM(1873));
MOV(INDD(1868, 3), IMM(929));
MOV(R0, 0);MOV(INDD(1868, 4), R0);
MOV(INDD(1873, 0), IMM(368031));
MOV(INDD(1873, 1), IMM(1876));
MOV(INDD(1873, 2), IMM(1878));
MOV(INDD(1873, 3), IMM(936));
MOV(R0, 0);MOV(INDD(1873, 4), R0);
MOV(INDD(1878, 0), IMM(368031));
MOV(INDD(1878, 1), IMM(1881));
MOV(INDD(1878, 2), IMM(1883));
MOV(INDD(1878, 3), IMM(944));
MOV(R0, 0);MOV(INDD(1878, 4), R0);
MOV(INDD(1883, 0), IMM(368031));
MOV(INDD(1883, 1), IMM(1886));
MOV(INDD(1883, 2), IMM(1888));
MOV(INDD(1883, 3), IMM(951));
MOV(R0, 0);MOV(INDD(1883, 4), R0);
MOV(INDD(1888, 0), IMM(368031));
MOV(INDD(1888, 1), IMM(1891));
MOV(INDD(1888, 2), IMM(1893));
MOV(INDD(1888, 3), IMM(957));
MOV(R0, 0);MOV(INDD(1888, 4), R0);
MOV(INDD(1893, 0), IMM(368031));
MOV(INDD(1893, 1), IMM(1896));
MOV(INDD(1893, 2), IMM(1898));
MOV(INDD(1893, 3), IMM(963));
MOV(R0, 0);MOV(INDD(1893, 4), R0);
MOV(INDD(1898, 0), IMM(368031));
MOV(INDD(1898, 1), IMM(1901));
MOV(INDD(1898, 2), IMM(1903));
MOV(INDD(1898, 3), IMM(971));
MOV(R0, 0);MOV(INDD(1898, 4), R0);
MOV(INDD(1903, 0), IMM(368031));
MOV(INDD(1903, 1), IMM(1906));
MOV(INDD(1903, 2), IMM(1908));
MOV(INDD(1903, 3), IMM(976));
MOV(R0, 0);MOV(INDD(1903, 4), R0);
MOV(INDD(1908, 0), IMM(368031));
MOV(INDD(1908, 1), IMM(1911));
MOV(INDD(1908, 2), IMM(1913));
MOV(INDD(1908, 3), IMM(984));
MOV(R0, 0);MOV(INDD(1908, 4), R0);
MOV(INDD(1913, 0), IMM(368031));
MOV(INDD(1913, 1), IMM(1916));
MOV(INDD(1913, 2), IMM(1918));
MOV(INDD(1913, 3), IMM(991));
MOV(R0, 0);MOV(INDD(1913, 4), R0);
MOV(INDD(1918, 0), IMM(368031));
MOV(INDD(1918, 1), IMM(1921));
MOV(INDD(1918, 2), IMM(1923));
MOV(INDD(1918, 3), IMM(998));
MOV(R0, 0);MOV(INDD(1918, 4), R0);
MOV(INDD(1923, 0), IMM(368031));
MOV(INDD(1923, 1), IMM(1926));
MOV(INDD(1923, 2), IMM(1928));
MOV(INDD(1923, 3), IMM(1005));
MOV(R0, 0);MOV(INDD(1923, 4), R0);
MOV(INDD(1928, 0), IMM(368031));
MOV(INDD(1928, 1), IMM(1931));
MOV(INDD(1928, 2), IMM(1933));
MOV(INDD(1928, 3), IMM(1011));
MOV(R0, 0);MOV(INDD(1928, 4), R0);
MOV(INDD(1933, 0), IMM(368031));
MOV(INDD(1933, 1), IMM(1936));
MOV(INDD(1933, 2), IMM(1938));
MOV(INDD(1933, 3), IMM(1017));
MOV(R0, 0);MOV(INDD(1933, 4), R0);
MOV(INDD(1938, 0), IMM(368031));
MOV(INDD(1938, 1), IMM(1941));
MOV(INDD(1938, 2), IMM(1943));
MOV(INDD(1938, 3), IMM(1023));
MOV(R0, 0);MOV(INDD(1938, 4), R0);
MOV(INDD(1943, 0), IMM(368031));
MOV(INDD(1943, 1), IMM(1946));
MOV(INDD(1943, 2), IMM(1948));
MOV(INDD(1943, 3), IMM(1029));
MOV(R0, 0);MOV(INDD(1943, 4), R0);
MOV(INDD(1948, 0), IMM(368031));
MOV(INDD(1948, 1), IMM(1951));
MOV(INDD(1948, 2), IMM(1953));
MOV(INDD(1948, 3), IMM(1033));
MOV(R0, 0);MOV(INDD(1948, 4), R0);
MOV(INDD(1953, 0), IMM(368031));
MOV(INDD(1953, 1), IMM(1956));
MOV(INDD(1953, 2), IMM(1958));
MOV(INDD(1953, 3), IMM(1038));
PUSH(LABEL(SET_CAR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1953, 4), R0);
MOV(INDD(1958, 0), IMM(368031));
MOV(INDD(1958, 1), IMM(1961));
MOV(INDD(1958, 2), IMM(1963));
MOV(INDD(1958, 3), IMM(1048));
PUSH(LABEL(SET_CDR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1958, 4), R0);
MOV(INDD(1963, 0), IMM(368031));
MOV(INDD(1963, 1), IMM(1966));
MOV(INDD(1963, 2), IMM(1968));
MOV(INDD(1963, 3), IMM(1058));
PUSH(LABEL(EQ));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1963, 4), R0);
MOV(INDD(1968, 0), IMM(368031));
MOV(INDD(1968, 1), IMM(1971));
MOV(INDD(1968, 2), IMM(1973));
MOV(INDD(1968, 3), IMM(1063));
PUSH(LABEL(STRING_TO_SYMBOL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1968, 4), R0);
MOV(INDD(1973, 0), IMM(368031));
MOV(INDD(1973, 1), IMM(1976));
MOV(INDD(1973, 2), IMM(1978));
MOV(INDD(1973, 3), IMM(1079));
PUSH(LABEL(SYMBOL_TO_STRING));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1973, 4), R0);
MOV(INDD(1978, 0), IMM(368031));
MOV(INDD(1978, 1), IMM(1981));
MOV(INDD(1978, 2), IMM(1983));
MOV(INDD(1978, 3), IMM(1095));
MOV(R0, 0);MOV(INDD(1978, 4), R0);
MOV(INDD(1983, 0), IMM(368031));
MOV(INDD(1983, 1), IMM(1986));
MOV(INDD(1983, 2), IMM(1988));
MOV(INDD(1983, 3), IMM(1103));
PUSH(LABEL(APPLY_TC));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1983, 4), R0);
MOV(INDD(1988, 0), IMM(368031));
MOV(INDD(1988, 1), IMM(1991));
MOV(INDD(1988, 2), IMM(1993));
MOV(INDD(1988, 3), IMM(1110));
MOV(R0, 0);MOV(INDD(1988, 4), R0);
MOV(INDD(1993, 0), IMM(368031));
MOV(INDD(1993, 1), IMM(1996));
MOV(INDD(1993, 2), IMM(1998));
MOV(INDD(1993, 3), IMM(1118));
MOV(R0, 0);MOV(INDD(1993, 4), R0);
MOV(INDD(1998, 0), IMM(368031));
MOV(INDD(1998, 1), IMM(2001));
MOV(INDD(1998, 2), IMM(2003));
MOV(INDD(1998, 3), IMM(1124));
PUSH(LABEL(CDR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1998, 4), R0);
MOV(INDD(2003, 0), IMM(368031));
MOV(INDD(2003, 1), IMM(2006));
MOV(INDD(2003, 2), IMM(2008));
MOV(INDD(2003, 3), IMM(1129));
PUSH(LABEL(CAR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2003, 4), R0);
MOV(INDD(2008, 0), IMM(368031));
MOV(INDD(2008, 1), IMM(2011));
MOV(INDD(2008, 2), IMM(2013));
MOV(INDD(2008, 3), IMM(1134));
PUSH(LABEL(CONS));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2008, 4), R0);
MOV(INDD(2013, 0), IMM(368031));
MOV(INDD(2013, 1), IMM(2016));
MOV(INDD(2013, 2), IMM(2018));
MOV(INDD(2013, 3), IMM(1140));
PUSH(LABEL(MAKE_VECTOR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2013, 4), R0);
MOV(INDD(2018, 0), IMM(368031));
MOV(INDD(2018, 1), IMM(2021));
MOV(INDD(2018, 2), IMM(2023));
MOV(INDD(2018, 3), IMM(1153));
PUSH(LABEL(VECTOR_SET));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2018, 4), R0);
MOV(INDD(2023, 0), IMM(368031));
MOV(INDD(2023, 1), IMM(2026));
MOV(INDD(2023, 2), IMM(2028));
MOV(INDD(2023, 3), IMM(1166));
PUSH(LABEL(VECTOR_REF));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2023, 4), R0);
MOV(INDD(2028, 0), IMM(368031));
MOV(INDD(2028, 1), IMM(2031));
MOV(INDD(2028, 2), IMM(2033));
MOV(INDD(2028, 3), IMM(1178));
PUSH(LABEL(VECTOR_LENGTH));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2028, 4), R0);
MOV(INDD(2033, 0), IMM(368031));
MOV(INDD(2033, 1), IMM(2036));
MOV(INDD(2033, 2), IMM(2038));
MOV(INDD(2033, 3), IMM(1193));
PUSH(LABEL(MAKE_STRING));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2033, 4), R0);
MOV(INDD(2038, 0), IMM(368031));
MOV(INDD(2038, 1), IMM(2041));
MOV(INDD(2038, 2), IMM(2043));
MOV(INDD(2038, 3), IMM(1206));
PUSH(LABEL(STRING_SET));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2038, 4), R0);
MOV(INDD(2043, 0), IMM(368031));
MOV(INDD(2043, 1), IMM(2046));
MOV(INDD(2043, 2), IMM(2048));
MOV(INDD(2043, 3), IMM(1219));
PUSH(LABEL(STRING_REF));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2043, 4), R0);
MOV(INDD(2048, 0), IMM(368031));
MOV(INDD(2048, 1), IMM(2051));
MOV(INDD(2048, 2), IMM(2053));
MOV(INDD(2048, 3), IMM(1231));
PUSH(LABEL(STRING_LENGTH));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2048, 4), R0);
MOV(INDD(2053, 0), IMM(368031));
MOV(INDD(2053, 1), IMM(2056));
MOV(INDD(2053, 2), IMM(2058));
MOV(INDD(2053, 3), IMM(1246));
PUSH(LABEL(INTEGER_TO_CHAR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2053, 4), R0);
MOV(INDD(2058, 0), IMM(368031));
MOV(INDD(2058, 1), IMM(2061));
MOV(INDD(2058, 2), IMM(2063));
MOV(INDD(2058, 3), IMM(1261));
PUSH(LABEL(CHAR_TO_INTEGER));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2058, 4), R0);
MOV(INDD(2063, 0), IMM(368031));
MOV(INDD(2063, 1), IMM(2066));
MOV(INDD(2063, 2), IMM(2068));
MOV(INDD(2063, 3), IMM(1276));
PUSH(LABEL(VARIADIC_EQUAL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2063, 4), R0);
MOV(INDD(2068, 0), IMM(368031));
MOV(INDD(2068, 1), IMM(2071));
MOV(INDD(2068, 2), IMM(2073));
MOV(INDD(2068, 3), IMM(1279));
PUSH(LABEL(VARIADIC_GT));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2068, 4), R0);
MOV(INDD(2073, 0), IMM(368031));
MOV(INDD(2073, 1), IMM(2076));
MOV(INDD(2073, 2), IMM(2078));
MOV(INDD(2073, 3), IMM(1282));
PUSH(LABEL(VARIADIC_LT));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2073, 4), R0);
MOV(INDD(2078, 0), IMM(368031));
MOV(INDD(2078, 1), IMM(2081));
MOV(INDD(2078, 2), IMM(2083));
MOV(INDD(2078, 3), IMM(1285));
PUSH(LABEL(VARIADIC_DIV));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2078, 4), R0);
MOV(INDD(2083, 0), IMM(368031));
MOV(INDD(2083, 1), IMM(2086));
MOV(INDD(2083, 2), IMM(2088));
MOV(INDD(2083, 3), IMM(1288));
PUSH(LABEL(VARIADIC_MUL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2083, 4), R0);
MOV(INDD(2088, 0), IMM(368031));
MOV(INDD(2088, 1), IMM(2091));
MOV(INDD(2088, 2), IMM(2093));
MOV(INDD(2088, 3), IMM(1291));
PUSH(LABEL(VARIADIC_MINUS));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2088, 4), R0);
MOV(INDD(2093, 0), IMM(368031));
MOV(INDD(2093, 1), IMM(2096));
MOV(INDD(2093, 2), IMM(2098));
MOV(INDD(2093, 3), IMM(1294));
PUSH(LABEL(VARIADIC_PLUS));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2093, 4), R0);
MOV(INDD(2098, 0), IMM(368031));
MOV(INDD(2098, 1), IMM(2101));
MOV(INDD(2098, 2), IMM(2103));
MOV(INDD(2098, 3), IMM(1297));
PUSH(LABEL(IS_PROCEDURE));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2098, 4), R0);
MOV(INDD(2103, 0), IMM(368031));
MOV(INDD(2103, 1), IMM(2106));
MOV(INDD(2103, 2), IMM(2108));
MOV(INDD(2103, 3), IMM(1309));
PUSH(LABEL(IS_VECTOR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2103, 4), R0);
MOV(INDD(2108, 0), IMM(368031));
MOV(INDD(2108, 1), IMM(2111));
MOV(INDD(2108, 2), IMM(2113));
MOV(INDD(2108, 3), IMM(1318));
PUSH(LABEL(IS_ZERO_MY));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2108, 4), R0);
MOV(INDD(2113, 0), IMM(368031));
MOV(INDD(2113, 1), IMM(2116));
MOV(INDD(2113, 2), IMM(2118));
MOV(INDD(2113, 3), IMM(1325));
PUSH(LABEL(IS_SYMBOL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2113, 4), R0);
MOV(INDD(2118, 0), IMM(368031));
MOV(INDD(2118, 1), IMM(2121));
MOV(INDD(2118, 2), IMM(2123));
MOV(INDD(2118, 3), IMM(1334));
PUSH(LABEL(IS_STRING));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2118, 4), R0);
MOV(INDD(2123, 0), IMM(368031));
MOV(INDD(2123, 1), IMM(2126));
MOV(INDD(2123, 2), IMM(2128));
MOV(INDD(2123, 3), IMM(1343));
PUSH(LABEL(IS_PAIR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2123, 4), R0);
MOV(INDD(2128, 0), IMM(368031));
MOV(INDD(2128, 1), IMM(2131));
MOV(INDD(2128, 2), IMM(2133));
MOV(INDD(2128, 3), IMM(1350));
PUSH(LABEL(IS_NULL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2128, 4), R0);
MOV(INDD(2133, 0), IMM(368031));
MOV(INDD(2133, 1), IMM(2136));
MOV(INDD(2133, 2), IMM(2138));
MOV(INDD(2133, 3), IMM(1357));
PUSH(LABEL(IS_CHAR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2133, 4), R0);
MOV(INDD(2138, 0), IMM(368031));
MOV(INDD(2138, 1), IMM(2141));
MOV(INDD(2138, 2), IMM(2143));
MOV(INDD(2138, 3), IMM(1364));
PUSH(LABEL(IS_BOOLEAN));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2138, 4), R0);
MOV(INDD(2143, 0), IMM(368031));
MOV(INDD(2143, 1), IMM(2146));
MOV(INDD(2143, 2), IMM(2148));
MOV(INDD(2143, 3), IMM(1374));
PUSH(LABEL(IS_INTEGER));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2143, 4), R0);
MOV(INDD(2148, 0), IMM(368031));
MOV(INDD(2148, 1), IMM(2151));
MOV(INDD(2148, 2), IMM(2153));
MOV(INDD(2148, 3), IMM(1384));
PUSH(LABEL(IS_NUMBER));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2148, 4), R0);
MOV(INDD(2148, 2), 2);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop154:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit154);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop154);
L_env_loop_exit154: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop154:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit154);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop154);
L_params_loop_exit154: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body154));
MOV(R0,R10);
JUMP(L_closure_end154);
L_closure_body154:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop155:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit155);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop155);
L_env_loop_exit155: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop155:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit155);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop155);
L_params_loop_exit155: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body155));
MOV(R0,R10);
JUMP(L_closure_end155);
L_closure_body155:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop156:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit156);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop156);
L_env_loop_exit156: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop156:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit156);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop156);
L_params_loop_exit156: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body156));
MOV(R0,R10);
JUMP(L_closure_end156);
L_closure_body156:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy127:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit127);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy127);
L_tc_copy_exit127:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end156:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy128:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit128);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy128);
L_tc_copy_exit128:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end155:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop157:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit157);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop157);
L_env_loop_exit157: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop157:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit157);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop157);
L_params_loop_exit157: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body157));
MOV(R0,R10);
JUMP(L_closure_end157);
L_closure_body157:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop158:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit158);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop158);
L_env_loop_exit158: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop158:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit158);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop158);
L_params_loop_exit158: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body158));
MOV(R0,R10);
JUMP(L_closure_end158);
L_closure_body158:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy129:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit129);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy129);
L_tc_copy_exit129:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end158:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy130:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit130);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy130);
L_tc_copy_exit130:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end157:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy131:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit131);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy131);
L_tc_copy_exit131:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end154:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop159:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit159);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop159);
L_env_loop_exit159: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop159:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit159);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop159);
L_params_loop_exit159: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body159));
MOV(R0,R10);
JUMP(L_closure_end159);
L_closure_body159:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop160:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit160);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop160);
L_env_loop_exit160: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop160:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit160);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop160);
L_params_loop_exit160: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body160));
MOV(R0,R10);
JUMP(L_closure_end160);
L_closure_body160:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop161:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit161);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop161);
L_env_loop_exit161: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop161:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit161);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop161);
L_params_loop_exit161: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body161));
MOV(R0,R10);
JUMP(L_closure_end161);
L_closure_body161:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else72);
/* In consts .. */
MOV(R0,IMM(2));
JUMP(L_if3_exit72);
L_if3_else72:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in pvar */
MOV(R0, FPARG(2));
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2012));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy132:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit132);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy132);
L_tc_copy_exit132:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit72:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end161:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end160:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in pvar */
MOV(R0, FPARG(2));
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop162:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit162);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop162);
L_env_loop_exit162: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop162:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit162);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop162);
L_params_loop_exit162: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body162));
MOV(R0,R10);
JUMP(L_closure_end162);
L_closure_body162:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop163:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit163);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop163);
L_env_loop_exit163: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop163:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit163);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop163);
L_params_loop_exit163: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body163));
MOV(R0,R10);
JUMP(L_closure_end163);
L_closure_body163:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop164:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit164);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop164);
L_env_loop_exit164: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop164:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit164);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop164);
L_params_loop_exit164: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body164));
MOV(R0,R10);
JUMP(L_closure_end164);
L_closure_body164:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else73);
/* In consts .. */
MOV(R0,IMM(2));
JUMP(L_if3_exit73);
L_if3_else73:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1987));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2012));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy133:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit133);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy133);
L_tc_copy_exit133:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit73:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end164:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end163:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop165:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit165);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop165);
L_env_loop_exit165: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop165:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit165);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop165);
L_params_loop_exit165: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body165));
MOV(R0,R10);
JUMP(L_closure_end165);
L_closure_body165:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop166:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit166);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop166);
L_env_loop_exit166: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop166:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit166);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop166);
L_params_loop_exit166: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body166));
MOV(R0,R10);
JUMP(L_closure_end166);
L_closure_body166:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy6:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit6);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy6);
L_opt_copy_exit6:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy6:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit6);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy6);
L_opt_2copy_exit6:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy134:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit134);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy134);
L_tc_copy_exit134:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end166:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end165:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy135:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit135);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy135);
L_tc_copy_exit135:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end162:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy136:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit136);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy136);
L_tc_copy_exit136:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end159:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1952), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop148:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit148);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop148);
L_env_loop_exit148: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop148:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit148);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop148);
L_params_loop_exit148: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body148));
MOV(R0,R10);
JUMP(L_closure_end148);
L_closure_body148:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop149:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit149);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop149);
L_env_loop_exit149: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop149:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit149);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop149);
L_params_loop_exit149: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body149));
MOV(R0,R10);
JUMP(L_closure_end149);
L_closure_body149:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop150:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit150);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop150);
L_env_loop_exit150: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop150:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit150);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop150);
L_params_loop_exit150: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body150));
MOV(R0,R10);
JUMP(L_closure_end150);
L_closure_body150:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop151:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit151);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop151);
L_env_loop_exit151: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop151:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit151);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop151);
L_params_loop_exit151: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body151));
MOV(R0,R10);
JUMP(L_closure_end151);
L_closure_body151:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(5));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<4; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop152:
CMP(R5,IMM(4));
JUMP_GE(L_env_loop_exit152);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop152);
L_env_loop_exit152: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop152:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit152);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop152);
L_params_loop_exit152: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body152));
MOV(R0,R10);
JUMP(L_closure_end152);
L_closure_body152:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1987));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1987));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy123:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit123);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy123);
L_tc_copy_exit123:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end152:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end151:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1952));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1987));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy124:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit124);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy124);
L_tc_copy_exit124:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end150:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end149:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1952));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop153:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit153);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop153);
L_env_loop_exit153: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop153:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit153);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop153);
L_params_loop_exit153: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body153));
MOV(R0,R10);
JUMP(L_closure_end153);
L_closure_body153:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1987));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy125:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit125);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy125);
L_tc_copy_exit125:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end153:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy126:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit126);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy126);
L_tc_copy_exit126:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end148:

MOV(ADDR(1947), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop147:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit147);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop147);
L_env_loop_exit147: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop147:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit147);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop147);
L_params_loop_exit147: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body147));
MOV(R0,R10);
JUMP(L_closure_end147);
L_closure_body147:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2097));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy122:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit122);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy122);
L_tc_copy_exit122:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end147:

MOV(ADDR(1942), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop146:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit146);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop146);
L_env_loop_exit146: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop146:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit146);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop146);
L_params_loop_exit146: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body146));
MOV(R0,R10);
JUMP(L_closure_end146);
L_closure_body146:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2092));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy121:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit121);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy121);
L_tc_copy_exit121:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end146:

MOV(ADDR(1937), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop145:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit145);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop145);
L_env_loop_exit145: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop145:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit145);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop145);
L_params_loop_exit145: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body145));
MOV(R0,R10);
JUMP(L_closure_end145);
L_closure_body145:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2087));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy120:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit120);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy120);
L_tc_copy_exit120:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end145:

MOV(ADDR(1932), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop144:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit144);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop144);
L_env_loop_exit144: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop144:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit144);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop144);
L_params_loop_exit144: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body144));
MOV(R0,R10);
JUMP(L_closure_end144);
L_closure_body144:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2082));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy119:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit119);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy119);
L_tc_copy_exit119:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end144:

MOV(ADDR(1927), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop143:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit143);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop143);
L_env_loop_exit143: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop143:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit143);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop143);
L_params_loop_exit143: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body143));
MOV(R0,R10);
JUMP(L_closure_end143);
L_closure_body143:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2077));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy118:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit118);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy118);
L_tc_copy_exit118:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end143:

MOV(ADDR(1922), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop142:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit142);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop142);
L_env_loop_exit142: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop142:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit142);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop142);
L_params_loop_exit142: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body142));
MOV(R0,R10);
JUMP(L_closure_end142);
L_closure_body142:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2072));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy117:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit117);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy117);
L_tc_copy_exit117:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end142:

MOV(ADDR(1917), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop141:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit141);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop141);
L_env_loop_exit141: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop141:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit141);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop141);
L_params_loop_exit141: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body141));
MOV(R0,R10);
JUMP(L_closure_end141);
L_closure_body141:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2067));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy116:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit116);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy116);
L_tc_copy_exit116:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end141:

MOV(ADDR(1912), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop140:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit140);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop140);
L_env_loop_exit140: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop140:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit140);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop140);
L_params_loop_exit140: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body140));
MOV(R0,R10);
JUMP(L_closure_end140);
L_closure_body140:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1917));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1902));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy115:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit115);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy115);
L_tc_copy_exit115:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end140:

MOV(ADDR(1907), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop139:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit139);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop139);
L_env_loop_exit139: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop139:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit139);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop139);
L_params_loop_exit139: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body139));
MOV(R0,R10);
JUMP(L_closure_end139);
L_closure_body139:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1922));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1902));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy114:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit114);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy114);
L_tc_copy_exit114:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end139:

MOV(ADDR(1897), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop138:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit138);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop138);
L_env_loop_exit138: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop138:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit138);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop138);
L_params_loop_exit138: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body138));
MOV(R0,R10);
JUMP(L_closure_end138);
L_closure_body138:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2187));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1942));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy113:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit113);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy113);
L_tc_copy_exit113:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end138:

MOV(ADDR(1892), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop137:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit137);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop137);
L_env_loop_exit137: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop137:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit137);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop137);
L_params_loop_exit137: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body137));
MOV(R0,R10);
JUMP(L_closure_end137);
L_closure_body137:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2187));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1937));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy112:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit112);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy112);
L_tc_copy_exit112:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end137:

MOV(ADDR(1887), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop136:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit136);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop136);
L_env_loop_exit136: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop136:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit136);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop136);
L_params_loop_exit136: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body136));
MOV(R0,R10);
JUMP(L_closure_end136);
L_closure_body136:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* in pvar */
MOV(R0, FPARG(2));

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else71);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit71);
L_if3_else71:
/* In consts .. */
MOV(R0,IMM(5));
L_if3_exit71:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end136:

MOV(ADDR(1902), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop132:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit132);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop132);
L_env_loop_exit132: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop132:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit132);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop132);
L_params_loop_exit132: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body132));
MOV(R0,R10);
JUMP(L_closure_end132);
L_closure_body132:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy5:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit5);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy5);
L_opt_copy_exit5:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy5:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit5);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy5);
L_opt_2copy_exit5:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop134:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit134);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop134);
L_env_loop_exit134: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop134:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit134);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop134);
L_params_loop_exit134: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body134));
MOV(R0,R10);
JUMP(L_closure_end134);
L_closure_body134:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop135:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit135);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop135);
L_env_loop_exit135: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop135:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit135);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop135);
L_params_loop_exit135: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body135));
MOV(R0,R10);
JUMP(L_closure_end135);
L_closure_body135:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2127));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else70);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1952));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1987));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit5);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1952));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy110:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit110);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy110);
L_tc_copy_exit110:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit5);
L_or_exit5:

JUMP(L_if3_exit70);
L_if3_else70:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit70:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end135:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end134:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop133:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit133);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop133);
L_env_loop_exit133: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop133:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit133);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop133);
L_params_loop_exit133: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body133));
MOV(R0,R10);
JUMP(L_closure_end133);
L_closure_body133:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy109:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit109);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy109);
L_tc_copy_exit109:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end133:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy111:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit111);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy111);
L_tc_copy_exit111:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end132:

MOV(ADDR(1882), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop128:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit128);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop128);
L_env_loop_exit128: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop128:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit128);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop128);
L_params_loop_exit128: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body128));
MOV(R0,R10);
JUMP(L_closure_end128);
L_closure_body128:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy4:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit4);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy4);
L_opt_copy_exit4:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy4:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit4);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy4);
L_opt_2copy_exit4:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop130:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit130);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop130);
L_env_loop_exit130: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop130:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit130);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop130);
L_params_loop_exit130: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body130));
MOV(R0,R10);
JUMP(L_closure_end130);
L_closure_body130:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop131:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit131);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop131);
L_env_loop_exit131: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop131:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit131);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop131);
L_params_loop_exit131: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body131));
MOV(R0,R10);
JUMP(L_closure_end131);
L_closure_body131:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit4);
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1952));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1987));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else69);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1952));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy107:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit107);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy107);
L_tc_copy_exit107:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit69);
L_if3_else69:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit69:

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit4);
L_or_exit4:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end131:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end130:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop129:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit129);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop129);
L_env_loop_exit129: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop129:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit129);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop129);
L_params_loop_exit129: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body129));
MOV(R0,R10);
JUMP(L_closure_end129);
L_closure_body129:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy106:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit106);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy106);
L_tc_copy_exit106:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end129:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy108:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit108);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy108);
L_tc_copy_exit108:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end128:

MOV(ADDR(1877), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop123:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit123);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop123);
L_env_loop_exit123: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop123:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit123);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop123);
L_params_loop_exit123: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body123));
MOV(R0,R10);
JUMP(L_closure_end123);
L_closure_body123:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop126:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit126);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop126);
L_env_loop_exit126: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop126:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit126);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop126);
L_params_loop_exit126: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body126));
MOV(R0,R10);
JUMP(L_closure_end126);
L_closure_body126:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop127:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit127);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop127);
L_env_loop_exit127: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop127:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit127);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop127);
L_params_loop_exit127: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body127));
MOV(R0,R10);
JUMP(L_closure_end127);
L_closure_body127:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit3);
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else68);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy104:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit104);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy104);
L_tc_copy_exit104:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit68);
L_if3_else68:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit68:

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit3);
L_or_exit3:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end127:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end126:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop124:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit124);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop124);
L_env_loop_exit124: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop124:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit124);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop124);
L_params_loop_exit124: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body124));
MOV(R0,R10);
JUMP(L_closure_end124);
L_closure_body124:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop125:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit125);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop125);
L_env_loop_exit125: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop125:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit125);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop125);
L_params_loop_exit125: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body125));
MOV(R0,R10);
JUMP(L_closure_end125);
L_closure_body125:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy3:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit3);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy3);
L_opt_copy_exit3:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy3:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit3);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy3);
L_opt_2copy_exit3:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy103:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit103);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy103);
L_tc_copy_exit103:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end125:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end124:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy105:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit105);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy105);
L_tc_copy_exit105:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end123:

MOV(ADDR(1872), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1907));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1867), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1897));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1862), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop120:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit120);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop120);
L_env_loop_exit120: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop120:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit120);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop120);
L_params_loop_exit120: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body120));
MOV(R0,R10);
JUMP(L_closure_end120);
L_closure_body120:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop121:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit121);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop121);
L_env_loop_exit121: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop121:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit121);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop121);
L_params_loop_exit121: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body121));
MOV(R0,R10);
JUMP(L_closure_end121);
L_closure_body121:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit2);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop122:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit122);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop122);
L_env_loop_exit122: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop122:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit122);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop122);
L_params_loop_exit122: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body122));
MOV(R0,R10);
JUMP(L_closure_end122);
L_closure_body122:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2067));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1902));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy101:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit101);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy101);
L_tc_copy_exit101:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end122:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1877));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else67);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy102:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit102);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy102);
L_tc_copy_exit102:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit67);
L_if3_else67:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit67:

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit2);
L_or_exit2:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end121:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end120:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop118:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit118);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop118);
L_env_loop_exit118: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop118:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit118);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop118);
L_params_loop_exit118: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body118));
MOV(R0,R10);
JUMP(L_closure_end118);
L_closure_body118:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop119:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit119);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop119);
L_env_loop_exit119: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop119:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit119);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop119);
L_params_loop_exit119: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body119));
MOV(R0,R10);
JUMP(L_closure_end119);
L_closure_body119:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy100:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit100);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy100);
L_tc_copy_exit100:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end119:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end118:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1857), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop114:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit114);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop114);
L_env_loop_exit114: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop114:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit114);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop114);
L_params_loop_exit114: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body114));
MOV(R0,R10);
JUMP(L_closure_end114);
L_closure_body114:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop116:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit116);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop116);
L_env_loop_exit116: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop116:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit116);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop116);
L_params_loop_exit116: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body116));
MOV(R0,R10);
JUMP(L_closure_end116);
L_closure_body116:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop117:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit117);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop117);
L_env_loop_exit117: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop117:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit117);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop117);
L_params_loop_exit117: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body117));
MOV(R0,R10);
JUMP(L_closure_end117);
L_closure_body117:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else66);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

JUMP(L_if3_exit66);
L_if3_else66:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy98:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit98);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy98);
L_tc_copy_exit98:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit66:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end117:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end116:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop115:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit115);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop115);
L_env_loop_exit115: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop115:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit115);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop115);
L_params_loop_exit115: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body115));
MOV(R0,R10);
JUMP(L_closure_end115);
L_closure_body115:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(2)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy97:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit97);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy97);
L_tc_copy_exit97:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end115:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy99:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit99);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy99);
L_tc_copy_exit99:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end114:

MOV(ADDR(1852), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop109:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit109);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop109);
L_env_loop_exit109: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop109:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit109);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop109);
L_params_loop_exit109: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body109));
MOV(R0,R10);
JUMP(L_closure_end109);
L_closure_body109:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop110:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit110);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop110);
L_env_loop_exit110: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop110:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit110);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop110);
L_params_loop_exit110: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body110));
MOV(R0,R10);
JUMP(L_closure_end110);
L_closure_body110:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy95:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit95);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy95);
L_tc_copy_exit95:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end110:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end109:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop111:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit111);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop111);
L_env_loop_exit111: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop111:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit111);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop111);
L_params_loop_exit111: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body111));
MOV(R0,R10);
JUMP(L_closure_end111);
L_closure_body111:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop112:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit112);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop112);
L_env_loop_exit112: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop112:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit112);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop112);
L_params_loop_exit112: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body112));
MOV(R0,R10);
JUMP(L_closure_end112);
L_closure_body112:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop113:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit113);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop113);
L_env_loop_exit113: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop113:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit113);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop113);
L_params_loop_exit113: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body113));
MOV(R0,R10);
JUMP(L_closure_end113);
L_closure_body113:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* in pvar */
MOV(R0, FPARG(2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end113:

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1852));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy96:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit96);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy96);
L_tc_copy_exit96:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end112:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end111:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1847), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1842), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1837), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1832), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1827), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1842));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1822), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1837));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1817), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1832));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1812), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1827));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1807), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1842));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1802), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1837));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1797), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1832));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1792), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1827));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1787), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1822));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1782), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1817));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1777), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1812));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1772), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1807));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1767), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1802));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1762), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1797));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1757), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1792));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1752), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1787));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1747), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1822));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1742), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1817));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1737), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1812));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1732), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1807));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1727), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1802));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1722), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1797));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1717), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1792));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1712), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1787));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1707), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop104:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit104);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop104);
L_env_loop_exit104: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop104:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit104);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop104);
L_params_loop_exit104: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body104));
MOV(R0,R10);
JUMP(L_closure_end104);
L_closure_body104:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop107:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit107);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop107);
L_env_loop_exit107: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop107:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit107);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop107);
L_params_loop_exit107: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body107));
MOV(R0,R10);
JUMP(L_closure_end107);
L_closure_body107:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop108:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit108);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop108);
L_env_loop_exit108: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop108:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit108);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop108);
L_params_loop_exit108: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body108));
MOV(R0,R10);
JUMP(L_closure_end108);
L_closure_body108:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else65);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

JUMP(L_if3_exit65);
L_if3_else65:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy93:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit93);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy93);
L_tc_copy_exit93:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit65:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end108:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end107:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop105:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit105);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop105);
L_env_loop_exit105: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop105:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit105);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop105);
L_params_loop_exit105: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body105));
MOV(R0,R10);
JUMP(L_closure_end105);
L_closure_body105:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop106:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit106);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop106);
L_env_loop_exit106: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop106:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit106);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop106);
L_params_loop_exit106: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body106));
MOV(R0,R10);
JUMP(L_closure_end106);
L_closure_body106:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy92:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit92);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy92);
L_tc_copy_exit92:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end106:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end105:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy94:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit94);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy94);
L_tc_copy_exit94:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end104:

MOV(ADDR(1702), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop99:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit99);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop99);
L_env_loop_exit99: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop99:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit99);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop99);
L_params_loop_exit99: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body99));
MOV(R0,R10);
JUMP(L_closure_end99);
L_closure_body99:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop102:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit102);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop102);
L_env_loop_exit102: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop102:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit102);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop102);
L_params_loop_exit102: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body102));
MOV(R0,R10);
JUMP(L_closure_end102);
L_closure_body102:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop103:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit103);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop103);
L_env_loop_exit103: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop103:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit103);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop103);
L_params_loop_exit103: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body103));
MOV(R0,R10);
JUMP(L_closure_end103);
L_closure_body103:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else64);
/* in pvar */
MOV(R0, FPARG(2));

JUMP(L_if3_exit64);
L_if3_else64:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy90:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit90);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy90);
L_tc_copy_exit90:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit64:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end103:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end102:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop100:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit100);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop100);
L_env_loop_exit100: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop100:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit100);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop100);
L_params_loop_exit100: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body100));
MOV(R0,R10);
JUMP(L_closure_end100);
L_closure_body100:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop101:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit101);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop101);
L_env_loop_exit101: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop101:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit101);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop101);
L_params_loop_exit101: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body101));
MOV(R0,R10);
JUMP(L_closure_end101);
L_closure_body101:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else63);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

JUMP(L_if3_exit63);
L_if3_else63:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy89:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit89);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy89);
L_tc_copy_exit89:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit63:

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end101:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end100:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy91:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit91);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy91);
L_tc_copy_exit91:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end99:

MOV(ADDR(1697), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop97:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit97);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop97);
L_env_loop_exit97: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop97:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit97);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop97);
L_params_loop_exit97: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body97));
MOV(R0,R10);
JUMP(L_closure_end97);
L_closure_body97:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop98:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit98);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop98);
L_env_loop_exit98: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop98:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit98);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop98);
L_params_loop_exit98: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body98));
MOV(R0,R10);
JUMP(L_closure_end98);
L_closure_body98:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2062));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2062));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy88:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit88);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy88);
L_tc_copy_exit88:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end98:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end97:

MOV(ADDR(1692), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1912));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1692));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1687), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1907));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1692));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1682), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1922));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1692));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1677), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1897));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1692));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1672), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1917));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1692));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1667), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop96:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit96);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop96);
L_env_loop_exit96: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop96:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit96);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop96);
L_params_loop_exit96: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body96));
MOV(R0,R10);
JUMP(L_closure_end96);
L_closure_body96:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* In consts .. */
MOV(R0,IMM(2185));
PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1682));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else62);
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2183));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1682));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy87:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit87);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy87);
L_tc_copy_exit87:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit62);
L_if3_else62:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit62:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end96:

MOV(ADDR(1662), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop95:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit95);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop95);
L_env_loop_exit95: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop95:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit95);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop95);
L_params_loop_exit95: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body95));
MOV(R0,R10);
JUMP(L_closure_end95);
L_closure_body95:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* In consts .. */
MOV(R0,IMM(2181));
PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1682));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else61);
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2179));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1682));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy86:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit86);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy86);
L_tc_copy_exit86:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit61);
L_if3_else61:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit61:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end95:

MOV(ADDR(1657), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2185));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2062));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2181));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2062));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2092));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop93:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit93);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop93);
L_env_loop_exit93: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop93:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit93);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop93);
L_params_loop_exit93: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body93));
MOV(R0,R10);
JUMP(L_closure_end93);
L_closure_body93:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop94:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit94);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop94);
L_env_loop_exit94: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop94:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit94);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop94);
L_params_loop_exit94: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body94));
MOV(R0,R10);
JUMP(L_closure_end94);
L_closure_body94:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1657));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else60);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2062));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2092));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2057));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy85:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit85);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy85);
L_tc_copy_exit85:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit60);
L_if3_else60:
/* in pvar */
MOV(R0, FPARG(2));

L_if3_exit60:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end94:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end93:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1652), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2185));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2062));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2181));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2062));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2092));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop91:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit91);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop91);
L_env_loop_exit91: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop91:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit91);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop91);
L_params_loop_exit91: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body91));
MOV(R0,R10);
JUMP(L_closure_end91);
L_closure_body91:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop92:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit92);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop92);
L_env_loop_exit92: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop92:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit92);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop92);
L_params_loop_exit92: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body92));
MOV(R0,R10);
JUMP(L_closure_end92);
L_closure_body92:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1662));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else59);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2062));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2097));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2057));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy84:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit84);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy84);
L_tc_copy_exit84:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit59);
L_if3_else59:
/* in pvar */
MOV(R0, FPARG(2));

L_if3_exit59:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end92:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end91:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1647), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop90:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit90);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop90);
L_env_loop_exit90: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop90:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit90);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop90);
L_params_loop_exit90: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body90));
MOV(R0,R10);
JUMP(L_closure_end90);
L_closure_body90:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1652));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1652));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1682));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy83:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit83);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy83);
L_tc_copy_exit83:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end90:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1642), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop89:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit89);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop89);
L_env_loop_exit89: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop89:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit89);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop89);
L_params_loop_exit89: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body89));
MOV(R0,R10);
JUMP(L_closure_end89);
L_closure_body89:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1652));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1652));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1677));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy82:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit82);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy82);
L_tc_copy_exit82:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end89:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1637), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop88:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit88);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop88);
L_env_loop_exit88: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop88:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit88);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop88);
L_params_loop_exit88: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body88));
MOV(R0,R10);
JUMP(L_closure_end88);
L_closure_body88:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1652));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1652));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1687));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy81:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit81);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy81);
L_tc_copy_exit81:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end88:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1632), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop87:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit87);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop87);
L_env_loop_exit87: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop87:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit87);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop87);
L_params_loop_exit87: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body87));
MOV(R0,R10);
JUMP(L_closure_end87);
L_closure_body87:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1652));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1652));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1667));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy80:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit80);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy80);
L_tc_copy_exit80:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end87:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1627), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop86:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit86);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop86);
L_env_loop_exit86: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop86:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit86);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop86);
L_params_loop_exit86: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body86));
MOV(R0,R10);
JUMP(L_closure_end86);
L_closure_body86:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1652));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1652));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1672));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy79:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit79);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy79);
L_tc_copy_exit79:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end86:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1622), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop85:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit85);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop85);
L_env_loop_exit85: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop85:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit85);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop85);
L_params_loop_exit85: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body85));
MOV(R0,R10);
JUMP(L_closure_end85);
L_closure_body85:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1607));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1652));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1952));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1612));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy78:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit78);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy78);
L_tc_copy_exit78:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end85:

MOV(ADDR(1617), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop84:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit84);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop84);
L_env_loop_exit84: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop84:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit84);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop84);
L_params_loop_exit84: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body84));
MOV(R0,R10);
JUMP(L_closure_end84);
L_closure_body84:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1607));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1647));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1952));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1612));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy77:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit77);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy77);
L_tc_copy_exit77:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end84:

MOV(ADDR(1602), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop83:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit83);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop83);
L_env_loop_exit83: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop83:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit83);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop83);
L_params_loop_exit83: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body83));
MOV(R0,R10);
JUMP(L_closure_end83);
L_closure_body83:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2177));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1592));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2112));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy76:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit76);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy76);
L_tc_copy_exit76:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end83:

MOV(ADDR(1597), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop82:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit82);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop82);
L_env_loop_exit82: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop82:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit82);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop82);
L_params_loop_exit82: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body82));
MOV(R0,R10);
JUMP(L_closure_end82);
L_closure_body82:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2177));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1592));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2112));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1902));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy75:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit75);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy75);
L_tc_copy_exit75:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end82:

MOV(ADDR(1587), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop81:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit81);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop81);
L_env_loop_exit81: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop81:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit81);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop81);
L_params_loop_exit81: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body81));
MOV(R0,R10);
JUMP(L_closure_end81);
L_closure_body81:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else58);
/* In consts .. */
MOV(R0,IMM(2175));
JUMP(L_if3_exit58);
L_if3_else58:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1982));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1892));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy74:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit74);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy74);
L_tc_copy_exit74:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit58:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end81:

MOV(ADDR(1982), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop80:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit80);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop80);
L_env_loop_exit80: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop80:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit80);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop80);
L_params_loop_exit80: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body80));
MOV(R0,R10);
JUMP(L_closure_end80);
L_closure_body80:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* in pvar */
MOV(R0, FPARG(2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end80:

MOV(ADDR(1997), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop79:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit79);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop79);
L_env_loop_exit79: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop79:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit79);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop79);
L_params_loop_exit79: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body79));
MOV(R0,R10);
JUMP(L_closure_end79);
L_closure_body79:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2112));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else57);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy72:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit72);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy72);
L_tc_copy_exit72:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit57);
L_if3_else57:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2187));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2092));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1582));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy73:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit73);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy73);
L_tc_copy_exit73:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit57:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end79:

MOV(ADDR(1582), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop78:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit78);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop78);
L_env_loop_exit78: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop78:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit78);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop78);
L_params_loop_exit78: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body78));
MOV(R0,R10);
JUMP(L_closure_end78);
L_closure_body78:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit1);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2127));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else56);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1577));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy71:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit71);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy71);
L_tc_copy_exit71:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit56);
L_if3_else56:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit56:

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit1);
L_or_exit1:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end78:

MOV(ADDR(1577), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop76:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit76);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop76);
L_env_loop_exit76: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop76:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit76);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop76);
L_params_loop_exit76: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body76));
MOV(R0,R10);
JUMP(L_closure_end76);
L_closure_body76:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop77:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit77);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop77);
L_env_loop_exit77: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop77:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit77);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop77);
L_params_loop_exit77: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body77));
MOV(R0,R10);
JUMP(L_closure_end77);
L_closure_body77:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1967));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy69:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit69);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy69);
L_tc_copy_exit69:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end77:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1882));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy70:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit70);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy70);
L_tc_copy_exit70:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end76:

MOV(ADDR(1572), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop75:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit75);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop75);
L_env_loop_exit75: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop75:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit75);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop75);
L_params_loop_exit75: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body75));
MOV(R0,R10);
JUMP(L_closure_end75);
L_closure_body75:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2077));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy68:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit68);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy68);
L_tc_copy_exit68:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end75:

MOV(ADDR(1567), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop74:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit74);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop74);
L_env_loop_exit74: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop74:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit74);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop74);
L_params_loop_exit74: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body74));
MOV(R0,R10);
JUMP(L_closure_end74);
L_closure_body74:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2072));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy67:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit67);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy67);
L_tc_copy_exit67:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end74:

MOV(ADDR(1562), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop73:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit73);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop73);
L_env_loop_exit73: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop73:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit73);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop73);
L_params_loop_exit73: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body73));
MOV(R0,R10);
JUMP(L_closure_end73);
L_closure_body73:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1557));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy66:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit66);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy66);
L_tc_copy_exit66:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end73:

MOV(ADDR(1992), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop71:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit71);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop71);
L_env_loop_exit71: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop71:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit71);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop71);
L_params_loop_exit71: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body71));
MOV(R0,R10);
JUMP(L_closure_end71);
L_closure_body71:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop72:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit72);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop72);
L_env_loop_exit72: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop72:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit72);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop72);
L_params_loop_exit72: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body72));
MOV(R0,R10);
JUMP(L_closure_end72);
L_closure_body72:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2173));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2067));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else55);
/* in pvar */
MOV(R0, FPARG(4));

JUMP(L_if3_exit55);
L_if3_else55:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2047));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2012));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2187));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2092));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy65:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit65);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy65);
L_tc_copy_exit65:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit55:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end72:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end71:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop69:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit69);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop69);
L_env_loop_exit69: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop69:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit69);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop69);
L_params_loop_exit69: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body69));
MOV(R0,R10);
JUMP(L_closure_end69);
L_closure_body69:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop70:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit70);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop70);
L_env_loop_exit70: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop70:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit70);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop70);
L_params_loop_exit70: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body70));
MOV(R0,R10);
JUMP(L_closure_end70);
L_closure_body70:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2));
PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2187));
PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2052));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2092));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy64:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit64);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy64);
L_tc_copy_exit64:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end70:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end69:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1607), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop66:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit66);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop66);
L_env_loop_exit66: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop66:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit66);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop66);
L_params_loop_exit66: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body66));
MOV(R0,R10);
JUMP(L_closure_end66);
L_closure_body66:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2052));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2052));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop67:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit67);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop67);
L_env_loop_exit67: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop67:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit67);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop67);
L_params_loop_exit67: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body67));
MOV(R0,R10);
JUMP(L_closure_end67);
L_closure_body67:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2067));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else54);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1607));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1607));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop68:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit68);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop68);
L_env_loop_exit68: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop68:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit68);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop68);
L_params_loop_exit68: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body68));
MOV(R0,R10);
JUMP(L_closure_end68);
L_closure_body68:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1687));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1877));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy61:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit61);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy61);
L_tc_copy_exit61:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end68:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy62:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit62);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy62);
L_tc_copy_exit62:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit54);
L_if3_else54:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit54:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end67:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy63:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit63);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy63);
L_tc_copy_exit63:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end66:

MOV(ADDR(1552), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop62:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit62);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop62);
L_env_loop_exit62: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop62:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit62);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop62);
L_params_loop_exit62: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body62));
MOV(R0,R10);
JUMP(L_closure_end62);
L_closure_body62:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop64:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit64);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop64);
L_env_loop_exit64: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop64:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit64);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop64);
L_params_loop_exit64: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body64));
MOV(R0,R10);
JUMP(L_closure_end64);
L_closure_body64:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop65:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit65);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop65);
L_env_loop_exit65: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop65:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit65);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop65);
L_params_loop_exit65: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body65));
MOV(R0,R10);
JUMP(L_closure_end65);
L_closure_body65:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else53);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2127));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy57:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit57);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy57);
L_tc_copy_exit57:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit53);
L_if3_else53:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else52);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit52);
L_if3_else52:
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1687));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else51);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy58:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit58);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy58);
L_tc_copy_exit58:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit51);
L_if3_else51:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1677));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy59:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit59);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy59);
L_tc_copy_exit59:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit51:

L_if3_exit52:

L_if3_exit53:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end65:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end64:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop63:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit63);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop63);
L_env_loop_exit63: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop63:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit63);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop63);
L_params_loop_exit63: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body63));
MOV(R0,R10);
JUMP(L_closure_end63);
L_closure_body63:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1607));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1607));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy56:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit56);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy56);
L_tc_copy_exit56:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end63:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy60:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit60);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy60);
L_tc_copy_exit60:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end62:

MOV(ADDR(1547), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop61:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit61);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop61);
L_env_loop_exit61: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop61:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit61);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop61);
L_params_loop_exit61: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body61));
MOV(R0,R10);
JUMP(L_closure_end61);
L_closure_body61:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1547));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy55:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit55);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy55);
L_tc_copy_exit55:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end61:

MOV(ADDR(1542), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop60:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit60);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop60);
L_env_loop_exit60: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop60:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit60);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop60);
L_params_loop_exit60: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body60));
MOV(R0,R10);
JUMP(L_closure_end60);
L_closure_body60:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1542));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1902));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy54:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit54);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy54);
L_tc_copy_exit54:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end60:

MOV(ADDR(1537), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop59:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit59);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop59);
L_env_loop_exit59: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop59:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit59);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop59);
L_params_loop_exit59: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body59));
MOV(R0,R10);
JUMP(L_closure_end59);
L_closure_body59:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1547));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1902));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy53:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit53);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy53);
L_tc_copy_exit53:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end59:

MOV(ADDR(1532), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1552));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1527), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1547));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1522), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1542));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1517), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1537));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1512), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1532));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1872));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1507), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop57:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit57);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop57);
L_env_loop_exit57: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop57:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit57);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop57);
L_params_loop_exit57: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body57));
MOV(R0,R10);
JUMP(L_closure_end57);
L_closure_body57:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop58:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit58);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop58);
L_env_loop_exit58: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop58:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit58);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop58);
L_params_loop_exit58: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body58));
MOV(R0,R10);
JUMP(L_closure_end58);
L_closure_body58:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2173));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2067));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else50);
/* in pvar */
MOV(R0, FPARG(4));

JUMP(L_if3_exit50);
L_if3_else50:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2027));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2012));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2187));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2092));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy52:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit52);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy52);
L_tc_copy_exit52:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit50:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end58:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end57:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop55:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit55);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop55);
L_env_loop_exit55: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop55:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit55);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop55);
L_params_loop_exit55: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body55));
MOV(R0,R10);
JUMP(L_closure_end55);
L_closure_body55:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop56:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit56);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop56);
L_env_loop_exit56: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop56:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit56);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop56);
L_params_loop_exit56: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body56));
MOV(R0,R10);
JUMP(L_closure_end56);
L_closure_body56:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2));
PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2187));
PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2032));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2092));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy51:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit51);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy51);
L_tc_copy_exit51:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end56:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end55:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1502), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop49:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit49);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop49);
L_env_loop_exit49: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop49:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit49);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop49);
L_params_loop_exit49: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body49));
MOV(R0,R10);
JUMP(L_closure_end49);
L_closure_body49:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1982));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop50:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit50);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop50);
L_env_loop_exit50: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop50:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit50);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop50);
L_params_loop_exit50: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body50));
MOV(R0,R10);
JUMP(L_closure_end50);
L_closure_body50:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2037));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop51:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit51);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop51);
L_env_loop_exit51: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop51:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit51);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop51);
L_params_loop_exit51: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body51));
MOV(R0,R10);
JUMP(L_closure_end51);
L_closure_body51:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop53:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit53);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop53);
L_env_loop_exit53: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop53:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit53);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop53);
L_params_loop_exit53: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body53));
MOV(R0,R10);
JUMP(L_closure_end53);
L_closure_body53:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(5));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<4; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop54:
CMP(R5,IMM(4));
JUMP_GE(L_env_loop_exit54);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop54);
L_env_loop_exit54: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop54:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit54);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop54);
L_params_loop_exit54: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body54));
MOV(R0,R10);
JUMP(L_closure_end54);
L_closure_body54:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(2)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2067));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else49);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

JUMP(L_if3_exit49);
L_if3_else49:
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* in fvar */
MOV(R1, IMM(2042));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2187));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2097));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy47:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit47);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy47);
L_tc_copy_exit47:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));


L_if3_exit49:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end54:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end53:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop52:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit52);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop52);
L_env_loop_exit52: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop52:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit52);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop52);
L_params_loop_exit52: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body52));
MOV(R0,R10);
JUMP(L_closure_end52);
L_closure_body52:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(2)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy46:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit46);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy46);
L_tc_copy_exit46:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end52:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy48:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit48);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy48);
L_tc_copy_exit48:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end51:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy49:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit49);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy49);
L_tc_copy_exit49:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end50:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy50:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit50);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy50);
L_tc_copy_exit50:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end49:

MOV(ADDR(1612), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop43:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit43);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop43);
L_env_loop_exit43: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop43:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit43);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop43);
L_params_loop_exit43: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body43));
MOV(R0,R10);
JUMP(L_closure_end43);
L_closure_body43:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1982));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop44:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit44);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop44);
L_env_loop_exit44: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop44:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit44);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop44);
L_params_loop_exit44: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body44));
MOV(R0,R10);
JUMP(L_closure_end44);
L_closure_body44:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2017));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop45:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit45);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop45);
L_env_loop_exit45: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop45:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit45);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop45);
L_params_loop_exit45: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body45));
MOV(R0,R10);
JUMP(L_closure_end45);
L_closure_body45:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop47:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit47);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop47);
L_env_loop_exit47: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop47:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit47);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop47);
L_params_loop_exit47: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body47));
MOV(R0,R10);
JUMP(L_closure_end47);
L_closure_body47:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(5));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<4; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop48:
CMP(R5,IMM(4));
JUMP_GE(L_env_loop_exit48);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop48);
L_env_loop_exit48: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop48:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit48);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop48);
L_params_loop_exit48: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body48));
MOV(R0,R10);
JUMP(L_closure_end48);
L_closure_body48:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(2)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2067));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else48);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

JUMP(L_if3_exit48);
L_if3_else48:
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* in fvar */
MOV(R1, IMM(2022));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2187));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2097));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy42:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit42);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy42);
L_tc_copy_exit42:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));


L_if3_exit48:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end48:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end47:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop46:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit46);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop46);
L_env_loop_exit46: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop46:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit46);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop46);
L_params_loop_exit46: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body46));
MOV(R0,R10);
JUMP(L_closure_end46);
L_closure_body46:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(2)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy41:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit41);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy41);
L_tc_copy_exit41:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end46:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy43:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit43);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy43);
L_tc_copy_exit43:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end45:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy44:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit44);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy44);
L_tc_copy_exit44:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end44:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy45:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit45);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy45);
L_tc_copy_exit45:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end43:

MOV(ADDR(1557), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop42:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit42);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop42);
L_env_loop_exit42: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop42:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit42);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop42);
L_params_loop_exit42: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body42));
MOV(R0,R10);
JUMP(L_closure_end42);
L_closure_body42:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else47);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit47);
L_if3_else47:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1492));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else46);
/* in pvar */
MOV(R0, FPARG(3));

JUMP(L_if3_exit46);
L_if3_else46:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1497));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy40:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit40);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy40);
L_tc_copy_exit40:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit46:

L_if3_exit47:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end42:

MOV(ADDR(1497), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* I am in the if exp */
/* In consts .. */
MOV(R0,IMM(3));
CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else27);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit27);
L_if3_else27:
/* In consts .. */
MOV(R0,IMM(1));
L_if3_exit27:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop38:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit38);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop38);
L_env_loop_exit38: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop38:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit38);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop38);
L_params_loop_exit38: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body38));
MOV(R0,R10);
JUMP(L_closure_end38);
L_closure_body38:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop40:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit40);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop40);
L_env_loop_exit40: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop40:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit40);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop40);
L_params_loop_exit40: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body40));
MOV(R0,R10);
JUMP(L_closure_end40);
L_closure_body40:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop41:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit41);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop41);
L_env_loop_exit41: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop41:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit41);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop41);
L_params_loop_exit41: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body41));
MOV(R0,R10);
JUMP(L_closure_end41);
L_closure_body41:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2142));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else28);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2142));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit28);
L_if3_else28:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit28:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else45);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1487));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy30:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit30);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy30);
L_tc_copy_exit30:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit45);
L_if3_else45:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2137));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else29);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2137));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit29);
L_if3_else29:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit29:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else44);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1687));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy31:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit31);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy31);
L_tc_copy_exit31:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit44);
L_if3_else44:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else43);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy32:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit32);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy32);
L_tc_copy_exit32:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit43);
L_if3_else43:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2152));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else30);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2152));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit30);
L_if3_else30:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit30:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else42);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2067));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy33:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit33);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy33);
L_tc_copy_exit33:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit42);
L_if3_else42:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2127));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else31);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2127));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit31);
L_if3_else31:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit31:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else41);
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else32);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy34:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit34);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy34);
L_tc_copy_exit34:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit32);
L_if3_else32:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit32:

JUMP(L_if3_exit41);
L_if3_else41:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2122));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else33);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2122));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit33);
L_if3_else33:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit33:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else40);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1527));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy35:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit35);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy35);
L_tc_copy_exit35:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit40);
L_if3_else40:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2117));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else34);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2117));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit34);
L_if3_else34:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit34:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else39);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1967));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy36:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit36);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy36);
L_tc_copy_exit36:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit39);
L_if3_else39:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2107));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else36);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2107));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else35);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2032));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2032));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2067));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit35);
L_if3_else35:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit35:

JUMP(L_if3_exit36);
L_if3_else36:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit36:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else38);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1502));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1502));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy37:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit37);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy37);
L_tc_copy_exit37:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit38);
L_if3_else38:
/* I am in the if exp */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1967));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else37);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1967));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy38:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit38);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy38);
L_tc_copy_exit38:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit37);
L_if3_else37:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit37:

L_if3_exit38:

L_if3_exit39:

L_if3_exit40:

L_if3_exit41:

L_if3_exit42:

L_if3_exit43:

L_if3_exit44:

L_if3_exit45:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end41:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end40:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop39:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit39);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop39);
L_env_loop_exit39: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop39:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit39);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop39);
L_params_loop_exit39: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body39));
MOV(R0,R10);
JUMP(L_closure_end39);
L_closure_body39:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* in pvar */
MOV(R0, FPARG(3));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end39:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy39:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit39);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy39);
L_tc_copy_exit39:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end38:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1492), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop34:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit34);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop34);
L_env_loop_exit34: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop34:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit34);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop34);
L_params_loop_exit34: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body34));
MOV(R0,R10);
JUMP(L_closure_end34);
L_closure_body34:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop36:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit36);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop36);
L_env_loop_exit36: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop36:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit36);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop36);
L_params_loop_exit36: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body36));
MOV(R0,R10);
JUMP(L_closure_end36);
L_closure_body36:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop37:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit37);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop37);
L_env_loop_exit37: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop37:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit37);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop37);
L_params_loop_exit37: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body37));
MOV(R0,R10);
JUMP(L_closure_end37);
L_closure_body37:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else26);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit26);
L_if3_else26:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1842));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else25);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy27:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit27);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy27);
L_tc_copy_exit27:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit25);
L_if3_else25:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy28:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit28);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy28);
L_tc_copy_exit28:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit25:

L_if3_exit26:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end37:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end36:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop35:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit35);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop35);
L_env_loop_exit35: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop35:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit35);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop35);
L_params_loop_exit35: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body35));
MOV(R0,R10);
JUMP(L_closure_end35);
L_closure_body35:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* in pvar */
MOV(R0, FPARG(3));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end35:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy29:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit29);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy29);
L_tc_copy_exit29:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end34:

MOV(ADDR(1482), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1492));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1482));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1477), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1967));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1482));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1472), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop33:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit33);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop33);
L_env_loop_exit33: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop33:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit33);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop33);
L_params_loop_exit33: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body33));
MOV(R0,R10);
JUMP(L_closure_end33);
L_closure_body33:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2142));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else22);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2142));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit22);
L_if3_else22:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit22:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else24);
/* I am in the if exp */
/* in pvar */
MOV(R0, FPARG(2));

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else23);
/* in pvar */
MOV(R0, FPARG(3));

JUMP(L_if3_exit23);
L_if3_else23:
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1902));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy26:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit26);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy26);
L_tc_copy_exit26:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit23:

JUMP(L_if3_exit24);
L_if3_else24:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit24:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end33:

MOV(ADDR(1487), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* I am in the if exp */
/* In consts .. */
MOV(R0,IMM(3));
CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else21);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit21);
L_if3_else21:
/* In consts .. */
MOV(R0,IMM(1));
L_if3_exit21:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop31:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit31);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop31);
L_env_loop_exit31: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop31:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit31);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop31);
L_params_loop_exit31: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body31));
MOV(R0,R10);
JUMP(L_closure_end31);
L_closure_body31:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop32:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit32);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop32);
L_env_loop_exit32: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop32:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit32);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop32);
L_params_loop_exit32: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body32));
MOV(R0,R10);
JUMP(L_closure_end32);
L_closure_body32:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(0));
JUMP_NE(ERROR);
/* Call code gen ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end32:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end31:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1467), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* push number of args. */
PUSH(IMM(0));
/* in fvar */
MOV(R1, IMM(1467));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop29:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit29);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop29);
L_env_loop_exit29: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop29:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit29);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop29);
L_params_loop_exit29: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body29));
MOV(R0,R10);
JUMP(L_closure_end29);
L_closure_body29:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop30:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit30);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop30);
L_env_loop_exit30: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop30:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit30);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop30);
L_params_loop_exit30: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body30));
MOV(R0,R10);
JUMP(L_closure_end30);
L_closure_body30:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1967));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy25:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit25);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy25);
L_tc_copy_exit25:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end30:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end29:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1462), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop28:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit28);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop28);
L_env_loop_exit28: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop28:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit28);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop28);
L_params_loop_exit28: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body28));
MOV(R0,R10);
JUMP(L_closure_end28);
L_closure_body28:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1607));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1952));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1452));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1987));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1612));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy24:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit24);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy24);
L_tc_copy_exit24:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end28:

MOV(ADDR(1457), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop27:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit27);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop27);
L_env_loop_exit27: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop27:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit27);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop27);
L_params_loop_exit27: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body27));
MOV(R0,R10);
JUMP(L_closure_end27);
L_closure_body27:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1502));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1952));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1452));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1987));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1557));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy23:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit23);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy23);
L_tc_copy_exit23:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end27:

MOV(ADDR(1447), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop21:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit21);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop21);
L_env_loop_exit21: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop21:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit21);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop21);
L_params_loop_exit21: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body21));
MOV(R0,R10);
JUMP(L_closure_end21);
L_closure_body21:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop22:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit22);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop22);
L_env_loop_exit22: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop22:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit22);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop22);
L_params_loop_exit22: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body22));
MOV(R0,R10);
JUMP(L_closure_end22);
L_closure_body22:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else18);
/* in pvar */
MOV(R0, FPARG(2));

JUMP(L_if3_exit18);
L_if3_else18:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(2)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy20:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit20);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy20);
L_tc_copy_exit20:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit18:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end22:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end21:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop25:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit25);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop25);
L_env_loop_exit25: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop25:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit25);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop25);
L_params_loop_exit25: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body25));
MOV(R0,R10);
JUMP(L_closure_end25);
L_closure_body25:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop26:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit26);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop26);
L_env_loop_exit26: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop26:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit26);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop26);
L_params_loop_exit26: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body26));
MOV(R0,R10);
JUMP(L_closure_end26);
L_closure_body26:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else20);
/* in pvar */
MOV(R0, FPARG(3));

JUMP(L_if3_exit20);
L_if3_else20:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2012));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy22:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit22);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy22);
L_tc_copy_exit22:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit20:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end26:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end25:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop23:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit23);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop23);
L_env_loop_exit23: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop23:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit23);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop23);
L_params_loop_exit23: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body23));
MOV(R0,R10);
JUMP(L_closure_end23);
L_closure_body23:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop24:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit24);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop24);
L_env_loop_exit24: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop24:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit24);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop24);
L_params_loop_exit24: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body24));
MOV(R0,R10);
JUMP(L_closure_end24);
L_closure_body24:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else19);
/* In consts .. */
MOV(R0,IMM(2));
JUMP(L_if3_exit19);
L_if3_else19:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(2)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy21:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit21);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy21);
L_tc_copy_exit21:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit19:

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end24:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end23:

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1452), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop19:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit19);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop19);
L_env_loop_exit19: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop19:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit19);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop19);
L_params_loop_exit19: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body19));
MOV(R0,R10);
JUMP(L_closure_end19);
L_closure_body19:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop20:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit20);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop20);
L_env_loop_exit20: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop20:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit20);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop20);
L_params_loop_exit20: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body20));
MOV(R0,R10);
JUMP(L_closure_end20);
L_closure_body20:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2132));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else17);
/* in pvar */
MOV(R0, FPARG(3));

JUMP(L_if3_exit17);
L_if3_else17:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2012));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy19:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit19);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy19);
L_tc_copy_exit19:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit17:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end20:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end19:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop17:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit17);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop17);
L_env_loop_exit17: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop17:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit17);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop17);
L_params_loop_exit17: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body17));
MOV(R0,R10);
JUMP(L_closure_end17);
L_closure_body17:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop18:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit18);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop18);
L_env_loop_exit18: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop18:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit18);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop18);
L_params_loop_exit18: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body18));
MOV(R0,R10);
JUMP(L_closure_end18);
L_closure_body18:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy18:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit18);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy18);
L_tc_copy_exit18:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end18:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end17:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1442), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1607));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1442));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1612));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* in fvar */
MOV(R1, IMM(1847));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1437), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop16:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit16);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop16);
L_env_loop_exit16: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop16:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit16);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop16);
L_params_loop_exit16: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body16));
MOV(R0,R10);
JUMP(L_closure_end16);
L_closure_body16:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2112));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else16);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy16:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit16);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy16);
L_tc_copy_exit16:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit16);
L_if3_else16:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2187));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2092));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1582));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy17:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit17);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy17);
L_tc_copy_exit17:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit16:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end16:

MOV(ADDR(1582), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop15:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit15);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop15);
L_env_loop_exit15: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop15:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit15);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop15);
L_params_loop_exit15: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body15));
MOV(R0,R10);
JUMP(L_closure_end15);
L_closure_body15:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2112));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else15);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1957));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy14:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit14);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy14);
L_tc_copy_exit14:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit15);
L_if3_else15:
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2187));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2092));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1432));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy15:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit15);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy15);
L_tc_copy_exit15:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit15:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end15:

MOV(ADDR(1432), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop12:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit12);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop12);
L_env_loop_exit12: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop12:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit12);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop12);
L_params_loop_exit12: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body12));
MOV(R0,R10);
JUMP(L_closure_end12);
L_closure_body12:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2072));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else14);
/* in pvar */
MOV(R0, FPARG(2));

JUMP(L_if3_exit14);
L_if3_else14:
/* in pvar */
MOV(R0, FPARG(3));

L_if3_exit14:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end12:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop13:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit13);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop13);
L_env_loop_exit13: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop13:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit13);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop13);
L_params_loop_exit13: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body13));
MOV(R0,R10);
JUMP(L_closure_end13);
L_closure_body13:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop14:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit14);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop14);
L_env_loop_exit14: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop14:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit14);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop14);
L_params_loop_exit14: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body14));
MOV(R0,R10);
JUMP(L_closure_end14);
L_closure_body14:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy2:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit2);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy2);
L_opt_copy_exit2:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy2:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit2);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy2);
L_opt_2copy_exit2:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1852));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy13:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit13);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy13);
L_tc_copy_exit13:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end14:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end13:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1427), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop9:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit9);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop9);
L_env_loop_exit9: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop9:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit9);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop9);
L_params_loop_exit9: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body9));
MOV(R0,R10);
JUMP(L_closure_end9);
L_closure_body9:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2077));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else13);
/* in pvar */
MOV(R0, FPARG(2));

JUMP(L_if3_exit13);
L_if3_else13:
/* in pvar */
MOV(R0, FPARG(3));

L_if3_exit13:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end9:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop10:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit10);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop10);
L_env_loop_exit10: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop10:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit10);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop10);
L_params_loop_exit10: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body10));
MOV(R0,R10);
JUMP(L_closure_end10);
L_closure_body10:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop11:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit11);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop11);
L_env_loop_exit11: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop11:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit11);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop11);
L_params_loop_exit11: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body11));
MOV(R0,R10);
JUMP(L_closure_end11);
L_closure_body11:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy1:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit1);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy1);
L_opt_copy_exit1:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy1:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit1);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy1);
L_opt_2copy_exit1:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1852));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy12:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit12);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy12);
L_tc_copy_exit12:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end11:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end10:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1422), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop4:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit4);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop4);
L_env_loop_exit4: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop4:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit4);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop4);
L_params_loop_exit4: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body4));
MOV(R0,R10);
JUMP(L_closure_end4);
L_closure_body4:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop5:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit5);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop5);
L_env_loop_exit5: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop5:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit5);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop5);
L_params_loop_exit5: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body5));
MOV(R0,R10);
JUMP(L_closure_end5);
L_closure_body5:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(4));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2127));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else1);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2127));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit1);
L_if3_else1:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit1:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else12);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(5));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop6:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit6);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop6);
L_env_loop_exit6: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<4; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop6:
CMP(R5,IMM(6));
JUMP_GE(L_params_loop_exit6);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop6);
L_params_loop_exit6: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body6));
MOV(R0,R10);
JUMP(L_closure_end6);
L_closure_body6:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(3)));
MOV(R0,R3);

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop7:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit7);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop7);
L_env_loop_exit7: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop7:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit7);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop7);
L_params_loop_exit7: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body7));
MOV(R0,R10);
JUMP(L_closure_end7);
L_closure_body7:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1452));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(2)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy3:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit3);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy3);
L_tc_copy_exit3:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end7:

PUSH(R0);
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2002));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(4));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(5));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy4:
CMP(R4, IMM(7));
JUMP_EQ(L_tc_copy_exit4);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy4);
L_tc_copy_exit4:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end6:

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2007));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(4));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(5));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy5:
CMP(R4, IMM(7));
JUMP_EQ(L_tc_copy_exit5);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy5);
L_tc_copy_exit5:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit12);
L_if3_else12:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2107));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else4);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2107));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else3);
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2032));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2032));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2067));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else2);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(5));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1502));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1502));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(4));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit2);
L_if3_else2:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit2:

JUMP(L_if3_exit3);
L_if3_else3:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit3:

JUMP(L_if3_exit4);
L_if3_else4:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit4:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else11);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2107));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else7);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2107));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else6);
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2032));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2032));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2067));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else5);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(5));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1502));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1502));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(4));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(5));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy6:
CMP(R4, IMM(7));
JUMP_EQ(L_tc_copy_exit6);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy6);
L_tc_copy_exit6:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit5);
L_if3_else5:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit5:

JUMP(L_if3_exit6);
L_if3_else6:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit6:

JUMP(L_if3_exit7);
L_if3_else7:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit7:

JUMP(L_if3_exit11);
L_if3_else11:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2102));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else10);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in pvar */
MOV(R0, FPARG(2));
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop8:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit8);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop8);
L_env_loop_exit8: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<4; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop8:
CMP(R5,IMM(6));
JUMP_GE(L_params_loop_exit8);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop8);
L_params_loop_exit8: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body8));
MOV(R0,R10);
JUMP(L_closure_end8);
L_closure_body8:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* in pvar */
MOV(R0, FPARG(2));

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else8);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(2)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy7:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit7);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy7);
L_tc_copy_exit7:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit8);
L_if3_else8:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push number of args. */
PUSH(IMM(0));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(3)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(1));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy8:
CMP(R4, IMM(3));
JUMP_EQ(L_tc_copy_exit8);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy8);
L_tc_copy_exit8:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit8:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end8:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy9:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit9);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy9);
L_tc_copy_exit9:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit10);
L_if3_else10:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1492));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else9);
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(4));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy10:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit10);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy10);
L_tc_copy_exit10:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit9);
L_if3_else9:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push number of args. */
PUSH(IMM(0));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(5));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(1));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy11:
CMP(R4, IMM(3));
JUMP_EQ(L_tc_copy_exit11);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy11);
L_tc_copy_exit11:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit9:

L_if3_exit10:

L_if3_exit11:

L_if3_exit12:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end5:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end4:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop1:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit1);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop1);
L_env_loop_exit1: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop1:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit1);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop1);
L_params_loop_exit1: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body1));
MOV(R0,R10);
JUMP(L_closure_end1);
L_closure_body1:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop2:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit2);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop2);
L_env_loop_exit2: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop2:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit2);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop2);
L_params_loop_exit2: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body2));
MOV(R0,R10);
JUMP(L_closure_end2);
L_closure_body2:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(4));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(5));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop3:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit3);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop3);
L_env_loop_exit3: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<4; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop3:
CMP(R5,IMM(6));
JUMP_GE(L_params_loop_exit3);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop3);
L_params_loop_exit3: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body3));
MOV(R0,R10);
JUMP(L_closure_end3);
L_closure_body3:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(2)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1987));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy1:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit1);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy1);
L_tc_copy_exit1:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end3:

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(4));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(5));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy2:
CMP(R4, IMM(7));
JUMP_EQ(L_tc_copy_exit2);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy2);
L_tc_copy_exit2:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end2:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end1:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1947));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1417), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);

POP(FP);
DROP(IMM(3));
STOP_MACHINE;
HALT;
}
