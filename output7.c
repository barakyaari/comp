#include <stdio.h>
#include <stdlib.h>
#include "arch/cisc.h"
int main() {
#define SOB_TRUE 5
#define SOB_FALSE 3
#define SOB_NIL 2
#define SOB_VOID 1
#define LOC_ENV 0
#define LOC_NUM_ARGS 1
#define SYM_TAB_START 1406 
START_MACHINE;
JUMP(LETS_START);
#include "arch/char.lib"
#include "arch/io.lib"
#include "arch/scheme.lib"
#include "arch/math.lib"
#include "arch/string.lib"
#include "arch/system.lib"
#include "arch/project_proc.lib"
ERROR:
HALT;
LETS_START:
PUSH(0);
PUSH(0);
PUSH(0);
PUSH(FP);
MOV(FP, SP);
MOV(IND(0), IMM(2197));
MOV(IND(IMM(1)), IMM(937610));
MOV(IND(IMM(2)), IMM(722689));
MOV(IND(IMM(3)), IMM(741553));
MOV(IND(IMM(4)), IMM(0));
MOV(IND(IMM(5)), IMM(741553));
MOV(IND(IMM(6)), IMM(1));
MOV(IND(IMM(10)), IMM(799345));
MOV(IND(IMM(11)), IMM(3));
MOV(IND(IMM(12)), IMM(109));
MOV(IND(IMM(13)), IMM(105));
MOV(IND(IMM(14)), IMM(110));
MOV(IND(IMM(15)), IMM(799345));
MOV(IND(IMM(16)), IMM(3));
MOV(IND(IMM(17)), IMM(109));
MOV(IND(IMM(18)), IMM(97));
MOV(IND(IMM(19)), IMM(120));
MOV(IND(IMM(20)), IMM(799345));
MOV(IND(IMM(21)), IMM(9));
MOV(IND(IMM(22)), IMM(108));
MOV(IND(IMM(23)), IMM(105));
MOV(IND(IMM(24)), IMM(115));
MOV(IND(IMM(25)), IMM(116));
MOV(IND(IMM(26)), IMM(45));
MOV(IND(IMM(27)), IMM(115));
MOV(IND(IMM(28)), IMM(101));
MOV(IND(IMM(29)), IMM(116));
MOV(IND(IMM(30)), IMM(33));
MOV(IND(IMM(31)), IMM(799345));
MOV(IND(IMM(32)), IMM(14));
MOV(IND(IMM(33)), IMM(115));
MOV(IND(IMM(34)), IMM(116));
MOV(IND(IMM(35)), IMM(114));
MOV(IND(IMM(36)), IMM(105));
MOV(IND(IMM(37)), IMM(110));
MOV(IND(IMM(38)), IMM(103));
MOV(IND(IMM(39)), IMM(45));
MOV(IND(IMM(40)), IMM(114));
MOV(IND(IMM(41)), IMM(101));
MOV(IND(IMM(42)), IMM(118));
MOV(IND(IMM(43)), IMM(101));
MOV(IND(IMM(44)), IMM(114));
MOV(IND(IMM(45)), IMM(115));
MOV(IND(IMM(46)), IMM(101));
MOV(IND(IMM(47)), IMM(799345));
MOV(IND(IMM(48)), IMM(7));
MOV(IND(IMM(49)), IMM(114));
MOV(IND(IMM(50)), IMM(101));
MOV(IND(IMM(51)), IMM(118));
MOV(IND(IMM(52)), IMM(101));
MOV(IND(IMM(53)), IMM(114));
MOV(IND(IMM(54)), IMM(115));
MOV(IND(IMM(55)), IMM(101));
MOV(IND(IMM(56)), IMM(799345));
MOV(IND(IMM(57)), IMM(13));
MOV(IND(IMM(58)), IMM(118));
MOV(IND(IMM(59)), IMM(101));
MOV(IND(IMM(60)), IMM(99));
MOV(IND(IMM(61)), IMM(116));
MOV(IND(IMM(62)), IMM(111));
MOV(IND(IMM(63)), IMM(114));
MOV(IND(IMM(64)), IMM(45));
MOV(IND(IMM(65)), IMM(97));
MOV(IND(IMM(66)), IMM(112));
MOV(IND(IMM(67)), IMM(112));
MOV(IND(IMM(68)), IMM(101));
MOV(IND(IMM(69)), IMM(110));
MOV(IND(IMM(70)), IMM(100));
MOV(IND(IMM(71)), IMM(799345));
MOV(IND(IMM(72)), IMM(6));
MOV(IND(IMM(73)), IMM(97));
MOV(IND(IMM(74)), IMM(112));
MOV(IND(IMM(75)), IMM(112));
MOV(IND(IMM(76)), IMM(101));
MOV(IND(IMM(77)), IMM(110));
MOV(IND(IMM(78)), IMM(100));
MOV(IND(IMM(79)), IMM(799345));
MOV(IND(IMM(80)), IMM(13));
MOV(IND(IMM(81)), IMM(115));
MOV(IND(IMM(82)), IMM(116));
MOV(IND(IMM(83)), IMM(114));
MOV(IND(IMM(84)), IMM(105));
MOV(IND(IMM(85)), IMM(110));
MOV(IND(IMM(86)), IMM(103));
MOV(IND(IMM(87)), IMM(45));
MOV(IND(IMM(88)), IMM(97));
MOV(IND(IMM(89)), IMM(112));
MOV(IND(IMM(90)), IMM(112));
MOV(IND(IMM(91)), IMM(101));
MOV(IND(IMM(92)), IMM(110));
MOV(IND(IMM(93)), IMM(100));
MOV(IND(IMM(94)), IMM(799345));
MOV(IND(IMM(95)), IMM(5));
MOV(IND(IMM(96)), IMM(118));
MOV(IND(IMM(97)), IMM(111));
MOV(IND(IMM(98)), IMM(105));
MOV(IND(IMM(99)), IMM(100));
MOV(IND(IMM(100)), IMM(63));
MOV(IND(IMM(101)), IMM(799345));
MOV(IND(IMM(102)), IMM(4));
MOV(IND(IMM(103)), IMM(118));
MOV(IND(IMM(104)), IMM(111));
MOV(IND(IMM(105)), IMM(105));
MOV(IND(IMM(106)), IMM(100));
MOV(IND(IMM(107)), IMM(799345));
MOV(IND(IMM(108)), IMM(4));
MOV(IND(IMM(109)), IMM(97));
MOV(IND(IMM(110)), IMM(115));
MOV(IND(IMM(111)), IMM(115));
MOV(IND(IMM(112)), IMM(113));
MOV(IND(IMM(113)), IMM(799345));
MOV(IND(IMM(114)), IMM(5));
MOV(IND(IMM(115)), IMM(97));
MOV(IND(IMM(116)), IMM(115));
MOV(IND(IMM(117)), IMM(115));
MOV(IND(IMM(118)), IMM(111));
MOV(IND(IMM(119)), IMM(99));
MOV(IND(IMM(120)), IMM(799345));
MOV(IND(IMM(121)), IMM(10));
MOV(IND(IMM(122)), IMM(94));
MOV(IND(IMM(123)), IMM(97));
MOV(IND(IMM(124)), IMM(115));
MOV(IND(IMM(125)), IMM(115));
MOV(IND(IMM(126)), IMM(111));
MOV(IND(IMM(127)), IMM(99));
MOV(IND(IMM(128)), IMM(105));
MOV(IND(IMM(129)), IMM(97));
MOV(IND(IMM(130)), IMM(116));
MOV(IND(IMM(131)), IMM(101));
MOV(IND(IMM(132)), IMM(799345));
MOV(IND(IMM(133)), IMM(9));
MOV(IND(IMM(134)), IMM(98));
MOV(IND(IMM(135)), IMM(111));
MOV(IND(IMM(136)), IMM(111));
MOV(IND(IMM(137)), IMM(108));
MOV(IND(IMM(138)), IMM(101));
MOV(IND(IMM(139)), IMM(97));
MOV(IND(IMM(140)), IMM(110));
MOV(IND(IMM(141)), IMM(61));
MOV(IND(IMM(142)), IMM(63));
MOV(IND(IMM(143)), IMM(799345));
MOV(IND(IMM(144)), IMM(6));
MOV(IND(IMM(145)), IMM(101));
MOV(IND(IMM(146)), IMM(113));
MOV(IND(IMM(147)), IMM(117));
MOV(IND(IMM(148)), IMM(97));
MOV(IND(IMM(149)), IMM(108));
MOV(IND(IMM(150)), IMM(63));
MOV(IND(IMM(151)), IMM(799345));
MOV(IND(IMM(152)), IMM(6));
MOV(IND(IMM(153)), IMM(109));
MOV(IND(IMM(154)), IMM(101));
MOV(IND(IMM(155)), IMM(109));
MOV(IND(IMM(156)), IMM(98));
MOV(IND(IMM(157)), IMM(101));
MOV(IND(IMM(158)), IMM(114));
MOV(IND(IMM(159)), IMM(799345));
MOV(IND(IMM(160)), IMM(12));
MOV(IND(IMM(161)), IMM(118));
MOV(IND(IMM(162)), IMM(101));
MOV(IND(IMM(163)), IMM(99));
MOV(IND(IMM(164)), IMM(116));
MOV(IND(IMM(165)), IMM(111));
MOV(IND(IMM(166)), IMM(114));
MOV(IND(IMM(167)), IMM(45));
MOV(IND(IMM(168)), IMM(62));
MOV(IND(IMM(169)), IMM(108));
MOV(IND(IMM(170)), IMM(105));
MOV(IND(IMM(171)), IMM(115));
MOV(IND(IMM(172)), IMM(116));
MOV(IND(IMM(173)), IMM(799345));
MOV(IND(IMM(174)), IMM(9));
MOV(IND(IMM(175)), IMM(115));
MOV(IND(IMM(176)), IMM(116));
MOV(IND(IMM(177)), IMM(114));
MOV(IND(IMM(178)), IMM(105));
MOV(IND(IMM(179)), IMM(110));
MOV(IND(IMM(180)), IMM(103));
MOV(IND(IMM(181)), IMM(62));
MOV(IND(IMM(182)), IMM(61));
MOV(IND(IMM(183)), IMM(63));
MOV(IND(IMM(184)), IMM(799345));
MOV(IND(IMM(185)), IMM(9));
MOV(IND(IMM(186)), IMM(115));
MOV(IND(IMM(187)), IMM(116));
MOV(IND(IMM(188)), IMM(114));
MOV(IND(IMM(189)), IMM(105));
MOV(IND(IMM(190)), IMM(110));
MOV(IND(IMM(191)), IMM(103));
MOV(IND(IMM(192)), IMM(60));
MOV(IND(IMM(193)), IMM(61));
MOV(IND(IMM(194)), IMM(63));
MOV(IND(IMM(195)), IMM(799345));
MOV(IND(IMM(196)), IMM(8));
MOV(IND(IMM(197)), IMM(115));
MOV(IND(IMM(198)), IMM(116));
MOV(IND(IMM(199)), IMM(114));
MOV(IND(IMM(200)), IMM(105));
MOV(IND(IMM(201)), IMM(110));
MOV(IND(IMM(202)), IMM(103));
MOV(IND(IMM(203)), IMM(62));
MOV(IND(IMM(204)), IMM(63));
MOV(IND(IMM(205)), IMM(799345));
MOV(IND(IMM(206)), IMM(8));
MOV(IND(IMM(207)), IMM(115));
MOV(IND(IMM(208)), IMM(116));
MOV(IND(IMM(209)), IMM(114));
MOV(IND(IMM(210)), IMM(105));
MOV(IND(IMM(211)), IMM(110));
MOV(IND(IMM(212)), IMM(103));
MOV(IND(IMM(213)), IMM(60));
MOV(IND(IMM(214)), IMM(63));
MOV(IND(IMM(215)), IMM(799345));
MOV(IND(IMM(216)), IMM(8));
MOV(IND(IMM(217)), IMM(115));
MOV(IND(IMM(218)), IMM(116));
MOV(IND(IMM(219)), IMM(114));
MOV(IND(IMM(220)), IMM(105));
MOV(IND(IMM(221)), IMM(110));
MOV(IND(IMM(222)), IMM(103));
MOV(IND(IMM(223)), IMM(61));
MOV(IND(IMM(224)), IMM(63));
MOV(IND(IMM(225)), IMM(799345));
MOV(IND(IMM(226)), IMM(16));
MOV(IND(IMM(227)), IMM(98));
MOV(IND(IMM(228)), IMM(105));
MOV(IND(IMM(229)), IMM(110));
MOV(IND(IMM(230)), IMM(97));
MOV(IND(IMM(231)), IMM(114));
MOV(IND(IMM(232)), IMM(121));
MOV(IND(IMM(233)), IMM(45));
MOV(IND(IMM(234)), IMM(115));
MOV(IND(IMM(235)), IMM(116));
MOV(IND(IMM(236)), IMM(114));
MOV(IND(IMM(237)), IMM(105));
MOV(IND(IMM(238)), IMM(110));
MOV(IND(IMM(239)), IMM(103));
MOV(IND(IMM(240)), IMM(62));
MOV(IND(IMM(241)), IMM(61));
MOV(IND(IMM(242)), IMM(63));
MOV(IND(IMM(243)), IMM(799345));
MOV(IND(IMM(244)), IMM(16));
MOV(IND(IMM(245)), IMM(98));
MOV(IND(IMM(246)), IMM(105));
MOV(IND(IMM(247)), IMM(110));
MOV(IND(IMM(248)), IMM(97));
MOV(IND(IMM(249)), IMM(114));
MOV(IND(IMM(250)), IMM(121));
MOV(IND(IMM(251)), IMM(45));
MOV(IND(IMM(252)), IMM(115));
MOV(IND(IMM(253)), IMM(116));
MOV(IND(IMM(254)), IMM(114));
MOV(IND(IMM(255)), IMM(105));
MOV(IND(IMM(256)), IMM(110));
MOV(IND(IMM(257)), IMM(103));
MOV(IND(IMM(258)), IMM(60));
MOV(IND(IMM(259)), IMM(61));
MOV(IND(IMM(260)), IMM(63));
MOV(IND(IMM(261)), IMM(799345));
MOV(IND(IMM(262)), IMM(15));
MOV(IND(IMM(263)), IMM(98));
MOV(IND(IMM(264)), IMM(105));
MOV(IND(IMM(265)), IMM(110));
MOV(IND(IMM(266)), IMM(97));
MOV(IND(IMM(267)), IMM(114));
MOV(IND(IMM(268)), IMM(121));
MOV(IND(IMM(269)), IMM(45));
MOV(IND(IMM(270)), IMM(115));
MOV(IND(IMM(271)), IMM(116));
MOV(IND(IMM(272)), IMM(114));
MOV(IND(IMM(273)), IMM(105));
MOV(IND(IMM(274)), IMM(110));
MOV(IND(IMM(275)), IMM(103));
MOV(IND(IMM(276)), IMM(62));
MOV(IND(IMM(277)), IMM(63));
MOV(IND(IMM(278)), IMM(799345));
MOV(IND(IMM(279)), IMM(15));
MOV(IND(IMM(280)), IMM(98));
MOV(IND(IMM(281)), IMM(105));
MOV(IND(IMM(282)), IMM(110));
MOV(IND(IMM(283)), IMM(97));
MOV(IND(IMM(284)), IMM(114));
MOV(IND(IMM(285)), IMM(121));
MOV(IND(IMM(286)), IMM(45));
MOV(IND(IMM(287)), IMM(115));
MOV(IND(IMM(288)), IMM(116));
MOV(IND(IMM(289)), IMM(114));
MOV(IND(IMM(290)), IMM(105));
MOV(IND(IMM(291)), IMM(110));
MOV(IND(IMM(292)), IMM(103));
MOV(IND(IMM(293)), IMM(60));
MOV(IND(IMM(294)), IMM(63));
MOV(IND(IMM(295)), IMM(799345));
MOV(IND(IMM(296)), IMM(15));
MOV(IND(IMM(297)), IMM(98));
MOV(IND(IMM(298)), IMM(105));
MOV(IND(IMM(299)), IMM(110));
MOV(IND(IMM(300)), IMM(97));
MOV(IND(IMM(301)), IMM(114));
MOV(IND(IMM(302)), IMM(121));
MOV(IND(IMM(303)), IMM(45));
MOV(IND(IMM(304)), IMM(115));
MOV(IND(IMM(305)), IMM(116));
MOV(IND(IMM(306)), IMM(114));
MOV(IND(IMM(307)), IMM(105));
MOV(IND(IMM(308)), IMM(110));
MOV(IND(IMM(309)), IMM(103));
MOV(IND(IMM(310)), IMM(61));
MOV(IND(IMM(311)), IMM(63));
MOV(IND(IMM(312)), IMM(799345));
MOV(IND(IMM(313)), IMM(12));
MOV(IND(IMM(314)), IMM(108));
MOV(IND(IMM(315)), IMM(105));
MOV(IND(IMM(316)), IMM(115));
MOV(IND(IMM(317)), IMM(116));
MOV(IND(IMM(318)), IMM(45));
MOV(IND(IMM(319)), IMM(62));
MOV(IND(IMM(320)), IMM(118));
MOV(IND(IMM(321)), IMM(101));
MOV(IND(IMM(322)), IMM(99));
MOV(IND(IMM(323)), IMM(116));
MOV(IND(IMM(324)), IMM(111));
MOV(IND(IMM(325)), IMM(114));
MOV(IND(IMM(326)), IMM(799345));
MOV(IND(IMM(327)), IMM(9));
MOV(IND(IMM(328)), IMM(112));
MOV(IND(IMM(329)), IMM(111));
MOV(IND(IMM(330)), IMM(115));
MOV(IND(IMM(331)), IMM(105));
MOV(IND(IMM(332)), IMM(116));
MOV(IND(IMM(333)), IMM(105));
MOV(IND(IMM(334)), IMM(118));
MOV(IND(IMM(335)), IMM(101));
MOV(IND(IMM(336)), IMM(63));
MOV(IND(IMM(337)), IMM(799345));
MOV(IND(IMM(338)), IMM(9));
MOV(IND(IMM(339)), IMM(110));
MOV(IND(IMM(340)), IMM(101));
MOV(IND(IMM(341)), IMM(103));
MOV(IND(IMM(342)), IMM(97));
MOV(IND(IMM(343)), IMM(116));
MOV(IND(IMM(344)), IMM(105));
MOV(IND(IMM(345)), IMM(118));
MOV(IND(IMM(346)), IMM(101));
MOV(IND(IMM(347)), IMM(63));
MOV(IND(IMM(348)), IMM(799345));
MOV(IND(IMM(349)), IMM(7));
MOV(IND(IMM(350)), IMM(109));
MOV(IND(IMM(351)), IMM(101));
MOV(IND(IMM(352)), IMM(109));
MOV(IND(IMM(353)), IMM(98));
MOV(IND(IMM(354)), IMM(101));
MOV(IND(IMM(355)), IMM(114));
MOV(IND(IMM(356)), IMM(63));
MOV(IND(IMM(357)), IMM(799345));
MOV(IND(IMM(358)), IMM(5));
MOV(IND(IMM(359)), IMM(108));
MOV(IND(IMM(360)), IMM(105));
MOV(IND(IMM(361)), IMM(115));
MOV(IND(IMM(362)), IMM(116));
MOV(IND(IMM(363)), IMM(63));
MOV(IND(IMM(364)), IMM(799345));
MOV(IND(IMM(365)), IMM(8));
MOV(IND(IMM(366)), IMM(108));
MOV(IND(IMM(367)), IMM(105));
MOV(IND(IMM(368)), IMM(115));
MOV(IND(IMM(369)), IMM(116));
MOV(IND(IMM(370)), IMM(45));
MOV(IND(IMM(371)), IMM(114));
MOV(IND(IMM(372)), IMM(101));
MOV(IND(IMM(373)), IMM(102));
MOV(IND(IMM(374)), IMM(799345));
MOV(IND(IMM(375)), IMM(4));
MOV(IND(IMM(376)), IMM(111));
MOV(IND(IMM(377)), IMM(100));
MOV(IND(IMM(378)), IMM(100));
MOV(IND(IMM(379)), IMM(63));
MOV(IND(IMM(380)), IMM(799345));
MOV(IND(IMM(381)), IMM(9));
MOV(IND(IMM(382)), IMM(114));
MOV(IND(IMM(383)), IMM(101));
MOV(IND(IMM(384)), IMM(109));
MOV(IND(IMM(385)), IMM(97));
MOV(IND(IMM(386)), IMM(105));
MOV(IND(IMM(387)), IMM(110));
MOV(IND(IMM(388)), IMM(100));
MOV(IND(IMM(389)), IMM(101));
MOV(IND(IMM(390)), IMM(114));
MOV(IND(IMM(391)), IMM(799345));
MOV(IND(IMM(392)), IMM(5));
MOV(IND(IMM(393)), IMM(101));
MOV(IND(IMM(394)), IMM(118));
MOV(IND(IMM(395)), IMM(101));
MOV(IND(IMM(396)), IMM(110));
MOV(IND(IMM(397)), IMM(63));
MOV(IND(IMM(398)), IMM(799345));
MOV(IND(IMM(399)), IMM(15));
MOV(IND(IMM(400)), IMM(115));
MOV(IND(IMM(401)), IMM(116));
MOV(IND(IMM(402)), IMM(114));
MOV(IND(IMM(403)), IMM(105));
MOV(IND(IMM(404)), IMM(110));
MOV(IND(IMM(405)), IMM(103));
MOV(IND(IMM(406)), IMM(45));
MOV(IND(IMM(407)), IMM(100));
MOV(IND(IMM(408)), IMM(111));
MOV(IND(IMM(409)), IMM(119));
MOV(IND(IMM(410)), IMM(110));
MOV(IND(IMM(411)), IMM(99));
MOV(IND(IMM(412)), IMM(97));
MOV(IND(IMM(413)), IMM(115));
MOV(IND(IMM(414)), IMM(101));
MOV(IND(IMM(415)), IMM(799345));
MOV(IND(IMM(416)), IMM(12));
MOV(IND(IMM(417)), IMM(115));
MOV(IND(IMM(418)), IMM(116));
MOV(IND(IMM(419)), IMM(114));
MOV(IND(IMM(420)), IMM(105));
MOV(IND(IMM(421)), IMM(110));
MOV(IND(IMM(422)), IMM(103));
MOV(IND(IMM(423)), IMM(45));
MOV(IND(IMM(424)), IMM(62));
MOV(IND(IMM(425)), IMM(108));
MOV(IND(IMM(426)), IMM(105));
MOV(IND(IMM(427)), IMM(115));
MOV(IND(IMM(428)), IMM(116));
MOV(IND(IMM(429)), IMM(799345));
MOV(IND(IMM(430)), IMM(12));
MOV(IND(IMM(431)), IMM(108));
MOV(IND(IMM(432)), IMM(105));
MOV(IND(IMM(433)), IMM(115));
MOV(IND(IMM(434)), IMM(116));
MOV(IND(IMM(435)), IMM(45));
MOV(IND(IMM(436)), IMM(62));
MOV(IND(IMM(437)), IMM(115));
MOV(IND(IMM(438)), IMM(116));
MOV(IND(IMM(439)), IMM(114));
MOV(IND(IMM(440)), IMM(105));
MOV(IND(IMM(441)), IMM(110));
MOV(IND(IMM(442)), IMM(103));
MOV(IND(IMM(443)), IMM(799345));
MOV(IND(IMM(444)), IMM(13));
MOV(IND(IMM(445)), IMM(115));
MOV(IND(IMM(446)), IMM(116));
MOV(IND(IMM(447)), IMM(114));
MOV(IND(IMM(448)), IMM(105));
MOV(IND(IMM(449)), IMM(110));
MOV(IND(IMM(450)), IMM(103));
MOV(IND(IMM(451)), IMM(45));
MOV(IND(IMM(452)), IMM(117));
MOV(IND(IMM(453)), IMM(112));
MOV(IND(IMM(454)), IMM(99));
MOV(IND(IMM(455)), IMM(97));
MOV(IND(IMM(456)), IMM(115));
MOV(IND(IMM(457)), IMM(101));
MOV(IND(IMM(458)), IMM(799345));
MOV(IND(IMM(459)), IMM(10));
MOV(IND(IMM(460)), IMM(99));
MOV(IND(IMM(461)), IMM(104));
MOV(IND(IMM(462)), IMM(97));
MOV(IND(IMM(463)), IMM(114));
MOV(IND(IMM(464)), IMM(45));
MOV(IND(IMM(465)), IMM(99));
MOV(IND(IMM(466)), IMM(105));
MOV(IND(IMM(467)), IMM(62));
MOV(IND(IMM(468)), IMM(61));
MOV(IND(IMM(469)), IMM(63));
MOV(IND(IMM(470)), IMM(799345));
MOV(IND(IMM(471)), IMM(9));
MOV(IND(IMM(472)), IMM(99));
MOV(IND(IMM(473)), IMM(104));
MOV(IND(IMM(474)), IMM(97));
MOV(IND(IMM(475)), IMM(114));
MOV(IND(IMM(476)), IMM(45));
MOV(IND(IMM(477)), IMM(99));
MOV(IND(IMM(478)), IMM(105));
MOV(IND(IMM(479)), IMM(62));
MOV(IND(IMM(480)), IMM(63));
MOV(IND(IMM(481)), IMM(799345));
MOV(IND(IMM(482)), IMM(9));
MOV(IND(IMM(483)), IMM(99));
MOV(IND(IMM(484)), IMM(104));
MOV(IND(IMM(485)), IMM(97));
MOV(IND(IMM(486)), IMM(114));
MOV(IND(IMM(487)), IMM(45));
MOV(IND(IMM(488)), IMM(99));
MOV(IND(IMM(489)), IMM(105));
MOV(IND(IMM(490)), IMM(61));
MOV(IND(IMM(491)), IMM(63));
MOV(IND(IMM(492)), IMM(799345));
MOV(IND(IMM(493)), IMM(9));
MOV(IND(IMM(494)), IMM(99));
MOV(IND(IMM(495)), IMM(104));
MOV(IND(IMM(496)), IMM(97));
MOV(IND(IMM(497)), IMM(114));
MOV(IND(IMM(498)), IMM(45));
MOV(IND(IMM(499)), IMM(99));
MOV(IND(IMM(500)), IMM(105));
MOV(IND(IMM(501)), IMM(60));
MOV(IND(IMM(502)), IMM(63));
MOV(IND(IMM(503)), IMM(799345));
MOV(IND(IMM(504)), IMM(10));
MOV(IND(IMM(505)), IMM(99));
MOV(IND(IMM(506)), IMM(104));
MOV(IND(IMM(507)), IMM(97));
MOV(IND(IMM(508)), IMM(114));
MOV(IND(IMM(509)), IMM(45));
MOV(IND(IMM(510)), IMM(99));
MOV(IND(IMM(511)), IMM(105));
MOV(IND(IMM(512)), IMM(60));
MOV(IND(IMM(513)), IMM(61));
MOV(IND(IMM(514)), IMM(63));
MOV(IND(IMM(515)), IMM(799345));
MOV(IND(IMM(516)), IMM(13));
MOV(IND(IMM(517)), IMM(99));
MOV(IND(IMM(518)), IMM(104));
MOV(IND(IMM(519)), IMM(97));
MOV(IND(IMM(520)), IMM(114));
MOV(IND(IMM(521)), IMM(45));
MOV(IND(IMM(522)), IMM(100));
MOV(IND(IMM(523)), IMM(111));
MOV(IND(IMM(524)), IMM(119));
MOV(IND(IMM(525)), IMM(110));
MOV(IND(IMM(526)), IMM(99));
MOV(IND(IMM(527)), IMM(97));
MOV(IND(IMM(528)), IMM(115));
MOV(IND(IMM(529)), IMM(101));
MOV(IND(IMM(530)), IMM(799345));
MOV(IND(IMM(531)), IMM(11));
MOV(IND(IMM(532)), IMM(99));
MOV(IND(IMM(533)), IMM(104));
MOV(IND(IMM(534)), IMM(97));
MOV(IND(IMM(535)), IMM(114));
MOV(IND(IMM(536)), IMM(45));
MOV(IND(IMM(537)), IMM(117));
MOV(IND(IMM(538)), IMM(112));
MOV(IND(IMM(539)), IMM(99));
MOV(IND(IMM(540)), IMM(97));
MOV(IND(IMM(541)), IMM(115));
MOV(IND(IMM(542)), IMM(101));
MOV(IND(IMM(543)), IMM(799345));
MOV(IND(IMM(544)), IMM(15));
MOV(IND(IMM(545)), IMM(99));
MOV(IND(IMM(546)), IMM(104));
MOV(IND(IMM(547)), IMM(97));
MOV(IND(IMM(548)), IMM(114));
MOV(IND(IMM(549)), IMM(45));
MOV(IND(IMM(550)), IMM(108));
MOV(IND(IMM(551)), IMM(111));
MOV(IND(IMM(552)), IMM(119));
MOV(IND(IMM(553)), IMM(101));
MOV(IND(IMM(554)), IMM(114));
MOV(IND(IMM(555)), IMM(99));
MOV(IND(IMM(556)), IMM(97));
MOV(IND(IMM(557)), IMM(115));
MOV(IND(IMM(558)), IMM(101));
MOV(IND(IMM(559)), IMM(63));
MOV(IND(IMM(560)), IMM(799345));
MOV(IND(IMM(561)), IMM(15));
MOV(IND(IMM(562)), IMM(99));
MOV(IND(IMM(563)), IMM(104));
MOV(IND(IMM(564)), IMM(97));
MOV(IND(IMM(565)), IMM(114));
MOV(IND(IMM(566)), IMM(45));
MOV(IND(IMM(567)), IMM(117));
MOV(IND(IMM(568)), IMM(112));
MOV(IND(IMM(569)), IMM(112));
MOV(IND(IMM(570)), IMM(101));
MOV(IND(IMM(571)), IMM(114));
MOV(IND(IMM(572)), IMM(99));
MOV(IND(IMM(573)), IMM(97));
MOV(IND(IMM(574)), IMM(115));
MOV(IND(IMM(575)), IMM(101));
MOV(IND(IMM(576)), IMM(63));
MOV(IND(IMM(577)), IMM(799345));
MOV(IND(IMM(578)), IMM(6));
MOV(IND(IMM(579)), IMM(99));
MOV(IND(IMM(580)), IMM(104));
MOV(IND(IMM(581)), IMM(97));
MOV(IND(IMM(582)), IMM(114));
MOV(IND(IMM(583)), IMM(62));
MOV(IND(IMM(584)), IMM(63));
MOV(IND(IMM(585)), IMM(799345));
MOV(IND(IMM(586)), IMM(7));
MOV(IND(IMM(587)), IMM(99));
MOV(IND(IMM(588)), IMM(104));
MOV(IND(IMM(589)), IMM(97));
MOV(IND(IMM(590)), IMM(114));
MOV(IND(IMM(591)), IMM(62));
MOV(IND(IMM(592)), IMM(61));
MOV(IND(IMM(593)), IMM(63));
MOV(IND(IMM(594)), IMM(799345));
MOV(IND(IMM(595)), IMM(6));
MOV(IND(IMM(596)), IMM(99));
MOV(IND(IMM(597)), IMM(104));
MOV(IND(IMM(598)), IMM(97));
MOV(IND(IMM(599)), IMM(114));
MOV(IND(IMM(600)), IMM(60));
MOV(IND(IMM(601)), IMM(63));
MOV(IND(IMM(602)), IMM(799345));
MOV(IND(IMM(603)), IMM(7));
MOV(IND(IMM(604)), IMM(99));
MOV(IND(IMM(605)), IMM(104));
MOV(IND(IMM(606)), IMM(97));
MOV(IND(IMM(607)), IMM(114));
MOV(IND(IMM(608)), IMM(60));
MOV(IND(IMM(609)), IMM(61));
MOV(IND(IMM(610)), IMM(63));
MOV(IND(IMM(611)), IMM(799345));
MOV(IND(IMM(612)), IMM(6));
MOV(IND(IMM(613)), IMM(99));
MOV(IND(IMM(614)), IMM(104));
MOV(IND(IMM(615)), IMM(97));
MOV(IND(IMM(616)), IMM(114));
MOV(IND(IMM(617)), IMM(61));
MOV(IND(IMM(618)), IMM(63));
MOV(IND(IMM(619)), IMM(799345));
MOV(IND(IMM(620)), IMM(8));
MOV(IND(IMM(621)), IMM(94));
MOV(IND(IMM(622)), IMM(99));
MOV(IND(IMM(623)), IMM(104));
MOV(IND(IMM(624)), IMM(97));
MOV(IND(IMM(625)), IMM(114));
MOV(IND(IMM(626)), IMM(45));
MOV(IND(IMM(627)), IMM(111));
MOV(IND(IMM(628)), IMM(112));
MOV(IND(IMM(629)), IMM(799345));
MOV(IND(IMM(630)), IMM(26));
MOV(IND(IMM(631)), IMM(94));
MOV(IND(IMM(632)), IMM(118));
MOV(IND(IMM(633)), IMM(97));
MOV(IND(IMM(634)), IMM(114));
MOV(IND(IMM(635)), IMM(105));
MOV(IND(IMM(636)), IMM(97));
MOV(IND(IMM(637)), IMM(100));
MOV(IND(IMM(638)), IMM(105));
MOV(IND(IMM(639)), IMM(99));
MOV(IND(IMM(640)), IMM(45));
MOV(IND(IMM(641)), IMM(108));
MOV(IND(IMM(642)), IMM(101));
MOV(IND(IMM(643)), IMM(102));
MOV(IND(IMM(644)), IMM(116));
MOV(IND(IMM(645)), IMM(45));
MOV(IND(IMM(646)), IMM(102));
MOV(IND(IMM(647)), IMM(114));
MOV(IND(IMM(648)), IMM(111));
MOV(IND(IMM(649)), IMM(109));
MOV(IND(IMM(650)), IMM(45));
MOV(IND(IMM(651)), IMM(98));
MOV(IND(IMM(652)), IMM(105));
MOV(IND(IMM(653)), IMM(110));
MOV(IND(IMM(654)), IMM(97));
MOV(IND(IMM(655)), IMM(114));
MOV(IND(IMM(656)), IMM(121));
MOV(IND(IMM(657)), IMM(799345));
MOV(IND(IMM(658)), IMM(27));
MOV(IND(IMM(659)), IMM(94));
MOV(IND(IMM(660)), IMM(118));
MOV(IND(IMM(661)), IMM(97));
MOV(IND(IMM(662)), IMM(114));
MOV(IND(IMM(663)), IMM(105));
MOV(IND(IMM(664)), IMM(97));
MOV(IND(IMM(665)), IMM(100));
MOV(IND(IMM(666)), IMM(105));
MOV(IND(IMM(667)), IMM(99));
MOV(IND(IMM(668)), IMM(45));
MOV(IND(IMM(669)), IMM(114));
MOV(IND(IMM(670)), IMM(105));
MOV(IND(IMM(671)), IMM(103));
MOV(IND(IMM(672)), IMM(104));
MOV(IND(IMM(673)), IMM(116));
MOV(IND(IMM(674)), IMM(45));
MOV(IND(IMM(675)), IMM(102));
MOV(IND(IMM(676)), IMM(114));
MOV(IND(IMM(677)), IMM(111));
MOV(IND(IMM(678)), IMM(109));
MOV(IND(IMM(679)), IMM(45));
MOV(IND(IMM(680)), IMM(98));
MOV(IND(IMM(681)), IMM(105));
MOV(IND(IMM(682)), IMM(110));
MOV(IND(IMM(683)), IMM(97));
MOV(IND(IMM(684)), IMM(114));
MOV(IND(IMM(685)), IMM(121));
MOV(IND(IMM(686)), IMM(799345));
MOV(IND(IMM(687)), IMM(6));
MOV(IND(IMM(688)), IMM(99));
MOV(IND(IMM(689)), IMM(100));
MOV(IND(IMM(690)), IMM(100));
MOV(IND(IMM(691)), IMM(100));
MOV(IND(IMM(692)), IMM(100));
MOV(IND(IMM(693)), IMM(114));
MOV(IND(IMM(694)), IMM(799345));
MOV(IND(IMM(695)), IMM(6));
MOV(IND(IMM(696)), IMM(99));
MOV(IND(IMM(697)), IMM(100));
MOV(IND(IMM(698)), IMM(100));
MOV(IND(IMM(699)), IMM(100));
MOV(IND(IMM(700)), IMM(97));
MOV(IND(IMM(701)), IMM(114));
MOV(IND(IMM(702)), IMM(799345));
MOV(IND(IMM(703)), IMM(6));
MOV(IND(IMM(704)), IMM(99));
MOV(IND(IMM(705)), IMM(100));
MOV(IND(IMM(706)), IMM(100));
MOV(IND(IMM(707)), IMM(97));
MOV(IND(IMM(708)), IMM(100));
MOV(IND(IMM(709)), IMM(114));
MOV(IND(IMM(710)), IMM(799345));
MOV(IND(IMM(711)), IMM(6));
MOV(IND(IMM(712)), IMM(99));
MOV(IND(IMM(713)), IMM(100));
MOV(IND(IMM(714)), IMM(100));
MOV(IND(IMM(715)), IMM(97));
MOV(IND(IMM(716)), IMM(97));
MOV(IND(IMM(717)), IMM(114));
MOV(IND(IMM(718)), IMM(799345));
MOV(IND(IMM(719)), IMM(6));
MOV(IND(IMM(720)), IMM(99));
MOV(IND(IMM(721)), IMM(100));
MOV(IND(IMM(722)), IMM(97));
MOV(IND(IMM(723)), IMM(100));
MOV(IND(IMM(724)), IMM(100));
MOV(IND(IMM(725)), IMM(114));
MOV(IND(IMM(726)), IMM(799345));
MOV(IND(IMM(727)), IMM(6));
MOV(IND(IMM(728)), IMM(99));
MOV(IND(IMM(729)), IMM(100));
MOV(IND(IMM(730)), IMM(97));
MOV(IND(IMM(731)), IMM(100));
MOV(IND(IMM(732)), IMM(97));
MOV(IND(IMM(733)), IMM(114));
MOV(IND(IMM(734)), IMM(799345));
MOV(IND(IMM(735)), IMM(6));
MOV(IND(IMM(736)), IMM(99));
MOV(IND(IMM(737)), IMM(100));
MOV(IND(IMM(738)), IMM(97));
MOV(IND(IMM(739)), IMM(97));
MOV(IND(IMM(740)), IMM(100));
MOV(IND(IMM(741)), IMM(114));
MOV(IND(IMM(742)), IMM(799345));
MOV(IND(IMM(743)), IMM(6));
MOV(IND(IMM(744)), IMM(99));
MOV(IND(IMM(745)), IMM(100));
MOV(IND(IMM(746)), IMM(97));
MOV(IND(IMM(747)), IMM(97));
MOV(IND(IMM(748)), IMM(97));
MOV(IND(IMM(749)), IMM(114));
MOV(IND(IMM(750)), IMM(799345));
MOV(IND(IMM(751)), IMM(6));
MOV(IND(IMM(752)), IMM(99));
MOV(IND(IMM(753)), IMM(97));
MOV(IND(IMM(754)), IMM(100));
MOV(IND(IMM(755)), IMM(100));
MOV(IND(IMM(756)), IMM(100));
MOV(IND(IMM(757)), IMM(114));
MOV(IND(IMM(758)), IMM(799345));
MOV(IND(IMM(759)), IMM(6));
MOV(IND(IMM(760)), IMM(99));
MOV(IND(IMM(761)), IMM(97));
MOV(IND(IMM(762)), IMM(100));
MOV(IND(IMM(763)), IMM(100));
MOV(IND(IMM(764)), IMM(97));
MOV(IND(IMM(765)), IMM(114));
MOV(IND(IMM(766)), IMM(799345));
MOV(IND(IMM(767)), IMM(6));
MOV(IND(IMM(768)), IMM(99));
MOV(IND(IMM(769)), IMM(97));
MOV(IND(IMM(770)), IMM(100));
MOV(IND(IMM(771)), IMM(97));
MOV(IND(IMM(772)), IMM(100));
MOV(IND(IMM(773)), IMM(114));
MOV(IND(IMM(774)), IMM(799345));
MOV(IND(IMM(775)), IMM(6));
MOV(IND(IMM(776)), IMM(99));
MOV(IND(IMM(777)), IMM(97));
MOV(IND(IMM(778)), IMM(100));
MOV(IND(IMM(779)), IMM(97));
MOV(IND(IMM(780)), IMM(97));
MOV(IND(IMM(781)), IMM(114));
MOV(IND(IMM(782)), IMM(799345));
MOV(IND(IMM(783)), IMM(6));
MOV(IND(IMM(784)), IMM(99));
MOV(IND(IMM(785)), IMM(97));
MOV(IND(IMM(786)), IMM(97));
MOV(IND(IMM(787)), IMM(100));
MOV(IND(IMM(788)), IMM(100));
MOV(IND(IMM(789)), IMM(114));
MOV(IND(IMM(790)), IMM(799345));
MOV(IND(IMM(791)), IMM(6));
MOV(IND(IMM(792)), IMM(99));
MOV(IND(IMM(793)), IMM(97));
MOV(IND(IMM(794)), IMM(97));
MOV(IND(IMM(795)), IMM(100));
MOV(IND(IMM(796)), IMM(97));
MOV(IND(IMM(797)), IMM(114));
MOV(IND(IMM(798)), IMM(799345));
MOV(IND(IMM(799)), IMM(6));
MOV(IND(IMM(800)), IMM(99));
MOV(IND(IMM(801)), IMM(97));
MOV(IND(IMM(802)), IMM(97));
MOV(IND(IMM(803)), IMM(97));
MOV(IND(IMM(804)), IMM(100));
MOV(IND(IMM(805)), IMM(114));
MOV(IND(IMM(806)), IMM(799345));
MOV(IND(IMM(807)), IMM(6));
MOV(IND(IMM(808)), IMM(99));
MOV(IND(IMM(809)), IMM(97));
MOV(IND(IMM(810)), IMM(97));
MOV(IND(IMM(811)), IMM(97));
MOV(IND(IMM(812)), IMM(97));
MOV(IND(IMM(813)), IMM(114));
MOV(IND(IMM(814)), IMM(799345));
MOV(IND(IMM(815)), IMM(5));
MOV(IND(IMM(816)), IMM(99));
MOV(IND(IMM(817)), IMM(100));
MOV(IND(IMM(818)), IMM(100));
MOV(IND(IMM(819)), IMM(100));
MOV(IND(IMM(820)), IMM(114));
MOV(IND(IMM(821)), IMM(799345));
MOV(IND(IMM(822)), IMM(5));
MOV(IND(IMM(823)), IMM(99));
MOV(IND(IMM(824)), IMM(100));
MOV(IND(IMM(825)), IMM(100));
MOV(IND(IMM(826)), IMM(97));
MOV(IND(IMM(827)), IMM(114));
MOV(IND(IMM(828)), IMM(799345));
MOV(IND(IMM(829)), IMM(5));
MOV(IND(IMM(830)), IMM(99));
MOV(IND(IMM(831)), IMM(100));
MOV(IND(IMM(832)), IMM(97));
MOV(IND(IMM(833)), IMM(100));
MOV(IND(IMM(834)), IMM(114));
MOV(IND(IMM(835)), IMM(799345));
MOV(IND(IMM(836)), IMM(5));
MOV(IND(IMM(837)), IMM(99));
MOV(IND(IMM(838)), IMM(100));
MOV(IND(IMM(839)), IMM(97));
MOV(IND(IMM(840)), IMM(97));
MOV(IND(IMM(841)), IMM(114));
MOV(IND(IMM(842)), IMM(799345));
MOV(IND(IMM(843)), IMM(5));
MOV(IND(IMM(844)), IMM(99));
MOV(IND(IMM(845)), IMM(97));
MOV(IND(IMM(846)), IMM(100));
MOV(IND(IMM(847)), IMM(100));
MOV(IND(IMM(848)), IMM(114));
MOV(IND(IMM(849)), IMM(799345));
MOV(IND(IMM(850)), IMM(5));
MOV(IND(IMM(851)), IMM(99));
MOV(IND(IMM(852)), IMM(97));
MOV(IND(IMM(853)), IMM(100));
MOV(IND(IMM(854)), IMM(97));
MOV(IND(IMM(855)), IMM(114));
MOV(IND(IMM(856)), IMM(799345));
MOV(IND(IMM(857)), IMM(5));
MOV(IND(IMM(858)), IMM(99));
MOV(IND(IMM(859)), IMM(97));
MOV(IND(IMM(860)), IMM(97));
MOV(IND(IMM(861)), IMM(100));
MOV(IND(IMM(862)), IMM(114));
MOV(IND(IMM(863)), IMM(799345));
MOV(IND(IMM(864)), IMM(5));
MOV(IND(IMM(865)), IMM(99));
MOV(IND(IMM(866)), IMM(97));
MOV(IND(IMM(867)), IMM(97));
MOV(IND(IMM(868)), IMM(97));
MOV(IND(IMM(869)), IMM(114));
MOV(IND(IMM(870)), IMM(799345));
MOV(IND(IMM(871)), IMM(4));
MOV(IND(IMM(872)), IMM(99));
MOV(IND(IMM(873)), IMM(100));
MOV(IND(IMM(874)), IMM(100));
MOV(IND(IMM(875)), IMM(114));
MOV(IND(IMM(876)), IMM(799345));
MOV(IND(IMM(877)), IMM(4));
MOV(IND(IMM(878)), IMM(99));
MOV(IND(IMM(879)), IMM(100));
MOV(IND(IMM(880)), IMM(97));
MOV(IND(IMM(881)), IMM(114));
MOV(IND(IMM(882)), IMM(799345));
MOV(IND(IMM(883)), IMM(4));
MOV(IND(IMM(884)), IMM(99));
MOV(IND(IMM(885)), IMM(97));
MOV(IND(IMM(886)), IMM(100));
MOV(IND(IMM(887)), IMM(114));
MOV(IND(IMM(888)), IMM(799345));
MOV(IND(IMM(889)), IMM(4));
MOV(IND(IMM(890)), IMM(99));
MOV(IND(IMM(891)), IMM(97));
MOV(IND(IMM(892)), IMM(97));
MOV(IND(IMM(893)), IMM(114));
MOV(IND(IMM(894)), IMM(799345));
MOV(IND(IMM(895)), IMM(7));
MOV(IND(IMM(896)), IMM(99));
MOV(IND(IMM(897)), IMM(111));
MOV(IND(IMM(898)), IMM(109));
MOV(IND(IMM(899)), IMM(112));
MOV(IND(IMM(900)), IMM(111));
MOV(IND(IMM(901)), IMM(115));
MOV(IND(IMM(902)), IMM(101));
MOV(IND(IMM(903)), IMM(799345));
MOV(IND(IMM(904)), IMM(5));
MOV(IND(IMM(905)), IMM(102));
MOV(IND(IMM(906)), IMM(111));
MOV(IND(IMM(907)), IMM(108));
MOV(IND(IMM(908)), IMM(100));
MOV(IND(IMM(909)), IMM(114));
MOV(IND(IMM(910)), IMM(799345));
MOV(IND(IMM(911)), IMM(2));
MOV(IND(IMM(912)), IMM(60));
MOV(IND(IMM(913)), IMM(62));
MOV(IND(IMM(914)), IMM(799345));
MOV(IND(IMM(915)), IMM(2));
MOV(IND(IMM(916)), IMM(62));
MOV(IND(IMM(917)), IMM(61));
MOV(IND(IMM(918)), IMM(799345));
MOV(IND(IMM(919)), IMM(2));
MOV(IND(IMM(920)), IMM(60));
MOV(IND(IMM(921)), IMM(61));
MOV(IND(IMM(922)), IMM(799345));
MOV(IND(IMM(923)), IMM(5));
MOV(IND(IMM(924)), IMM(111));
MOV(IND(IMM(925)), IMM(114));
MOV(IND(IMM(926)), IMM(100));
MOV(IND(IMM(927)), IMM(101));
MOV(IND(IMM(928)), IMM(114));
MOV(IND(IMM(929)), IMM(799345));
MOV(IND(IMM(930)), IMM(6));
MOV(IND(IMM(931)), IMM(97));
MOV(IND(IMM(932)), IMM(110));
MOV(IND(IMM(933)), IMM(100));
MOV(IND(IMM(934)), IMM(109));
MOV(IND(IMM(935)), IMM(97));
MOV(IND(IMM(936)), IMM(112));
MOV(IND(IMM(937)), IMM(799345));
MOV(IND(IMM(938)), IMM(5));
MOV(IND(IMM(939)), IMM(111));
MOV(IND(IMM(940)), IMM(114));
MOV(IND(IMM(941)), IMM(109));
MOV(IND(IMM(942)), IMM(97));
MOV(IND(IMM(943)), IMM(112));
MOV(IND(IMM(944)), IMM(799345));
MOV(IND(IMM(945)), IMM(4));
MOV(IND(IMM(946)), IMM(115));
MOV(IND(IMM(947)), IMM(117));
MOV(IND(IMM(948)), IMM(98));
MOV(IND(IMM(949)), IMM(49));
MOV(IND(IMM(950)), IMM(799345));
MOV(IND(IMM(951)), IMM(4));
MOV(IND(IMM(952)), IMM(97));
MOV(IND(IMM(953)), IMM(100));
MOV(IND(IMM(954)), IMM(100));
MOV(IND(IMM(955)), IMM(49));
MOV(IND(IMM(956)), IMM(799345));
MOV(IND(IMM(957)), IMM(6));
MOV(IND(IMM(958)), IMM(98));
MOV(IND(IMM(959)), IMM(105));
MOV(IND(IMM(960)), IMM(110));
MOV(IND(IMM(961)), IMM(62));
MOV(IND(IMM(962)), IMM(61));
MOV(IND(IMM(963)), IMM(63));
MOV(IND(IMM(964)), IMM(799345));
MOV(IND(IMM(965)), IMM(3));
MOV(IND(IMM(966)), IMM(110));
MOV(IND(IMM(967)), IMM(111));
MOV(IND(IMM(968)), IMM(116));
MOV(IND(IMM(969)), IMM(799345));
MOV(IND(IMM(970)), IMM(6));
MOV(IND(IMM(971)), IMM(98));
MOV(IND(IMM(972)), IMM(105));
MOV(IND(IMM(973)), IMM(110));
MOV(IND(IMM(974)), IMM(60));
MOV(IND(IMM(975)), IMM(61));
MOV(IND(IMM(976)), IMM(63));
MOV(IND(IMM(977)), IMM(799345));
MOV(IND(IMM(978)), IMM(5));
MOV(IND(IMM(979)), IMM(98));
MOV(IND(IMM(980)), IMM(105));
MOV(IND(IMM(981)), IMM(110));
MOV(IND(IMM(982)), IMM(61));
MOV(IND(IMM(983)), IMM(63));
MOV(IND(IMM(984)), IMM(799345));
MOV(IND(IMM(985)), IMM(5));
MOV(IND(IMM(986)), IMM(98));
MOV(IND(IMM(987)), IMM(105));
MOV(IND(IMM(988)), IMM(110));
MOV(IND(IMM(989)), IMM(62));
MOV(IND(IMM(990)), IMM(63));
MOV(IND(IMM(991)), IMM(799345));
MOV(IND(IMM(992)), IMM(5));
MOV(IND(IMM(993)), IMM(98));
MOV(IND(IMM(994)), IMM(105));
MOV(IND(IMM(995)), IMM(110));
MOV(IND(IMM(996)), IMM(60));
MOV(IND(IMM(997)), IMM(63));
MOV(IND(IMM(998)), IMM(799345));
MOV(IND(IMM(999)), IMM(4));
MOV(IND(IMM(1000)), IMM(98));
MOV(IND(IMM(1001)), IMM(105));
MOV(IND(IMM(1002)), IMM(110));
MOV(IND(IMM(1003)), IMM(47));
MOV(IND(IMM(1004)), IMM(799345));
MOV(IND(IMM(1005)), IMM(4));
MOV(IND(IMM(1006)), IMM(98));
MOV(IND(IMM(1007)), IMM(105));
MOV(IND(IMM(1008)), IMM(110));
MOV(IND(IMM(1009)), IMM(42));
MOV(IND(IMM(1010)), IMM(799345));
MOV(IND(IMM(1011)), IMM(4));
MOV(IND(IMM(1012)), IMM(98));
MOV(IND(IMM(1013)), IMM(105));
MOV(IND(IMM(1014)), IMM(110));
MOV(IND(IMM(1015)), IMM(45));
MOV(IND(IMM(1016)), IMM(799345));
MOV(IND(IMM(1017)), IMM(4));
MOV(IND(IMM(1018)), IMM(98));
MOV(IND(IMM(1019)), IMM(105));
MOV(IND(IMM(1020)), IMM(110));
MOV(IND(IMM(1021)), IMM(43));
MOV(IND(IMM(1022)), IMM(799345));
MOV(IND(IMM(1023)), IMM(2));
MOV(IND(IMM(1024)), IMM(89));
MOV(IND(IMM(1025)), IMM(109));
MOV(IND(IMM(1026)), IMM(799345));
MOV(IND(IMM(1027)), IMM(3));
MOV(IND(IMM(1028)), IMM(109));
MOV(IND(IMM(1029)), IMM(97));
MOV(IND(IMM(1030)), IMM(112));
MOV(IND(IMM(1031)), IMM(799345));
MOV(IND(IMM(1032)), IMM(8));
MOV(IND(IMM(1033)), IMM(115));
MOV(IND(IMM(1034)), IMM(101));
MOV(IND(IMM(1035)), IMM(116));
MOV(IND(IMM(1036)), IMM(45));
MOV(IND(IMM(1037)), IMM(99));
MOV(IND(IMM(1038)), IMM(97));
MOV(IND(IMM(1039)), IMM(114));
MOV(IND(IMM(1040)), IMM(33));
MOV(IND(IMM(1041)), IMM(799345));
MOV(IND(IMM(1042)), IMM(8));
MOV(IND(IMM(1043)), IMM(115));
MOV(IND(IMM(1044)), IMM(101));
MOV(IND(IMM(1045)), IMM(116));
MOV(IND(IMM(1046)), IMM(45));
MOV(IND(IMM(1047)), IMM(99));
MOV(IND(IMM(1048)), IMM(100));
MOV(IND(IMM(1049)), IMM(114));
MOV(IND(IMM(1050)), IMM(33));
MOV(IND(IMM(1051)), IMM(799345));
MOV(IND(IMM(1052)), IMM(3));
MOV(IND(IMM(1053)), IMM(101));
MOV(IND(IMM(1054)), IMM(113));
MOV(IND(IMM(1055)), IMM(63));
MOV(IND(IMM(1056)), IMM(799345));
MOV(IND(IMM(1057)), IMM(14));
MOV(IND(IMM(1058)), IMM(115));
MOV(IND(IMM(1059)), IMM(116));
MOV(IND(IMM(1060)), IMM(114));
MOV(IND(IMM(1061)), IMM(105));
MOV(IND(IMM(1062)), IMM(110));
MOV(IND(IMM(1063)), IMM(103));
MOV(IND(IMM(1064)), IMM(45));
MOV(IND(IMM(1065)), IMM(62));
MOV(IND(IMM(1066)), IMM(115));
MOV(IND(IMM(1067)), IMM(121));
MOV(IND(IMM(1068)), IMM(109));
MOV(IND(IMM(1069)), IMM(98));
MOV(IND(IMM(1070)), IMM(111));
MOV(IND(IMM(1071)), IMM(108));
MOV(IND(IMM(1072)), IMM(799345));
MOV(IND(IMM(1073)), IMM(14));
MOV(IND(IMM(1074)), IMM(115));
MOV(IND(IMM(1075)), IMM(121));
MOV(IND(IMM(1076)), IMM(109));
MOV(IND(IMM(1077)), IMM(98));
MOV(IND(IMM(1078)), IMM(111));
MOV(IND(IMM(1079)), IMM(108));
MOV(IND(IMM(1080)), IMM(45));
MOV(IND(IMM(1081)), IMM(62));
MOV(IND(IMM(1082)), IMM(115));
MOV(IND(IMM(1083)), IMM(116));
MOV(IND(IMM(1084)), IMM(114));
MOV(IND(IMM(1085)), IMM(105));
MOV(IND(IMM(1086)), IMM(110));
MOV(IND(IMM(1087)), IMM(103));
MOV(IND(IMM(1088)), IMM(799345));
MOV(IND(IMM(1089)), IMM(6));
MOV(IND(IMM(1090)), IMM(108));
MOV(IND(IMM(1091)), IMM(101));
MOV(IND(IMM(1092)), IMM(110));
MOV(IND(IMM(1093)), IMM(103));
MOV(IND(IMM(1094)), IMM(116));
MOV(IND(IMM(1095)), IMM(104));
MOV(IND(IMM(1096)), IMM(799345));
MOV(IND(IMM(1097)), IMM(5));
MOV(IND(IMM(1098)), IMM(97));
MOV(IND(IMM(1099)), IMM(112));
MOV(IND(IMM(1100)), IMM(112));
MOV(IND(IMM(1101)), IMM(108));
MOV(IND(IMM(1102)), IMM(121));
MOV(IND(IMM(1103)), IMM(799345));
MOV(IND(IMM(1104)), IMM(6));
MOV(IND(IMM(1105)), IMM(118));
MOV(IND(IMM(1106)), IMM(101));
MOV(IND(IMM(1107)), IMM(99));
MOV(IND(IMM(1108)), IMM(116));
MOV(IND(IMM(1109)), IMM(111));
MOV(IND(IMM(1110)), IMM(114));
MOV(IND(IMM(1111)), IMM(799345));
MOV(IND(IMM(1112)), IMM(4));
MOV(IND(IMM(1113)), IMM(108));
MOV(IND(IMM(1114)), IMM(105));
MOV(IND(IMM(1115)), IMM(115));
MOV(IND(IMM(1116)), IMM(116));
MOV(IND(IMM(1117)), IMM(799345));
MOV(IND(IMM(1118)), IMM(3));
MOV(IND(IMM(1119)), IMM(99));
MOV(IND(IMM(1120)), IMM(100));
MOV(IND(IMM(1121)), IMM(114));
MOV(IND(IMM(1122)), IMM(799345));
MOV(IND(IMM(1123)), IMM(3));
MOV(IND(IMM(1124)), IMM(99));
MOV(IND(IMM(1125)), IMM(97));
MOV(IND(IMM(1126)), IMM(114));
MOV(IND(IMM(1127)), IMM(799345));
MOV(IND(IMM(1128)), IMM(4));
MOV(IND(IMM(1129)), IMM(99));
MOV(IND(IMM(1130)), IMM(111));
MOV(IND(IMM(1131)), IMM(110));
MOV(IND(IMM(1132)), IMM(115));
MOV(IND(IMM(1133)), IMM(799345));
MOV(IND(IMM(1134)), IMM(11));
MOV(IND(IMM(1135)), IMM(109));
MOV(IND(IMM(1136)), IMM(97));
MOV(IND(IMM(1137)), IMM(107));
MOV(IND(IMM(1138)), IMM(101));
MOV(IND(IMM(1139)), IMM(45));
MOV(IND(IMM(1140)), IMM(118));
MOV(IND(IMM(1141)), IMM(101));
MOV(IND(IMM(1142)), IMM(99));
MOV(IND(IMM(1143)), IMM(116));
MOV(IND(IMM(1144)), IMM(111));
MOV(IND(IMM(1145)), IMM(114));
MOV(IND(IMM(1146)), IMM(799345));
MOV(IND(IMM(1147)), IMM(11));
MOV(IND(IMM(1148)), IMM(118));
MOV(IND(IMM(1149)), IMM(101));
MOV(IND(IMM(1150)), IMM(99));
MOV(IND(IMM(1151)), IMM(116));
MOV(IND(IMM(1152)), IMM(111));
MOV(IND(IMM(1153)), IMM(114));
MOV(IND(IMM(1154)), IMM(45));
MOV(IND(IMM(1155)), IMM(115));
MOV(IND(IMM(1156)), IMM(101));
MOV(IND(IMM(1157)), IMM(116));
MOV(IND(IMM(1158)), IMM(33));
MOV(IND(IMM(1159)), IMM(799345));
MOV(IND(IMM(1160)), IMM(10));
MOV(IND(IMM(1161)), IMM(118));
MOV(IND(IMM(1162)), IMM(101));
MOV(IND(IMM(1163)), IMM(99));
MOV(IND(IMM(1164)), IMM(116));
MOV(IND(IMM(1165)), IMM(111));
MOV(IND(IMM(1166)), IMM(114));
MOV(IND(IMM(1167)), IMM(45));
MOV(IND(IMM(1168)), IMM(114));
MOV(IND(IMM(1169)), IMM(101));
MOV(IND(IMM(1170)), IMM(102));
MOV(IND(IMM(1171)), IMM(799345));
MOV(IND(IMM(1172)), IMM(13));
MOV(IND(IMM(1173)), IMM(118));
MOV(IND(IMM(1174)), IMM(101));
MOV(IND(IMM(1175)), IMM(99));
MOV(IND(IMM(1176)), IMM(116));
MOV(IND(IMM(1177)), IMM(111));
MOV(IND(IMM(1178)), IMM(114));
MOV(IND(IMM(1179)), IMM(45));
MOV(IND(IMM(1180)), IMM(108));
MOV(IND(IMM(1181)), IMM(101));
MOV(IND(IMM(1182)), IMM(110));
MOV(IND(IMM(1183)), IMM(103));
MOV(IND(IMM(1184)), IMM(116));
MOV(IND(IMM(1185)), IMM(104));
MOV(IND(IMM(1186)), IMM(799345));
MOV(IND(IMM(1187)), IMM(11));
MOV(IND(IMM(1188)), IMM(109));
MOV(IND(IMM(1189)), IMM(97));
MOV(IND(IMM(1190)), IMM(107));
MOV(IND(IMM(1191)), IMM(101));
MOV(IND(IMM(1192)), IMM(45));
MOV(IND(IMM(1193)), IMM(115));
MOV(IND(IMM(1194)), IMM(116));
MOV(IND(IMM(1195)), IMM(114));
MOV(IND(IMM(1196)), IMM(105));
MOV(IND(IMM(1197)), IMM(110));
MOV(IND(IMM(1198)), IMM(103));
MOV(IND(IMM(1199)), IMM(799345));
MOV(IND(IMM(1200)), IMM(11));
MOV(IND(IMM(1201)), IMM(115));
MOV(IND(IMM(1202)), IMM(116));
MOV(IND(IMM(1203)), IMM(114));
MOV(IND(IMM(1204)), IMM(105));
MOV(IND(IMM(1205)), IMM(110));
MOV(IND(IMM(1206)), IMM(103));
MOV(IND(IMM(1207)), IMM(45));
MOV(IND(IMM(1208)), IMM(115));
MOV(IND(IMM(1209)), IMM(101));
MOV(IND(IMM(1210)), IMM(116));
MOV(IND(IMM(1211)), IMM(33));
MOV(IND(IMM(1212)), IMM(799345));
MOV(IND(IMM(1213)), IMM(10));
MOV(IND(IMM(1214)), IMM(115));
MOV(IND(IMM(1215)), IMM(116));
MOV(IND(IMM(1216)), IMM(114));
MOV(IND(IMM(1217)), IMM(105));
MOV(IND(IMM(1218)), IMM(110));
MOV(IND(IMM(1219)), IMM(103));
MOV(IND(IMM(1220)), IMM(45));
MOV(IND(IMM(1221)), IMM(114));
MOV(IND(IMM(1222)), IMM(101));
MOV(IND(IMM(1223)), IMM(102));
MOV(IND(IMM(1224)), IMM(799345));
MOV(IND(IMM(1225)), IMM(13));
MOV(IND(IMM(1226)), IMM(115));
MOV(IND(IMM(1227)), IMM(116));
MOV(IND(IMM(1228)), IMM(114));
MOV(IND(IMM(1229)), IMM(105));
MOV(IND(IMM(1230)), IMM(110));
MOV(IND(IMM(1231)), IMM(103));
MOV(IND(IMM(1232)), IMM(45));
MOV(IND(IMM(1233)), IMM(108));
MOV(IND(IMM(1234)), IMM(101));
MOV(IND(IMM(1235)), IMM(110));
MOV(IND(IMM(1236)), IMM(103));
MOV(IND(IMM(1237)), IMM(116));
MOV(IND(IMM(1238)), IMM(104));
MOV(IND(IMM(1239)), IMM(799345));
MOV(IND(IMM(1240)), IMM(13));
MOV(IND(IMM(1241)), IMM(105));
MOV(IND(IMM(1242)), IMM(110));
MOV(IND(IMM(1243)), IMM(116));
MOV(IND(IMM(1244)), IMM(101));
MOV(IND(IMM(1245)), IMM(103));
MOV(IND(IMM(1246)), IMM(101));
MOV(IND(IMM(1247)), IMM(114));
MOV(IND(IMM(1248)), IMM(45));
MOV(IND(IMM(1249)), IMM(62));
MOV(IND(IMM(1250)), IMM(99));
MOV(IND(IMM(1251)), IMM(104));
MOV(IND(IMM(1252)), IMM(97));
MOV(IND(IMM(1253)), IMM(114));
MOV(IND(IMM(1254)), IMM(799345));
MOV(IND(IMM(1255)), IMM(13));
MOV(IND(IMM(1256)), IMM(99));
MOV(IND(IMM(1257)), IMM(104));
MOV(IND(IMM(1258)), IMM(97));
MOV(IND(IMM(1259)), IMM(114));
MOV(IND(IMM(1260)), IMM(45));
MOV(IND(IMM(1261)), IMM(62));
MOV(IND(IMM(1262)), IMM(105));
MOV(IND(IMM(1263)), IMM(110));
MOV(IND(IMM(1264)), IMM(116));
MOV(IND(IMM(1265)), IMM(101));
MOV(IND(IMM(1266)), IMM(103));
MOV(IND(IMM(1267)), IMM(101));
MOV(IND(IMM(1268)), IMM(114));
MOV(IND(IMM(1269)), IMM(799345));
MOV(IND(IMM(1270)), IMM(1));
MOV(IND(IMM(1271)), IMM(61));
MOV(IND(IMM(1272)), IMM(799345));
MOV(IND(IMM(1273)), IMM(1));
MOV(IND(IMM(1274)), IMM(62));
MOV(IND(IMM(1275)), IMM(799345));
MOV(IND(IMM(1276)), IMM(1));
MOV(IND(IMM(1277)), IMM(60));
MOV(IND(IMM(1278)), IMM(799345));
MOV(IND(IMM(1279)), IMM(1));
MOV(IND(IMM(1280)), IMM(47));
MOV(IND(IMM(1281)), IMM(799345));
MOV(IND(IMM(1282)), IMM(1));
MOV(IND(IMM(1283)), IMM(42));
MOV(IND(IMM(1284)), IMM(799345));
MOV(IND(IMM(1285)), IMM(1));
MOV(IND(IMM(1286)), IMM(45));
MOV(IND(IMM(1287)), IMM(799345));
MOV(IND(IMM(1288)), IMM(1));
MOV(IND(IMM(1289)), IMM(43));
MOV(IND(IMM(1290)), IMM(799345));
MOV(IND(IMM(1291)), IMM(10));
MOV(IND(IMM(1292)), IMM(112));
MOV(IND(IMM(1293)), IMM(114));
MOV(IND(IMM(1294)), IMM(111));
MOV(IND(IMM(1295)), IMM(99));
MOV(IND(IMM(1296)), IMM(101));
MOV(IND(IMM(1297)), IMM(100));
MOV(IND(IMM(1298)), IMM(117));
MOV(IND(IMM(1299)), IMM(114));
MOV(IND(IMM(1300)), IMM(101));
MOV(IND(IMM(1301)), IMM(63));
MOV(IND(IMM(1302)), IMM(799345));
MOV(IND(IMM(1303)), IMM(7));
MOV(IND(IMM(1304)), IMM(118));
MOV(IND(IMM(1305)), IMM(101));
MOV(IND(IMM(1306)), IMM(99));
MOV(IND(IMM(1307)), IMM(116));
MOV(IND(IMM(1308)), IMM(111));
MOV(IND(IMM(1309)), IMM(114));
MOV(IND(IMM(1310)), IMM(63));
MOV(IND(IMM(1311)), IMM(799345));
MOV(IND(IMM(1312)), IMM(5));
MOV(IND(IMM(1313)), IMM(122));
MOV(IND(IMM(1314)), IMM(101));
MOV(IND(IMM(1315)), IMM(114));
MOV(IND(IMM(1316)), IMM(111));
MOV(IND(IMM(1317)), IMM(63));
MOV(IND(IMM(1318)), IMM(799345));
MOV(IND(IMM(1319)), IMM(7));
MOV(IND(IMM(1320)), IMM(115));
MOV(IND(IMM(1321)), IMM(121));
MOV(IND(IMM(1322)), IMM(109));
MOV(IND(IMM(1323)), IMM(98));
MOV(IND(IMM(1324)), IMM(111));
MOV(IND(IMM(1325)), IMM(108));
MOV(IND(IMM(1326)), IMM(63));
MOV(IND(IMM(1327)), IMM(799345));
MOV(IND(IMM(1328)), IMM(7));
MOV(IND(IMM(1329)), IMM(115));
MOV(IND(IMM(1330)), IMM(116));
MOV(IND(IMM(1331)), IMM(114));
MOV(IND(IMM(1332)), IMM(105));
MOV(IND(IMM(1333)), IMM(110));
MOV(IND(IMM(1334)), IMM(103));
MOV(IND(IMM(1335)), IMM(63));
MOV(IND(IMM(1336)), IMM(799345));
MOV(IND(IMM(1337)), IMM(5));
MOV(IND(IMM(1338)), IMM(112));
MOV(IND(IMM(1339)), IMM(97));
MOV(IND(IMM(1340)), IMM(105));
MOV(IND(IMM(1341)), IMM(114));
MOV(IND(IMM(1342)), IMM(63));
MOV(IND(IMM(1343)), IMM(799345));
MOV(IND(IMM(1344)), IMM(5));
MOV(IND(IMM(1345)), IMM(110));
MOV(IND(IMM(1346)), IMM(117));
MOV(IND(IMM(1347)), IMM(108));
MOV(IND(IMM(1348)), IMM(108));
MOV(IND(IMM(1349)), IMM(63));
MOV(IND(IMM(1350)), IMM(799345));
MOV(IND(IMM(1351)), IMM(5));
MOV(IND(IMM(1352)), IMM(99));
MOV(IND(IMM(1353)), IMM(104));
MOV(IND(IMM(1354)), IMM(97));
MOV(IND(IMM(1355)), IMM(114));
MOV(IND(IMM(1356)), IMM(63));
MOV(IND(IMM(1357)), IMM(799345));
MOV(IND(IMM(1358)), IMM(8));
MOV(IND(IMM(1359)), IMM(98));
MOV(IND(IMM(1360)), IMM(111));
MOV(IND(IMM(1361)), IMM(111));
MOV(IND(IMM(1362)), IMM(108));
MOV(IND(IMM(1363)), IMM(101));
MOV(IND(IMM(1364)), IMM(97));
MOV(IND(IMM(1365)), IMM(110));
MOV(IND(IMM(1366)), IMM(63));
MOV(IND(IMM(1367)), IMM(799345));
MOV(IND(IMM(1368)), IMM(8));
MOV(IND(IMM(1369)), IMM(105));
MOV(IND(IMM(1370)), IMM(110));
MOV(IND(IMM(1371)), IMM(116));
MOV(IND(IMM(1372)), IMM(101));
MOV(IND(IMM(1373)), IMM(103));
MOV(IND(IMM(1374)), IMM(101));
MOV(IND(IMM(1375)), IMM(114));
MOV(IND(IMM(1376)), IMM(63));
MOV(IND(IMM(1377)), IMM(799345));
MOV(IND(IMM(1378)), IMM(7));
MOV(IND(IMM(1379)), IMM(110));
MOV(IND(IMM(1380)), IMM(117));
MOV(IND(IMM(1381)), IMM(109));
MOV(IND(IMM(1382)), IMM(98));
MOV(IND(IMM(1383)), IMM(101));
MOV(IND(IMM(1384)), IMM(114));
MOV(IND(IMM(1385)), IMM(63));
MOV(IND(IMM(1)), IMM(937610));
MOV(IND(IMM(2)), IMM(722689));
MOV(IND(IMM(3)), IMM(741553));
MOV(IND(IMM(4)), IMM(0));
MOV(IND(IMM(5)), IMM(741553));
MOV(IND(IMM(6)), IMM(1));
MOV(IND(IMM(2161)), IMM(945311));
MOV(IND(IMM(2162)), IMM(-1));
MOV(IND(IMM(2163)), IMM(945311));
MOV(IND(IMM(2164)), IMM(0));
MOV(IND(IMM(2165)), IMM(945311));
MOV(IND(IMM(2166)), IMM(2));
MOV(IND(IMM(2167)), IMM(181048));
MOV(IND(IMM(2168)), IMM(122));
MOV(IND(IMM(2169)), IMM(181048));
MOV(IND(IMM(2170)), IMM(97));
MOV(IND(IMM(2171)), IMM(181048));
MOV(IND(IMM(2172)), IMM(90));
MOV(IND(IMM(2173)), IMM(181048));
MOV(IND(IMM(2174)), IMM(65));
MOV(IND(IMM(2175)), IMM(945311));
MOV(IND(IMM(2176)), IMM(1));
MOV(INDD(1406, 0), IMM(368031));
MOV(INDD(1406, 1), IMM(1409));
MOV(INDD(1406, 2), IMM(1411));
MOV(INDD(1406, 3), IMM(10));
MOV(R0, 0);MOV(INDD(1406, 4), R0);
MOV(INDD(1411, 0), IMM(368031));
MOV(INDD(1411, 1), IMM(1414));
MOV(INDD(1411, 2), IMM(1416));
MOV(INDD(1411, 3), IMM(15));
MOV(R0, 0);MOV(INDD(1411, 4), R0);
MOV(INDD(1416, 0), IMM(368031));
MOV(INDD(1416, 1), IMM(1419));
MOV(INDD(1416, 2), IMM(1421));
MOV(INDD(1416, 3), IMM(20));
MOV(R0, 0);MOV(INDD(1416, 4), R0);
MOV(INDD(1421, 0), IMM(368031));
MOV(INDD(1421, 1), IMM(1424));
MOV(INDD(1421, 2), IMM(1426));
MOV(INDD(1421, 3), IMM(31));
MOV(R0, 0);MOV(INDD(1421, 4), R0);
MOV(INDD(1426, 0), IMM(368031));
MOV(INDD(1426, 1), IMM(1429));
MOV(INDD(1426, 2), IMM(1431));
MOV(INDD(1426, 3), IMM(47));
MOV(R0, 0);MOV(INDD(1426, 4), R0);
MOV(INDD(1431, 0), IMM(368031));
MOV(INDD(1431, 1), IMM(1434));
MOV(INDD(1431, 2), IMM(1436));
MOV(INDD(1431, 3), IMM(56));
MOV(R0, 0);MOV(INDD(1431, 4), R0);
MOV(INDD(1436, 0), IMM(368031));
MOV(INDD(1436, 1), IMM(1439));
MOV(INDD(1436, 2), IMM(1441));
MOV(INDD(1436, 3), IMM(71));
MOV(R0, 0);MOV(INDD(1436, 4), R0);
MOV(INDD(1441, 0), IMM(368031));
MOV(INDD(1441, 1), IMM(1444));
MOV(INDD(1441, 2), IMM(1446));
MOV(INDD(1441, 3), IMM(79));
MOV(R0, 0);MOV(INDD(1441, 4), R0);
MOV(INDD(1446, 0), IMM(368031));
MOV(INDD(1446, 1), IMM(1449));
MOV(INDD(1446, 2), IMM(1451));
MOV(INDD(1446, 3), IMM(94));
MOV(R0, 0);MOV(INDD(1446, 4), R0);
MOV(INDD(1451, 0), IMM(368031));
MOV(INDD(1451, 1), IMM(1454));
MOV(INDD(1451, 2), IMM(1456));
MOV(INDD(1451, 3), IMM(101));
MOV(R0, 0);MOV(INDD(1451, 4), R0);
MOV(INDD(1456, 0), IMM(368031));
MOV(INDD(1456, 1), IMM(1459));
MOV(INDD(1456, 2), IMM(1461));
MOV(INDD(1456, 3), IMM(107));
MOV(R0, 0);MOV(INDD(1456, 4), R0);
MOV(INDD(1461, 0), IMM(368031));
MOV(INDD(1461, 1), IMM(1464));
MOV(INDD(1461, 2), IMM(1466));
MOV(INDD(1461, 3), IMM(113));
MOV(R0, 0);MOV(INDD(1461, 4), R0);
MOV(INDD(1466, 0), IMM(368031));
MOV(INDD(1466, 1), IMM(1469));
MOV(INDD(1466, 2), IMM(1471));
MOV(INDD(1466, 3), IMM(120));
MOV(R0, 0);MOV(INDD(1466, 4), R0);
MOV(INDD(1471, 0), IMM(368031));
MOV(INDD(1471, 1), IMM(1474));
MOV(INDD(1471, 2), IMM(1476));
MOV(INDD(1471, 3), IMM(132));
MOV(R0, 0);MOV(INDD(1471, 4), R0);
MOV(INDD(1476, 0), IMM(368031));
MOV(INDD(1476, 1), IMM(1479));
MOV(INDD(1476, 2), IMM(1481));
MOV(INDD(1476, 3), IMM(143));
MOV(R0, 0);MOV(INDD(1476, 4), R0);
MOV(INDD(1481, 0), IMM(368031));
MOV(INDD(1481, 1), IMM(1484));
MOV(INDD(1481, 2), IMM(1486));
MOV(INDD(1481, 3), IMM(151));
MOV(R0, 0);MOV(INDD(1481, 4), R0);
MOV(INDD(1486, 0), IMM(368031));
MOV(INDD(1486, 1), IMM(1489));
MOV(INDD(1486, 2), IMM(1491));
MOV(INDD(1486, 3), IMM(159));
MOV(R0, 0);MOV(INDD(1486, 4), R0);
MOV(INDD(1491, 0), IMM(368031));
MOV(INDD(1491, 1), IMM(1494));
MOV(INDD(1491, 2), IMM(1496));
MOV(INDD(1491, 3), IMM(173));
MOV(R0, 0);MOV(INDD(1491, 4), R0);
MOV(INDD(1496, 0), IMM(368031));
MOV(INDD(1496, 1), IMM(1499));
MOV(INDD(1496, 2), IMM(1501));
MOV(INDD(1496, 3), IMM(184));
MOV(R0, 0);MOV(INDD(1496, 4), R0);
MOV(INDD(1501, 0), IMM(368031));
MOV(INDD(1501, 1), IMM(1504));
MOV(INDD(1501, 2), IMM(1506));
MOV(INDD(1501, 3), IMM(195));
MOV(R0, 0);MOV(INDD(1501, 4), R0);
MOV(INDD(1506, 0), IMM(368031));
MOV(INDD(1506, 1), IMM(1509));
MOV(INDD(1506, 2), IMM(1511));
MOV(INDD(1506, 3), IMM(205));
MOV(R0, 0);MOV(INDD(1506, 4), R0);
MOV(INDD(1511, 0), IMM(368031));
MOV(INDD(1511, 1), IMM(1514));
MOV(INDD(1511, 2), IMM(1516));
MOV(INDD(1511, 3), IMM(215));
MOV(R0, 0);MOV(INDD(1511, 4), R0);
MOV(INDD(1516, 0), IMM(368031));
MOV(INDD(1516, 1), IMM(1519));
MOV(INDD(1516, 2), IMM(1521));
MOV(INDD(1516, 3), IMM(225));
MOV(R0, 0);MOV(INDD(1516, 4), R0);
MOV(INDD(1521, 0), IMM(368031));
MOV(INDD(1521, 1), IMM(1524));
MOV(INDD(1521, 2), IMM(1526));
MOV(INDD(1521, 3), IMM(243));
MOV(R0, 0);MOV(INDD(1521, 4), R0);
MOV(INDD(1526, 0), IMM(368031));
MOV(INDD(1526, 1), IMM(1529));
MOV(INDD(1526, 2), IMM(1531));
MOV(INDD(1526, 3), IMM(261));
MOV(R0, 0);MOV(INDD(1526, 4), R0);
MOV(INDD(1531, 0), IMM(368031));
MOV(INDD(1531, 1), IMM(1534));
MOV(INDD(1531, 2), IMM(1536));
MOV(INDD(1531, 3), IMM(278));
MOV(R0, 0);MOV(INDD(1531, 4), R0);
MOV(INDD(1536, 0), IMM(368031));
MOV(INDD(1536, 1), IMM(1539));
MOV(INDD(1536, 2), IMM(1541));
MOV(INDD(1536, 3), IMM(295));
MOV(R0, 0);MOV(INDD(1536, 4), R0);
MOV(INDD(1541, 0), IMM(368031));
MOV(INDD(1541, 1), IMM(1544));
MOV(INDD(1541, 2), IMM(1546));
MOV(INDD(1541, 3), IMM(312));
MOV(R0, 0);MOV(INDD(1541, 4), R0);
MOV(INDD(1546, 0), IMM(368031));
MOV(INDD(1546, 1), IMM(1549));
MOV(INDD(1546, 2), IMM(1551));
MOV(INDD(1546, 3), IMM(326));
MOV(R0, 0);MOV(INDD(1546, 4), R0);
MOV(INDD(1551, 0), IMM(368031));
MOV(INDD(1551, 1), IMM(1554));
MOV(INDD(1551, 2), IMM(1556));
MOV(INDD(1551, 3), IMM(337));
MOV(R0, 0);MOV(INDD(1551, 4), R0);
MOV(INDD(1556, 0), IMM(368031));
MOV(INDD(1556, 1), IMM(1559));
MOV(INDD(1556, 2), IMM(1561));
MOV(INDD(1556, 3), IMM(348));
MOV(R0, 0);MOV(INDD(1556, 4), R0);
MOV(INDD(1561, 0), IMM(368031));
MOV(INDD(1561, 1), IMM(1564));
MOV(INDD(1561, 2), IMM(1566));
MOV(INDD(1561, 3), IMM(357));
MOV(R0, 0);MOV(INDD(1561, 4), R0);
MOV(INDD(1566, 0), IMM(368031));
MOV(INDD(1566, 1), IMM(1569));
MOV(INDD(1566, 2), IMM(1571));
MOV(INDD(1566, 3), IMM(364));
MOV(R0, 0);MOV(INDD(1566, 4), R0);
MOV(INDD(1571, 0), IMM(368031));
MOV(INDD(1571, 1), IMM(1574));
MOV(INDD(1571, 2), IMM(1576));
MOV(INDD(1571, 3), IMM(374));
MOV(R0, 0);MOV(INDD(1571, 4), R0);
MOV(INDD(1576, 0), IMM(368031));
MOV(INDD(1576, 1), IMM(1579));
MOV(INDD(1576, 2), IMM(1581));
MOV(INDD(1576, 3), IMM(380));
PUSH(LABEL(REMAINDER));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1576, 4), R0);
MOV(INDD(1581, 0), IMM(368031));
MOV(INDD(1581, 1), IMM(1584));
MOV(INDD(1581, 2), IMM(1586));
MOV(INDD(1581, 3), IMM(391));
MOV(R0, 0);MOV(INDD(1581, 4), R0);
MOV(INDD(1586, 0), IMM(368031));
MOV(INDD(1586, 1), IMM(1589));
MOV(INDD(1586, 2), IMM(1591));
MOV(INDD(1586, 3), IMM(398));
MOV(R0, 0);MOV(INDD(1586, 4), R0);
MOV(INDD(1591, 0), IMM(368031));
MOV(INDD(1591, 1), IMM(1594));
MOV(INDD(1591, 2), IMM(1596));
MOV(INDD(1591, 3), IMM(415));
MOV(R0, 0);MOV(INDD(1591, 4), R0);
MOV(INDD(1596, 0), IMM(368031));
MOV(INDD(1596, 1), IMM(1599));
MOV(INDD(1596, 2), IMM(1601));
MOV(INDD(1596, 3), IMM(429));
MOV(R0, 0);MOV(INDD(1596, 4), R0);
MOV(INDD(1601, 0), IMM(368031));
MOV(INDD(1601, 1), IMM(1604));
MOV(INDD(1601, 2), IMM(1606));
MOV(INDD(1601, 3), IMM(443));
MOV(R0, 0);MOV(INDD(1601, 4), R0);
MOV(INDD(1606, 0), IMM(368031));
MOV(INDD(1606, 1), IMM(1609));
MOV(INDD(1606, 2), IMM(1611));
MOV(INDD(1606, 3), IMM(458));
MOV(R0, 0);MOV(INDD(1606, 4), R0);
MOV(INDD(1611, 0), IMM(368031));
MOV(INDD(1611, 1), IMM(1614));
MOV(INDD(1611, 2), IMM(1616));
MOV(INDD(1611, 3), IMM(470));
MOV(R0, 0);MOV(INDD(1611, 4), R0);
MOV(INDD(1616, 0), IMM(368031));
MOV(INDD(1616, 1), IMM(1619));
MOV(INDD(1616, 2), IMM(1621));
MOV(INDD(1616, 3), IMM(481));
MOV(R0, 0);MOV(INDD(1616, 4), R0);
MOV(INDD(1621, 0), IMM(368031));
MOV(INDD(1621, 1), IMM(1624));
MOV(INDD(1621, 2), IMM(1626));
MOV(INDD(1621, 3), IMM(492));
MOV(R0, 0);MOV(INDD(1621, 4), R0);
MOV(INDD(1626, 0), IMM(368031));
MOV(INDD(1626, 1), IMM(1629));
MOV(INDD(1626, 2), IMM(1631));
MOV(INDD(1626, 3), IMM(503));
MOV(R0, 0);MOV(INDD(1626, 4), R0);
MOV(INDD(1631, 0), IMM(368031));
MOV(INDD(1631, 1), IMM(1634));
MOV(INDD(1631, 2), IMM(1636));
MOV(INDD(1631, 3), IMM(515));
MOV(R0, 0);MOV(INDD(1631, 4), R0);
MOV(INDD(1636, 0), IMM(368031));
MOV(INDD(1636, 1), IMM(1639));
MOV(INDD(1636, 2), IMM(1641));
MOV(INDD(1636, 3), IMM(530));
MOV(R0, 0);MOV(INDD(1636, 4), R0);
MOV(INDD(1641, 0), IMM(368031));
MOV(INDD(1641, 1), IMM(1644));
MOV(INDD(1641, 2), IMM(1646));
MOV(INDD(1641, 3), IMM(543));
MOV(R0, 0);MOV(INDD(1641, 4), R0);
MOV(INDD(1646, 0), IMM(368031));
MOV(INDD(1646, 1), IMM(1649));
MOV(INDD(1646, 2), IMM(1651));
MOV(INDD(1646, 3), IMM(560));
MOV(R0, 0);MOV(INDD(1646, 4), R0);
MOV(INDD(1651, 0), IMM(368031));
MOV(INDD(1651, 1), IMM(1654));
MOV(INDD(1651, 2), IMM(1656));
MOV(INDD(1651, 3), IMM(577));
MOV(R0, 0);MOV(INDD(1651, 4), R0);
MOV(INDD(1656, 0), IMM(368031));
MOV(INDD(1656, 1), IMM(1659));
MOV(INDD(1656, 2), IMM(1661));
MOV(INDD(1656, 3), IMM(585));
MOV(R0, 0);MOV(INDD(1656, 4), R0);
MOV(INDD(1661, 0), IMM(368031));
MOV(INDD(1661, 1), IMM(1664));
MOV(INDD(1661, 2), IMM(1666));
MOV(INDD(1661, 3), IMM(594));
MOV(R0, 0);MOV(INDD(1661, 4), R0);
MOV(INDD(1666, 0), IMM(368031));
MOV(INDD(1666, 1), IMM(1669));
MOV(INDD(1666, 2), IMM(1671));
MOV(INDD(1666, 3), IMM(602));
MOV(R0, 0);MOV(INDD(1666, 4), R0);
MOV(INDD(1671, 0), IMM(368031));
MOV(INDD(1671, 1), IMM(1674));
MOV(INDD(1671, 2), IMM(1676));
MOV(INDD(1671, 3), IMM(611));
MOV(R0, 0);MOV(INDD(1671, 4), R0);
MOV(INDD(1676, 0), IMM(368031));
MOV(INDD(1676, 1), IMM(1679));
MOV(INDD(1676, 2), IMM(1681));
MOV(INDD(1676, 3), IMM(619));
MOV(R0, 0);MOV(INDD(1676, 4), R0);
MOV(INDD(1681, 0), IMM(368031));
MOV(INDD(1681, 1), IMM(1684));
MOV(INDD(1681, 2), IMM(1686));
MOV(INDD(1681, 3), IMM(629));
MOV(R0, 0);MOV(INDD(1681, 4), R0);
MOV(INDD(1686, 0), IMM(368031));
MOV(INDD(1686, 1), IMM(1689));
MOV(INDD(1686, 2), IMM(1691));
MOV(INDD(1686, 3), IMM(657));
MOV(R0, 0);MOV(INDD(1686, 4), R0);
MOV(INDD(1691, 0), IMM(368031));
MOV(INDD(1691, 1), IMM(1694));
MOV(INDD(1691, 2), IMM(1696));
MOV(INDD(1691, 3), IMM(686));
MOV(R0, 0);MOV(INDD(1691, 4), R0);
MOV(INDD(1696, 0), IMM(368031));
MOV(INDD(1696, 1), IMM(1699));
MOV(INDD(1696, 2), IMM(1701));
MOV(INDD(1696, 3), IMM(694));
MOV(R0, 0);MOV(INDD(1696, 4), R0);
MOV(INDD(1701, 0), IMM(368031));
MOV(INDD(1701, 1), IMM(1704));
MOV(INDD(1701, 2), IMM(1706));
MOV(INDD(1701, 3), IMM(702));
MOV(R0, 0);MOV(INDD(1701, 4), R0);
MOV(INDD(1706, 0), IMM(368031));
MOV(INDD(1706, 1), IMM(1709));
MOV(INDD(1706, 2), IMM(1711));
MOV(INDD(1706, 3), IMM(710));
MOV(R0, 0);MOV(INDD(1706, 4), R0);
MOV(INDD(1711, 0), IMM(368031));
MOV(INDD(1711, 1), IMM(1714));
MOV(INDD(1711, 2), IMM(1716));
MOV(INDD(1711, 3), IMM(718));
MOV(R0, 0);MOV(INDD(1711, 4), R0);
MOV(INDD(1716, 0), IMM(368031));
MOV(INDD(1716, 1), IMM(1719));
MOV(INDD(1716, 2), IMM(1721));
MOV(INDD(1716, 3), IMM(726));
MOV(R0, 0);MOV(INDD(1716, 4), R0);
MOV(INDD(1721, 0), IMM(368031));
MOV(INDD(1721, 1), IMM(1724));
MOV(INDD(1721, 2), IMM(1726));
MOV(INDD(1721, 3), IMM(734));
MOV(R0, 0);MOV(INDD(1721, 4), R0);
MOV(INDD(1726, 0), IMM(368031));
MOV(INDD(1726, 1), IMM(1729));
MOV(INDD(1726, 2), IMM(1731));
MOV(INDD(1726, 3), IMM(742));
MOV(R0, 0);MOV(INDD(1726, 4), R0);
MOV(INDD(1731, 0), IMM(368031));
MOV(INDD(1731, 1), IMM(1734));
MOV(INDD(1731, 2), IMM(1736));
MOV(INDD(1731, 3), IMM(750));
MOV(R0, 0);MOV(INDD(1731, 4), R0);
MOV(INDD(1736, 0), IMM(368031));
MOV(INDD(1736, 1), IMM(1739));
MOV(INDD(1736, 2), IMM(1741));
MOV(INDD(1736, 3), IMM(758));
MOV(R0, 0);MOV(INDD(1736, 4), R0);
MOV(INDD(1741, 0), IMM(368031));
MOV(INDD(1741, 1), IMM(1744));
MOV(INDD(1741, 2), IMM(1746));
MOV(INDD(1741, 3), IMM(766));
MOV(R0, 0);MOV(INDD(1741, 4), R0);
MOV(INDD(1746, 0), IMM(368031));
MOV(INDD(1746, 1), IMM(1749));
MOV(INDD(1746, 2), IMM(1751));
MOV(INDD(1746, 3), IMM(774));
MOV(R0, 0);MOV(INDD(1746, 4), R0);
MOV(INDD(1751, 0), IMM(368031));
MOV(INDD(1751, 1), IMM(1754));
MOV(INDD(1751, 2), IMM(1756));
MOV(INDD(1751, 3), IMM(782));
MOV(R0, 0);MOV(INDD(1751, 4), R0);
MOV(INDD(1756, 0), IMM(368031));
MOV(INDD(1756, 1), IMM(1759));
MOV(INDD(1756, 2), IMM(1761));
MOV(INDD(1756, 3), IMM(790));
MOV(R0, 0);MOV(INDD(1756, 4), R0);
MOV(INDD(1761, 0), IMM(368031));
MOV(INDD(1761, 1), IMM(1764));
MOV(INDD(1761, 2), IMM(1766));
MOV(INDD(1761, 3), IMM(798));
MOV(R0, 0);MOV(INDD(1761, 4), R0);
MOV(INDD(1766, 0), IMM(368031));
MOV(INDD(1766, 1), IMM(1769));
MOV(INDD(1766, 2), IMM(1771));
MOV(INDD(1766, 3), IMM(806));
MOV(R0, 0);MOV(INDD(1766, 4), R0);
MOV(INDD(1771, 0), IMM(368031));
MOV(INDD(1771, 1), IMM(1774));
MOV(INDD(1771, 2), IMM(1776));
MOV(INDD(1771, 3), IMM(814));
MOV(R0, 0);MOV(INDD(1771, 4), R0);
MOV(INDD(1776, 0), IMM(368031));
MOV(INDD(1776, 1), IMM(1779));
MOV(INDD(1776, 2), IMM(1781));
MOV(INDD(1776, 3), IMM(821));
MOV(R0, 0);MOV(INDD(1776, 4), R0);
MOV(INDD(1781, 0), IMM(368031));
MOV(INDD(1781, 1), IMM(1784));
MOV(INDD(1781, 2), IMM(1786));
MOV(INDD(1781, 3), IMM(828));
MOV(R0, 0);MOV(INDD(1781, 4), R0);
MOV(INDD(1786, 0), IMM(368031));
MOV(INDD(1786, 1), IMM(1789));
MOV(INDD(1786, 2), IMM(1791));
MOV(INDD(1786, 3), IMM(835));
MOV(R0, 0);MOV(INDD(1786, 4), R0);
MOV(INDD(1791, 0), IMM(368031));
MOV(INDD(1791, 1), IMM(1794));
MOV(INDD(1791, 2), IMM(1796));
MOV(INDD(1791, 3), IMM(842));
MOV(R0, 0);MOV(INDD(1791, 4), R0);
MOV(INDD(1796, 0), IMM(368031));
MOV(INDD(1796, 1), IMM(1799));
MOV(INDD(1796, 2), IMM(1801));
MOV(INDD(1796, 3), IMM(849));
MOV(R0, 0);MOV(INDD(1796, 4), R0);
MOV(INDD(1801, 0), IMM(368031));
MOV(INDD(1801, 1), IMM(1804));
MOV(INDD(1801, 2), IMM(1806));
MOV(INDD(1801, 3), IMM(856));
MOV(R0, 0);MOV(INDD(1801, 4), R0);
MOV(INDD(1806, 0), IMM(368031));
MOV(INDD(1806, 1), IMM(1809));
MOV(INDD(1806, 2), IMM(1811));
MOV(INDD(1806, 3), IMM(863));
MOV(R0, 0);MOV(INDD(1806, 4), R0);
MOV(INDD(1811, 0), IMM(368031));
MOV(INDD(1811, 1), IMM(1814));
MOV(INDD(1811, 2), IMM(1816));
MOV(INDD(1811, 3), IMM(870));
MOV(R0, 0);MOV(INDD(1811, 4), R0);
MOV(INDD(1816, 0), IMM(368031));
MOV(INDD(1816, 1), IMM(1819));
MOV(INDD(1816, 2), IMM(1821));
MOV(INDD(1816, 3), IMM(876));
MOV(R0, 0);MOV(INDD(1816, 4), R0);
MOV(INDD(1821, 0), IMM(368031));
MOV(INDD(1821, 1), IMM(1824));
MOV(INDD(1821, 2), IMM(1826));
MOV(INDD(1821, 3), IMM(882));
MOV(R0, 0);MOV(INDD(1821, 4), R0);
MOV(INDD(1826, 0), IMM(368031));
MOV(INDD(1826, 1), IMM(1829));
MOV(INDD(1826, 2), IMM(1831));
MOV(INDD(1826, 3), IMM(888));
MOV(R0, 0);MOV(INDD(1826, 4), R0);
MOV(INDD(1831, 0), IMM(368031));
MOV(INDD(1831, 1), IMM(1834));
MOV(INDD(1831, 2), IMM(1836));
MOV(INDD(1831, 3), IMM(894));
MOV(R0, 0);MOV(INDD(1831, 4), R0);
MOV(INDD(1836, 0), IMM(368031));
MOV(INDD(1836, 1), IMM(1839));
MOV(INDD(1836, 2), IMM(1841));
MOV(INDD(1836, 3), IMM(903));
MOV(R0, 0);MOV(INDD(1836, 4), R0);
MOV(INDD(1841, 0), IMM(368031));
MOV(INDD(1841, 1), IMM(1844));
MOV(INDD(1841, 2), IMM(1846));
MOV(INDD(1841, 3), IMM(910));
MOV(R0, 0);MOV(INDD(1841, 4), R0);
MOV(INDD(1846, 0), IMM(368031));
MOV(INDD(1846, 1), IMM(1849));
MOV(INDD(1846, 2), IMM(1851));
MOV(INDD(1846, 3), IMM(914));
MOV(R0, 0);MOV(INDD(1846, 4), R0);
MOV(INDD(1851, 0), IMM(368031));
MOV(INDD(1851, 1), IMM(1854));
MOV(INDD(1851, 2), IMM(1856));
MOV(INDD(1851, 3), IMM(918));
MOV(R0, 0);MOV(INDD(1851, 4), R0);
MOV(INDD(1856, 0), IMM(368031));
MOV(INDD(1856, 1), IMM(1859));
MOV(INDD(1856, 2), IMM(1861));
MOV(INDD(1856, 3), IMM(922));
MOV(R0, 0);MOV(INDD(1856, 4), R0);
MOV(INDD(1861, 0), IMM(368031));
MOV(INDD(1861, 1), IMM(1864));
MOV(INDD(1861, 2), IMM(1866));
MOV(INDD(1861, 3), IMM(929));
MOV(R0, 0);MOV(INDD(1861, 4), R0);
MOV(INDD(1866, 0), IMM(368031));
MOV(INDD(1866, 1), IMM(1869));
MOV(INDD(1866, 2), IMM(1871));
MOV(INDD(1866, 3), IMM(937));
MOV(R0, 0);MOV(INDD(1866, 4), R0);
MOV(INDD(1871, 0), IMM(368031));
MOV(INDD(1871, 1), IMM(1874));
MOV(INDD(1871, 2), IMM(1876));
MOV(INDD(1871, 3), IMM(944));
MOV(R0, 0);MOV(INDD(1871, 4), R0);
MOV(INDD(1876, 0), IMM(368031));
MOV(INDD(1876, 1), IMM(1879));
MOV(INDD(1876, 2), IMM(1881));
MOV(INDD(1876, 3), IMM(950));
MOV(R0, 0);MOV(INDD(1876, 4), R0);
MOV(INDD(1881, 0), IMM(368031));
MOV(INDD(1881, 1), IMM(1884));
MOV(INDD(1881, 2), IMM(1886));
MOV(INDD(1881, 3), IMM(956));
MOV(R0, 0);MOV(INDD(1881, 4), R0);
MOV(INDD(1886, 0), IMM(368031));
MOV(INDD(1886, 1), IMM(1889));
MOV(INDD(1886, 2), IMM(1891));
MOV(INDD(1886, 3), IMM(964));
MOV(R0, 0);MOV(INDD(1886, 4), R0);
MOV(INDD(1891, 0), IMM(368031));
MOV(INDD(1891, 1), IMM(1894));
MOV(INDD(1891, 2), IMM(1896));
MOV(INDD(1891, 3), IMM(969));
MOV(R0, 0);MOV(INDD(1891, 4), R0);
MOV(INDD(1896, 0), IMM(368031));
MOV(INDD(1896, 1), IMM(1899));
MOV(INDD(1896, 2), IMM(1901));
MOV(INDD(1896, 3), IMM(977));
MOV(R0, 0);MOV(INDD(1896, 4), R0);
MOV(INDD(1901, 0), IMM(368031));
MOV(INDD(1901, 1), IMM(1904));
MOV(INDD(1901, 2), IMM(1906));
MOV(INDD(1901, 3), IMM(984));
MOV(R0, 0);MOV(INDD(1901, 4), R0);
MOV(INDD(1906, 0), IMM(368031));
MOV(INDD(1906, 1), IMM(1909));
MOV(INDD(1906, 2), IMM(1911));
MOV(INDD(1906, 3), IMM(991));
MOV(R0, 0);MOV(INDD(1906, 4), R0);
MOV(INDD(1911, 0), IMM(368031));
MOV(INDD(1911, 1), IMM(1914));
MOV(INDD(1911, 2), IMM(1916));
MOV(INDD(1911, 3), IMM(998));
MOV(R0, 0);MOV(INDD(1911, 4), R0);
MOV(INDD(1916, 0), IMM(368031));
MOV(INDD(1916, 1), IMM(1919));
MOV(INDD(1916, 2), IMM(1921));
MOV(INDD(1916, 3), IMM(1004));
MOV(R0, 0);MOV(INDD(1916, 4), R0);
MOV(INDD(1921, 0), IMM(368031));
MOV(INDD(1921, 1), IMM(1924));
MOV(INDD(1921, 2), IMM(1926));
MOV(INDD(1921, 3), IMM(1010));
MOV(R0, 0);MOV(INDD(1921, 4), R0);
MOV(INDD(1926, 0), IMM(368031));
MOV(INDD(1926, 1), IMM(1929));
MOV(INDD(1926, 2), IMM(1931));
MOV(INDD(1926, 3), IMM(1016));
MOV(R0, 0);MOV(INDD(1926, 4), R0);
MOV(INDD(1931, 0), IMM(368031));
MOV(INDD(1931, 1), IMM(1934));
MOV(INDD(1931, 2), IMM(1936));
MOV(INDD(1931, 3), IMM(1022));
MOV(R0, 0);MOV(INDD(1931, 4), R0);
MOV(INDD(1936, 0), IMM(368031));
MOV(INDD(1936, 1), IMM(1939));
MOV(INDD(1936, 2), IMM(1941));
MOV(INDD(1936, 3), IMM(1026));
MOV(R0, 0);MOV(INDD(1936, 4), R0);
MOV(INDD(1941, 0), IMM(368031));
MOV(INDD(1941, 1), IMM(1944));
MOV(INDD(1941, 2), IMM(1946));
MOV(INDD(1941, 3), IMM(1031));
PUSH(LABEL(SET_CAR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1941, 4), R0);
MOV(INDD(1946, 0), IMM(368031));
MOV(INDD(1946, 1), IMM(1949));
MOV(INDD(1946, 2), IMM(1951));
MOV(INDD(1946, 3), IMM(1041));
PUSH(LABEL(SET_CDR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1946, 4), R0);
MOV(INDD(1951, 0), IMM(368031));
MOV(INDD(1951, 1), IMM(1954));
MOV(INDD(1951, 2), IMM(1956));
MOV(INDD(1951, 3), IMM(1051));
PUSH(LABEL(EQ));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1951, 4), R0);
MOV(INDD(1956, 0), IMM(368031));
MOV(INDD(1956, 1), IMM(1959));
MOV(INDD(1956, 2), IMM(1961));
MOV(INDD(1956, 3), IMM(1056));
PUSH(LABEL(STRING_TO_SYMBOL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1956, 4), R0);
MOV(INDD(1961, 0), IMM(368031));
MOV(INDD(1961, 1), IMM(1964));
MOV(INDD(1961, 2), IMM(1966));
MOV(INDD(1961, 3), IMM(1072));
PUSH(LABEL(SYMBOL_TO_STRING));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1961, 4), R0);
MOV(INDD(1966, 0), IMM(368031));
MOV(INDD(1966, 1), IMM(1969));
MOV(INDD(1966, 2), IMM(1971));
MOV(INDD(1966, 3), IMM(1088));
MOV(R0, 0);MOV(INDD(1966, 4), R0);
MOV(INDD(1971, 0), IMM(368031));
MOV(INDD(1971, 1), IMM(1974));
MOV(INDD(1971, 2), IMM(1976));
MOV(INDD(1971, 3), IMM(1096));
PUSH(LABEL(APPLY_TC));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1971, 4), R0);
MOV(INDD(1976, 0), IMM(368031));
MOV(INDD(1976, 1), IMM(1979));
MOV(INDD(1976, 2), IMM(1981));
MOV(INDD(1976, 3), IMM(1103));
MOV(R0, 0);MOV(INDD(1976, 4), R0);
MOV(INDD(1981, 0), IMM(368031));
MOV(INDD(1981, 1), IMM(1984));
MOV(INDD(1981, 2), IMM(1986));
MOV(INDD(1981, 3), IMM(1111));
MOV(R0, 0);MOV(INDD(1981, 4), R0);
MOV(INDD(1986, 0), IMM(368031));
MOV(INDD(1986, 1), IMM(1989));
MOV(INDD(1986, 2), IMM(1991));
MOV(INDD(1986, 3), IMM(1117));
PUSH(LABEL(CDR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1986, 4), R0);
MOV(INDD(1991, 0), IMM(368031));
MOV(INDD(1991, 1), IMM(1994));
MOV(INDD(1991, 2), IMM(1996));
MOV(INDD(1991, 3), IMM(1122));
PUSH(LABEL(CAR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1991, 4), R0);
MOV(INDD(1996, 0), IMM(368031));
MOV(INDD(1996, 1), IMM(1999));
MOV(INDD(1996, 2), IMM(2001));
MOV(INDD(1996, 3), IMM(1127));
PUSH(LABEL(CONS));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(1996, 4), R0);
MOV(INDD(2001, 0), IMM(368031));
MOV(INDD(2001, 1), IMM(2004));
MOV(INDD(2001, 2), IMM(2006));
MOV(INDD(2001, 3), IMM(1133));
PUSH(LABEL(MAKE_VECTOR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2001, 4), R0);
MOV(INDD(2006, 0), IMM(368031));
MOV(INDD(2006, 1), IMM(2009));
MOV(INDD(2006, 2), IMM(2011));
MOV(INDD(2006, 3), IMM(1146));
PUSH(LABEL(VECTOR_SET));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2006, 4), R0);
MOV(INDD(2011, 0), IMM(368031));
MOV(INDD(2011, 1), IMM(2014));
MOV(INDD(2011, 2), IMM(2016));
MOV(INDD(2011, 3), IMM(1159));
PUSH(LABEL(VECTOR_REF));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2011, 4), R0);
MOV(INDD(2016, 0), IMM(368031));
MOV(INDD(2016, 1), IMM(2019));
MOV(INDD(2016, 2), IMM(2021));
MOV(INDD(2016, 3), IMM(1171));
PUSH(LABEL(VECTOR_LENGTH));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2016, 4), R0);
MOV(INDD(2021, 0), IMM(368031));
MOV(INDD(2021, 1), IMM(2024));
MOV(INDD(2021, 2), IMM(2026));
MOV(INDD(2021, 3), IMM(1186));
PUSH(LABEL(MAKE_STRING));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2021, 4), R0);
MOV(INDD(2026, 0), IMM(368031));
MOV(INDD(2026, 1), IMM(2029));
MOV(INDD(2026, 2), IMM(2031));
MOV(INDD(2026, 3), IMM(1199));
PUSH(LABEL(STRING_SET));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2026, 4), R0);
MOV(INDD(2031, 0), IMM(368031));
MOV(INDD(2031, 1), IMM(2034));
MOV(INDD(2031, 2), IMM(2036));
MOV(INDD(2031, 3), IMM(1212));
PUSH(LABEL(STRING_REF));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2031, 4), R0);
MOV(INDD(2036, 0), IMM(368031));
MOV(INDD(2036, 1), IMM(2039));
MOV(INDD(2036, 2), IMM(2041));
MOV(INDD(2036, 3), IMM(1224));
PUSH(LABEL(STRING_LENGTH));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2036, 4), R0);
MOV(INDD(2041, 0), IMM(368031));
MOV(INDD(2041, 1), IMM(2044));
MOV(INDD(2041, 2), IMM(2046));
MOV(INDD(2041, 3), IMM(1239));
PUSH(LABEL(INTEGER_TO_CHAR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2041, 4), R0);
MOV(INDD(2046, 0), IMM(368031));
MOV(INDD(2046, 1), IMM(2049));
MOV(INDD(2046, 2), IMM(2051));
MOV(INDD(2046, 3), IMM(1254));
PUSH(LABEL(CHAR_TO_INTEGER));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2046, 4), R0);
MOV(INDD(2051, 0), IMM(368031));
MOV(INDD(2051, 1), IMM(2054));
MOV(INDD(2051, 2), IMM(2056));
MOV(INDD(2051, 3), IMM(1269));
PUSH(LABEL(VARIADIC_EQUAL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2051, 4), R0);
MOV(INDD(2056, 0), IMM(368031));
MOV(INDD(2056, 1), IMM(2059));
MOV(INDD(2056, 2), IMM(2061));
MOV(INDD(2056, 3), IMM(1272));
PUSH(LABEL(VARIADIC_GT));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2056, 4), R0);
MOV(INDD(2061, 0), IMM(368031));
MOV(INDD(2061, 1), IMM(2064));
MOV(INDD(2061, 2), IMM(2066));
MOV(INDD(2061, 3), IMM(1275));
PUSH(LABEL(VARIADIC_LT));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2061, 4), R0);
MOV(INDD(2066, 0), IMM(368031));
MOV(INDD(2066, 1), IMM(2069));
MOV(INDD(2066, 2), IMM(2071));
MOV(INDD(2066, 3), IMM(1278));
PUSH(LABEL(VARIADIC_DIV));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2066, 4), R0);
MOV(INDD(2071, 0), IMM(368031));
MOV(INDD(2071, 1), IMM(2074));
MOV(INDD(2071, 2), IMM(2076));
MOV(INDD(2071, 3), IMM(1281));
PUSH(LABEL(VARIADIC_MUL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2071, 4), R0);
MOV(INDD(2076, 0), IMM(368031));
MOV(INDD(2076, 1), IMM(2079));
MOV(INDD(2076, 2), IMM(2081));
MOV(INDD(2076, 3), IMM(1284));
PUSH(LABEL(VARIADIC_MINUS));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2076, 4), R0);
MOV(INDD(2081, 0), IMM(368031));
MOV(INDD(2081, 1), IMM(2084));
MOV(INDD(2081, 2), IMM(2086));
MOV(INDD(2081, 3), IMM(1287));
PUSH(LABEL(VARIADIC_PLUS));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2081, 4), R0);
MOV(INDD(2086, 0), IMM(368031));
MOV(INDD(2086, 1), IMM(2089));
MOV(INDD(2086, 2), IMM(2091));
MOV(INDD(2086, 3), IMM(1290));
PUSH(LABEL(IS_PROCEDURE));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2086, 4), R0);
MOV(INDD(2091, 0), IMM(368031));
MOV(INDD(2091, 1), IMM(2094));
MOV(INDD(2091, 2), IMM(2096));
MOV(INDD(2091, 3), IMM(1302));
PUSH(LABEL(IS_VECTOR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2091, 4), R0);
MOV(INDD(2096, 0), IMM(368031));
MOV(INDD(2096, 1), IMM(2099));
MOV(INDD(2096, 2), IMM(2101));
MOV(INDD(2096, 3), IMM(1311));
PUSH(LABEL(IS_ZERO_MY));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2096, 4), R0);
MOV(INDD(2101, 0), IMM(368031));
MOV(INDD(2101, 1), IMM(2104));
MOV(INDD(2101, 2), IMM(2106));
MOV(INDD(2101, 3), IMM(1318));
PUSH(LABEL(IS_SYMBOL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2101, 4), R0);
MOV(INDD(2106, 0), IMM(368031));
MOV(INDD(2106, 1), IMM(2109));
MOV(INDD(2106, 2), IMM(2111));
MOV(INDD(2106, 3), IMM(1327));
PUSH(LABEL(IS_STRING));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2106, 4), R0);
MOV(INDD(2111, 0), IMM(368031));
MOV(INDD(2111, 1), IMM(2114));
MOV(INDD(2111, 2), IMM(2116));
MOV(INDD(2111, 3), IMM(1336));
PUSH(LABEL(IS_PAIR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2111, 4), R0);
MOV(INDD(2116, 0), IMM(368031));
MOV(INDD(2116, 1), IMM(2119));
MOV(INDD(2116, 2), IMM(2121));
MOV(INDD(2116, 3), IMM(1343));
PUSH(LABEL(IS_NULL));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2116, 4), R0);
MOV(INDD(2121, 0), IMM(368031));
MOV(INDD(2121, 1), IMM(2124));
MOV(INDD(2121, 2), IMM(2126));
MOV(INDD(2121, 3), IMM(1350));
PUSH(LABEL(IS_CHAR));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2121, 4), R0);
MOV(INDD(2126, 0), IMM(368031));
MOV(INDD(2126, 1), IMM(2129));
MOV(INDD(2126, 2), IMM(2131));
MOV(INDD(2126, 3), IMM(1357));
PUSH(LABEL(IS_BOOLEAN));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2126, 4), R0);
MOV(INDD(2131, 0), IMM(368031));
MOV(INDD(2131, 1), IMM(2134));
MOV(INDD(2131, 2), IMM(2136));
MOV(INDD(2131, 3), IMM(1367));
PUSH(LABEL(IS_INTEGER));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2131, 4), R0);
MOV(INDD(2136, 0), IMM(368031));
MOV(INDD(2136, 1), IMM(2139));
MOV(INDD(2136, 2), IMM(2141));
MOV(INDD(2136, 3), IMM(1377));
PUSH(LABEL(IS_NUMBER));
PUSH(IMM(0));
CALL(MAKE_SOB_CLOSURE);
DROP(IMM(2));
MOV(INDD(2136, 4), R0);
MOV(INDD(2136, 2), 2);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop146:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit146);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop146);
L_env_loop_exit146: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop146:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit146);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop146);
L_params_loop_exit146: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body146));
MOV(R0,R10);
JUMP(L_closure_end146);
L_closure_body146:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop147:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit147);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop147);
L_env_loop_exit147: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop147:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit147);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop147);
L_params_loop_exit147: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body147));
MOV(R0,R10);
JUMP(L_closure_end147);
L_closure_body147:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop148:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit148);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop148);
L_env_loop_exit148: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop148:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit148);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop148);
L_params_loop_exit148: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body148));
MOV(R0,R10);
JUMP(L_closure_end148);
L_closure_body148:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy116:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit116);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy116);
L_tc_copy_exit116:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end148:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy117:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit117);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy117);
L_tc_copy_exit117:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end147:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop149:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit149);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop149);
L_env_loop_exit149: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop149:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit149);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop149);
L_params_loop_exit149: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body149));
MOV(R0,R10);
JUMP(L_closure_end149);
L_closure_body149:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop150:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit150);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop150);
L_env_loop_exit150: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop150:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit150);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop150);
L_params_loop_exit150: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body150));
MOV(R0,R10);
JUMP(L_closure_end150);
L_closure_body150:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy118:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit118);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy118);
L_tc_copy_exit118:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end150:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy119:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit119);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy119);
L_tc_copy_exit119:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end149:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy120:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit120);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy120);
L_tc_copy_exit120:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end146:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop151:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit151);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop151);
L_env_loop_exit151: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop151:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit151);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop151);
L_params_loop_exit151: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body151));
MOV(R0,R10);
JUMP(L_closure_end151);
L_closure_body151:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop152:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit152);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop152);
L_env_loop_exit152: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop152:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit152);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop152);
L_params_loop_exit152: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body152));
MOV(R0,R10);
JUMP(L_closure_end152);
L_closure_body152:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop153:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit153);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop153);
L_env_loop_exit153: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop153:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit153);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop153);
L_params_loop_exit153: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body153));
MOV(R0,R10);
JUMP(L_closure_end153);
L_closure_body153:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else60);
/* In consts .. */
MOV(R0,IMM(2));
JUMP(L_if3_exit60);
L_if3_else60:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in pvar */
MOV(R0, FPARG(2));
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2000));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy121:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit121);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy121);
L_tc_copy_exit121:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit60:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end153:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end152:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in pvar */
MOV(R0, FPARG(2));
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop154:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit154);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop154);
L_env_loop_exit154: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop154:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit154);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop154);
L_params_loop_exit154: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body154));
MOV(R0,R10);
JUMP(L_closure_end154);
L_closure_body154:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop155:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit155);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop155);
L_env_loop_exit155: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop155:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit155);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop155);
L_params_loop_exit155: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body155));
MOV(R0,R10);
JUMP(L_closure_end155);
L_closure_body155:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop156:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit156);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop156);
L_env_loop_exit156: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop156:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit156);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop156);
L_params_loop_exit156: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body156));
MOV(R0,R10);
JUMP(L_closure_end156);
L_closure_body156:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else61);
/* In consts .. */
MOV(R0,IMM(2));
JUMP(L_if3_exit61);
L_if3_else61:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1975));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2000));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy122:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit122);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy122);
L_tc_copy_exit122:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit61:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end156:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end155:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop157:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit157);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop157);
L_env_loop_exit157: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop157:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit157);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop157);
L_params_loop_exit157: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body157));
MOV(R0,R10);
JUMP(L_closure_end157);
L_closure_body157:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop158:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit158);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop158);
L_env_loop_exit158: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop158:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit158);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop158);
L_params_loop_exit158: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body158));
MOV(R0,R10);
JUMP(L_closure_end158);
L_closure_body158:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy6:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit6);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy6);
L_opt_copy_exit6:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy6:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit6);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy6);
L_opt_2copy_exit6:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy123:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit123);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy123);
L_tc_copy_exit123:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end158:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end157:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy124:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit124);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy124);
L_tc_copy_exit124:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end154:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy125:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit125);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy125);
L_tc_copy_exit125:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end151:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1940), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop140:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit140);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop140);
L_env_loop_exit140: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop140:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit140);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop140);
L_params_loop_exit140: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body140));
MOV(R0,R10);
JUMP(L_closure_end140);
L_closure_body140:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop141:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit141);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop141);
L_env_loop_exit141: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop141:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit141);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop141);
L_params_loop_exit141: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body141));
MOV(R0,R10);
JUMP(L_closure_end141);
L_closure_body141:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop142:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit142);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop142);
L_env_loop_exit142: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop142:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit142);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop142);
L_params_loop_exit142: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body142));
MOV(R0,R10);
JUMP(L_closure_end142);
L_closure_body142:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop143:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit143);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop143);
L_env_loop_exit143: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop143:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit143);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop143);
L_params_loop_exit143: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body143));
MOV(R0,R10);
JUMP(L_closure_end143);
L_closure_body143:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(5));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<4; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop144:
CMP(R5,IMM(4));
JUMP_GE(L_env_loop_exit144);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop144);
L_env_loop_exit144: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop144:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit144);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop144);
L_params_loop_exit144: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body144));
MOV(R0,R10);
JUMP(L_closure_end144);
L_closure_body144:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1975));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1975));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy112:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit112);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy112);
L_tc_copy_exit112:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end144:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end143:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1940));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1975));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy113:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit113);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy113);
L_tc_copy_exit113:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end142:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end141:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1940));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop145:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit145);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop145);
L_env_loop_exit145: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop145:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit145);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop145);
L_params_loop_exit145: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body145));
MOV(R0,R10);
JUMP(L_closure_end145);
L_closure_body145:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1975));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy114:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit114);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy114);
L_tc_copy_exit114:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end145:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy115:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit115);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy115);
L_tc_copy_exit115:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end140:

MOV(ADDR(1935), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop139:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit139);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop139);
L_env_loop_exit139: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop139:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit139);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop139);
L_params_loop_exit139: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body139));
MOV(R0,R10);
JUMP(L_closure_end139);
L_closure_body139:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2085));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy111:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit111);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy111);
L_tc_copy_exit111:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end139:

MOV(ADDR(1930), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop138:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit138);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop138);
L_env_loop_exit138: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop138:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit138);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop138);
L_params_loop_exit138: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body138));
MOV(R0,R10);
JUMP(L_closure_end138);
L_closure_body138:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2080));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy110:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit110);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy110);
L_tc_copy_exit110:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end138:

MOV(ADDR(1925), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop137:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit137);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop137);
L_env_loop_exit137: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop137:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit137);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop137);
L_params_loop_exit137: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body137));
MOV(R0,R10);
JUMP(L_closure_end137);
L_closure_body137:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2075));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy109:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit109);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy109);
L_tc_copy_exit109:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end137:

MOV(ADDR(1920), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop136:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit136);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop136);
L_env_loop_exit136: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop136:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit136);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop136);
L_params_loop_exit136: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body136));
MOV(R0,R10);
JUMP(L_closure_end136);
L_closure_body136:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2070));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy108:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit108);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy108);
L_tc_copy_exit108:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end136:

MOV(ADDR(1915), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop135:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit135);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop135);
L_env_loop_exit135: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop135:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit135);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop135);
L_params_loop_exit135: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body135));
MOV(R0,R10);
JUMP(L_closure_end135);
L_closure_body135:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2065));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy107:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit107);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy107);
L_tc_copy_exit107:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end135:

MOV(ADDR(1910), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop134:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit134);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop134);
L_env_loop_exit134: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop134:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit134);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop134);
L_params_loop_exit134: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body134));
MOV(R0,R10);
JUMP(L_closure_end134);
L_closure_body134:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2060));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy106:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit106);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy106);
L_tc_copy_exit106:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end134:

MOV(ADDR(1905), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop133:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit133);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop133);
L_env_loop_exit133: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop133:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit133);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop133);
L_params_loop_exit133: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body133));
MOV(R0,R10);
JUMP(L_closure_end133);
L_closure_body133:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2055));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy105:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit105);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy105);
L_tc_copy_exit105:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end133:

MOV(ADDR(1900), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop132:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit132);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop132);
L_env_loop_exit132: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop132:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit132);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop132);
L_params_loop_exit132: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body132));
MOV(R0,R10);
JUMP(L_closure_end132);
L_closure_body132:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1905));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1890));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy104:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit104);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy104);
L_tc_copy_exit104:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end132:

MOV(ADDR(1895), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop131:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit131);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop131);
L_env_loop_exit131: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop131:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit131);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop131);
L_params_loop_exit131: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body131));
MOV(R0,R10);
JUMP(L_closure_end131);
L_closure_body131:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1910));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1890));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy103:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit103);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy103);
L_tc_copy_exit103:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end131:

MOV(ADDR(1885), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop130:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit130);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop130);
L_env_loop_exit130: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop130:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit130);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop130);
L_params_loop_exit130: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body130));
MOV(R0,R10);
JUMP(L_closure_end130);
L_closure_body130:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1930));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy102:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit102);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy102);
L_tc_copy_exit102:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end130:

MOV(ADDR(1880), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop129:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit129);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop129);
L_env_loop_exit129: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop129:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit129);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop129);
L_params_loop_exit129: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body129));
MOV(R0,R10);
JUMP(L_closure_end129);
L_closure_body129:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1925));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy101:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit101);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy101);
L_tc_copy_exit101:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end129:

MOV(ADDR(1875), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop128:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit128);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop128);
L_env_loop_exit128: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop128:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit128);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop128);
L_params_loop_exit128: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body128));
MOV(R0,R10);
JUMP(L_closure_end128);
L_closure_body128:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* in pvar */
MOV(R0, FPARG(2));

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else59);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit59);
L_if3_else59:
/* In consts .. */
MOV(R0,IMM(5));
L_if3_exit59:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end128:

MOV(ADDR(1890), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop124:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit124);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop124);
L_env_loop_exit124: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop124:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit124);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop124);
L_params_loop_exit124: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body124));
MOV(R0,R10);
JUMP(L_closure_end124);
L_closure_body124:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy5:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit5);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy5);
L_opt_copy_exit5:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy5:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit5);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy5);
L_opt_2copy_exit5:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop126:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit126);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop126);
L_env_loop_exit126: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop126:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit126);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop126);
L_params_loop_exit126: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body126));
MOV(R0,R10);
JUMP(L_closure_end126);
L_closure_body126:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop127:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit127);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop127);
L_env_loop_exit127: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop127:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit127);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop127);
L_params_loop_exit127: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body127));
MOV(R0,R10);
JUMP(L_closure_end127);
L_closure_body127:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2115));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else58);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1940));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1975));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit5);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1940));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy99:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit99);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy99);
L_tc_copy_exit99:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit5);
L_or_exit5:

JUMP(L_if3_exit58);
L_if3_else58:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit58:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end127:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end126:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop125:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit125);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop125);
L_env_loop_exit125: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop125:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit125);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop125);
L_params_loop_exit125: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body125));
MOV(R0,R10);
JUMP(L_closure_end125);
L_closure_body125:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy98:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit98);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy98);
L_tc_copy_exit98:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end125:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy100:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit100);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy100);
L_tc_copy_exit100:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end124:

MOV(ADDR(1870), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop120:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit120);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop120);
L_env_loop_exit120: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop120:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit120);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop120);
L_params_loop_exit120: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body120));
MOV(R0,R10);
JUMP(L_closure_end120);
L_closure_body120:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy4:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit4);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy4);
L_opt_copy_exit4:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy4:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit4);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy4);
L_opt_2copy_exit4:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop122:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit122);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop122);
L_env_loop_exit122: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop122:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit122);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop122);
L_params_loop_exit122: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body122));
MOV(R0,R10);
JUMP(L_closure_end122);
L_closure_body122:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop123:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit123);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop123);
L_env_loop_exit123: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop123:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit123);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop123);
L_params_loop_exit123: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body123));
MOV(R0,R10);
JUMP(L_closure_end123);
L_closure_body123:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit4);
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1940));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1975));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else57);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1940));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy96:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit96);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy96);
L_tc_copy_exit96:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit57);
L_if3_else57:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit57:

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit4);
L_or_exit4:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end123:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end122:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop121:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit121);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop121);
L_env_loop_exit121: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop121:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit121);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop121);
L_params_loop_exit121: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body121));
MOV(R0,R10);
JUMP(L_closure_end121);
L_closure_body121:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy95:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit95);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy95);
L_tc_copy_exit95:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end121:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy97:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit97);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy97);
L_tc_copy_exit97:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end120:

MOV(ADDR(1865), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop115:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit115);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop115);
L_env_loop_exit115: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop115:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit115);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop115);
L_params_loop_exit115: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body115));
MOV(R0,R10);
JUMP(L_closure_end115);
L_closure_body115:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop118:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit118);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop118);
L_env_loop_exit118: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop118:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit118);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop118);
L_params_loop_exit118: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body118));
MOV(R0,R10);
JUMP(L_closure_end118);
L_closure_body118:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop119:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit119);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop119);
L_env_loop_exit119: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop119:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit119);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop119);
L_params_loop_exit119: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body119));
MOV(R0,R10);
JUMP(L_closure_end119);
L_closure_body119:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit3);
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else56);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy93:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit93);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy93);
L_tc_copy_exit93:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit56);
L_if3_else56:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit56:

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit3);
L_or_exit3:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end119:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end118:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop116:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit116);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop116);
L_env_loop_exit116: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop116:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit116);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop116);
L_params_loop_exit116: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body116));
MOV(R0,R10);
JUMP(L_closure_end116);
L_closure_body116:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop117:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit117);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop117);
L_env_loop_exit117: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop117:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit117);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop117);
L_params_loop_exit117: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body117));
MOV(R0,R10);
JUMP(L_closure_end117);
L_closure_body117:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy3:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit3);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy3);
L_opt_copy_exit3:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy3:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit3);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy3);
L_opt_2copy_exit3:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy92:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit92);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy92);
L_tc_copy_exit92:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end117:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end116:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy94:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit94);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy94);
L_tc_copy_exit94:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end115:

MOV(ADDR(1860), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1895));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1855), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1885));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1850), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop112:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit112);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop112);
L_env_loop_exit112: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop112:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit112);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop112);
L_params_loop_exit112: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body112));
MOV(R0,R10);
JUMP(L_closure_end112);
L_closure_body112:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop113:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit113);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop113);
L_env_loop_exit113: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop113:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit113);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop113);
L_params_loop_exit113: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body113));
MOV(R0,R10);
JUMP(L_closure_end113);
L_closure_body113:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit2);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop114:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit114);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop114);
L_env_loop_exit114: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop114:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit114);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop114);
L_params_loop_exit114: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body114));
MOV(R0,R10);
JUMP(L_closure_end114);
L_closure_body114:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2055));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1890));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy90:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit90);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy90);
L_tc_copy_exit90:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end114:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1865));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else55);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy91:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit91);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy91);
L_tc_copy_exit91:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit55);
L_if3_else55:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit55:

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit2);
L_or_exit2:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end113:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end112:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop110:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit110);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop110);
L_env_loop_exit110: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop110:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit110);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop110);
L_params_loop_exit110: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body110));
MOV(R0,R10);
JUMP(L_closure_end110);
L_closure_body110:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop111:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit111);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop111);
L_env_loop_exit111: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop111:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit111);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop111);
L_params_loop_exit111: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body111));
MOV(R0,R10);
JUMP(L_closure_end111);
L_closure_body111:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy89:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit89);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy89);
L_tc_copy_exit89:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end111:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end110:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1845), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop106:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit106);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop106);
L_env_loop_exit106: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop106:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit106);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop106);
L_params_loop_exit106: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body106));
MOV(R0,R10);
JUMP(L_closure_end106);
L_closure_body106:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop108:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit108);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop108);
L_env_loop_exit108: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop108:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit108);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop108);
L_params_loop_exit108: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body108));
MOV(R0,R10);
JUMP(L_closure_end108);
L_closure_body108:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop109:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit109);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop109);
L_env_loop_exit109: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop109:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit109);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop109);
L_params_loop_exit109: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body109));
MOV(R0,R10);
JUMP(L_closure_end109);
L_closure_body109:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else54);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

JUMP(L_if3_exit54);
L_if3_else54:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy87:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit87);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy87);
L_tc_copy_exit87:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit54:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end109:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end108:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop107:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit107);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop107);
L_env_loop_exit107: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop107:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit107);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop107);
L_params_loop_exit107: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body107));
MOV(R0,R10);
JUMP(L_closure_end107);
L_closure_body107:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(2)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy86:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit86);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy86);
L_tc_copy_exit86:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end107:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy88:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit88);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy88);
L_tc_copy_exit88:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end106:

MOV(ADDR(1840), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop101:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit101);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop101);
L_env_loop_exit101: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop101:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit101);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop101);
L_params_loop_exit101: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body101));
MOV(R0,R10);
JUMP(L_closure_end101);
L_closure_body101:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop102:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit102);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop102);
L_env_loop_exit102: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop102:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit102);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop102);
L_params_loop_exit102: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body102));
MOV(R0,R10);
JUMP(L_closure_end102);
L_closure_body102:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy84:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit84);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy84);
L_tc_copy_exit84:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end102:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end101:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop103:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit103);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop103);
L_env_loop_exit103: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop103:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit103);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop103);
L_params_loop_exit103: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body103));
MOV(R0,R10);
JUMP(L_closure_end103);
L_closure_body103:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop104:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit104);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop104);
L_env_loop_exit104: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop104:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit104);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop104);
L_params_loop_exit104: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body104));
MOV(R0,R10);
JUMP(L_closure_end104);
L_closure_body104:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop105:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit105);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop105);
L_env_loop_exit105: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop105:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit105);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop105);
L_params_loop_exit105: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body105));
MOV(R0,R10);
JUMP(L_closure_end105);
L_closure_body105:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* in pvar */
MOV(R0, FPARG(2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end105:

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1840));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy85:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit85);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy85);
L_tc_copy_exit85:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end104:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end103:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1835), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1830), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1825), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1820), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1815), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1830));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1810), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1825));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1805), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1820));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1800), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1815));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1795), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1830));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1790), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1825));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1785), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1820));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1780), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1815));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1775), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1810));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1770), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1805));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1765), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1800));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1760), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1795));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1755), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1790));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1750), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1785));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1745), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1780));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1740), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1775));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1735), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1810));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1730), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1805));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1725), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1800));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1720), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1795));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1715), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1790));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1710), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1785));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1705), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1780));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1700), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1775));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1695), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop96:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit96);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop96);
L_env_loop_exit96: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop96:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit96);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop96);
L_params_loop_exit96: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body96));
MOV(R0,R10);
JUMP(L_closure_end96);
L_closure_body96:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop99:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit99);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop99);
L_env_loop_exit99: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop99:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit99);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop99);
L_params_loop_exit99: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body99));
MOV(R0,R10);
JUMP(L_closure_end99);
L_closure_body99:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop100:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit100);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop100);
L_env_loop_exit100: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop100:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit100);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop100);
L_params_loop_exit100: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body100));
MOV(R0,R10);
JUMP(L_closure_end100);
L_closure_body100:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else53);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

JUMP(L_if3_exit53);
L_if3_else53:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy82:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit82);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy82);
L_tc_copy_exit82:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit53:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end100:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end99:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop97:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit97);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop97);
L_env_loop_exit97: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop97:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit97);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop97);
L_params_loop_exit97: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body97));
MOV(R0,R10);
JUMP(L_closure_end97);
L_closure_body97:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop98:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit98);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop98);
L_env_loop_exit98: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop98:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit98);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop98);
L_params_loop_exit98: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body98));
MOV(R0,R10);
JUMP(L_closure_end98);
L_closure_body98:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy81:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit81);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy81);
L_tc_copy_exit81:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end98:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end97:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy83:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit83);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy83);
L_tc_copy_exit83:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end96:

MOV(ADDR(1690), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop91:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit91);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop91);
L_env_loop_exit91: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop91:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit91);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop91);
L_params_loop_exit91: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body91));
MOV(R0,R10);
JUMP(L_closure_end91);
L_closure_body91:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop94:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit94);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop94);
L_env_loop_exit94: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop94:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit94);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop94);
L_params_loop_exit94: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body94));
MOV(R0,R10);
JUMP(L_closure_end94);
L_closure_body94:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop95:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit95);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop95);
L_env_loop_exit95: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop95:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit95);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop95);
L_params_loop_exit95: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body95));
MOV(R0,R10);
JUMP(L_closure_end95);
L_closure_body95:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else52);
/* in pvar */
MOV(R0, FPARG(2));

JUMP(L_if3_exit52);
L_if3_else52:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy79:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit79);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy79);
L_tc_copy_exit79:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit52:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end95:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end94:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop92:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit92);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop92);
L_env_loop_exit92: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop92:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit92);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop92);
L_params_loop_exit92: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body92));
MOV(R0,R10);
JUMP(L_closure_end92);
L_closure_body92:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop93:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit93);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop93);
L_env_loop_exit93: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop93:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit93);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop93);
L_params_loop_exit93: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body93));
MOV(R0,R10);
JUMP(L_closure_end93);
L_closure_body93:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else51);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

JUMP(L_if3_exit51);
L_if3_else51:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy78:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit78);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy78);
L_tc_copy_exit78:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit51:

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end93:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end92:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy80:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit80);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy80);
L_tc_copy_exit80:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end91:

MOV(ADDR(1685), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop89:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit89);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop89);
L_env_loop_exit89: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop89:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit89);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop89);
L_params_loop_exit89: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body89));
MOV(R0,R10);
JUMP(L_closure_end89);
L_closure_body89:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop90:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit90);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop90);
L_env_loop_exit90: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop90:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit90);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop90);
L_params_loop_exit90: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body90));
MOV(R0,R10);
JUMP(L_closure_end90);
L_closure_body90:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2050));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2050));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy77:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit77);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy77);
L_tc_copy_exit77:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end90:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end89:

MOV(ADDR(1680), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1900));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1680));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1675), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1895));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1680));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1670), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1910));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1680));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1665), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1885));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1680));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1660), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1905));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1680));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1655), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop88:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit88);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop88);
L_env_loop_exit88: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop88:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit88);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop88);
L_params_loop_exit88: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body88));
MOV(R0,R10);
JUMP(L_closure_end88);
L_closure_body88:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* In consts .. */
MOV(R0,IMM(2173));
PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1670));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else50);
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2171));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1670));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy76:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit76);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy76);
L_tc_copy_exit76:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit50);
L_if3_else50:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit50:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end88:

MOV(ADDR(1650), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop87:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit87);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop87);
L_env_loop_exit87: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop87:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit87);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop87);
L_params_loop_exit87: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body87));
MOV(R0,R10);
JUMP(L_closure_end87);
L_closure_body87:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* In consts .. */
MOV(R0,IMM(2169));
PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1670));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else49);
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2167));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1670));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy75:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit75);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy75);
L_tc_copy_exit75:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit49);
L_if3_else49:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit49:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end87:

MOV(ADDR(1645), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2173));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2050));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2169));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2050));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2080));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop85:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit85);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop85);
L_env_loop_exit85: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop85:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit85);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop85);
L_params_loop_exit85: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body85));
MOV(R0,R10);
JUMP(L_closure_end85);
L_closure_body85:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop86:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit86);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop86);
L_env_loop_exit86: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop86:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit86);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop86);
L_params_loop_exit86: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body86));
MOV(R0,R10);
JUMP(L_closure_end86);
L_closure_body86:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1645));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else48);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2050));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2080));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2045));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy74:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit74);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy74);
L_tc_copy_exit74:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit48);
L_if3_else48:
/* in pvar */
MOV(R0, FPARG(2));

L_if3_exit48:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end86:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end85:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1640), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2173));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2050));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2169));
PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2050));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2080));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop83:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit83);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop83);
L_env_loop_exit83: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop83:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit83);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop83);
L_params_loop_exit83: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body83));
MOV(R0,R10);
JUMP(L_closure_end83);
L_closure_body83:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop84:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit84);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop84);
L_env_loop_exit84: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop84:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit84);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop84);
L_params_loop_exit84: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body84));
MOV(R0,R10);
JUMP(L_closure_end84);
L_closure_body84:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1650));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else47);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2050));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2085));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2045));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy73:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit73);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy73);
L_tc_copy_exit73:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit47);
L_if3_else47:
/* in pvar */
MOV(R0, FPARG(2));

L_if3_exit47:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end84:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end83:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1635), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop82:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit82);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop82);
L_env_loop_exit82: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop82:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit82);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop82);
L_params_loop_exit82: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body82));
MOV(R0,R10);
JUMP(L_closure_end82);
L_closure_body82:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1640));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1640));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1670));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy72:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit72);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy72);
L_tc_copy_exit72:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end82:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1630), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop81:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit81);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop81);
L_env_loop_exit81: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop81:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit81);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop81);
L_params_loop_exit81: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body81));
MOV(R0,R10);
JUMP(L_closure_end81);
L_closure_body81:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1640));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1640));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1665));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy71:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit71);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy71);
L_tc_copy_exit71:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end81:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1625), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop80:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit80);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop80);
L_env_loop_exit80: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop80:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit80);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop80);
L_params_loop_exit80: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body80));
MOV(R0,R10);
JUMP(L_closure_end80);
L_closure_body80:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1640));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1640));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1675));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy70:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit70);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy70);
L_tc_copy_exit70:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end80:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1620), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop79:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit79);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop79);
L_env_loop_exit79: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop79:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit79);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop79);
L_params_loop_exit79: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body79));
MOV(R0,R10);
JUMP(L_closure_end79);
L_closure_body79:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1640));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1640));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1655));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy69:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit69);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy69);
L_tc_copy_exit69:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end79:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1615), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop78:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit78);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop78);
L_env_loop_exit78: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop78:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit78);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop78);
L_params_loop_exit78: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body78));
MOV(R0,R10);
JUMP(L_closure_end78);
L_closure_body78:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1640));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1640));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1660));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy68:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit68);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy68);
L_tc_copy_exit68:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end78:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1610), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop77:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit77);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop77);
L_env_loop_exit77: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop77:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit77);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop77);
L_params_loop_exit77: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body77));
MOV(R0,R10);
JUMP(L_closure_end77);
L_closure_body77:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1595));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1640));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1940));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1600));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy67:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit67);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy67);
L_tc_copy_exit67:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end77:

MOV(ADDR(1605), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop76:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit76);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop76);
L_env_loop_exit76: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop76:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit76);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop76);
L_params_loop_exit76: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body76));
MOV(R0,R10);
JUMP(L_closure_end76);
L_closure_body76:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1595));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1635));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1940));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1600));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy66:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit66);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy66);
L_tc_copy_exit66:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end76:

MOV(ADDR(1590), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop75:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit75);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop75);
L_env_loop_exit75: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop75:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit75);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop75);
L_params_loop_exit75: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body75));
MOV(R0,R10);
JUMP(L_closure_end75);
L_closure_body75:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2165));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1580));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2100));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy65:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit65);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy65);
L_tc_copy_exit65:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end75:

MOV(ADDR(1585), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop74:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit74);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop74);
L_env_loop_exit74: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop74:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit74);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop74);
L_params_loop_exit74: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body74));
MOV(R0,R10);
JUMP(L_closure_end74);
L_closure_body74:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2165));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1580));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2100));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1890));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy64:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit64);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy64);
L_tc_copy_exit64:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end74:

MOV(ADDR(1575), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop73:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit73);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop73);
L_env_loop_exit73: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop73:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit73);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop73);
L_params_loop_exit73: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body73));
MOV(R0,R10);
JUMP(L_closure_end73);
L_closure_body73:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else46);
/* In consts .. */
MOV(R0,IMM(2163));
JUMP(L_if3_exit46);
L_if3_else46:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1970));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1880));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy63:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit63);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy63);
L_tc_copy_exit63:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit46:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end73:

MOV(ADDR(1970), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop72:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit72);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop72);
L_env_loop_exit72: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop72:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit72);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop72);
L_params_loop_exit72: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body72));
MOV(R0,R10);
JUMP(L_closure_end72);
L_closure_body72:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* in pvar */
MOV(R0, FPARG(2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end72:

MOV(ADDR(1985), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop71:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit71);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop71);
L_env_loop_exit71: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop71:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit71);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop71);
L_params_loop_exit71: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body71));
MOV(R0,R10);
JUMP(L_closure_end71);
L_closure_body71:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2100));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else45);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy61:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit61);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy61);
L_tc_copy_exit61:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit45);
L_if3_else45:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2080));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1570));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy62:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit62);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy62);
L_tc_copy_exit62:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit45:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end71:

MOV(ADDR(1570), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop70:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit70);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop70);
L_env_loop_exit70: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop70:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit70);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop70);
L_params_loop_exit70: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body70));
MOV(R0,R10);
JUMP(L_closure_end70);
L_closure_body70:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit1);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2115));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else44);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1565));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy60:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit60);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy60);
L_tc_copy_exit60:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit44);
L_if3_else44:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit44:

CMP(R0, SOB_FALSE);
JUMP_NE(L_or_exit1);
L_or_exit1:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end70:

MOV(ADDR(1565), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop68:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit68);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop68);
L_env_loop_exit68: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop68:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit68);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop68);
L_params_loop_exit68: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body68));
MOV(R0,R10);
JUMP(L_closure_end68);
L_closure_body68:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop69:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit69);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop69);
L_env_loop_exit69: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop69:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit69);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop69);
L_params_loop_exit69: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body69));
MOV(R0,R10);
JUMP(L_closure_end69);
L_closure_body69:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1955));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy58:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit58);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy58);
L_tc_copy_exit58:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end69:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1870));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy59:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit59);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy59);
L_tc_copy_exit59:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end68:

MOV(ADDR(1560), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop67:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit67);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop67);
L_env_loop_exit67: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop67:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit67);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop67);
L_params_loop_exit67: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body67));
MOV(R0,R10);
JUMP(L_closure_end67);
L_closure_body67:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2163));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2065));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy57:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit57);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy57);
L_tc_copy_exit57:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end67:

MOV(ADDR(1555), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop66:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit66);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop66);
L_env_loop_exit66: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop66:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit66);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop66);
L_params_loop_exit66: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body66));
MOV(R0,R10);
JUMP(L_closure_end66);
L_closure_body66:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2163));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2060));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy56:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit56);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy56);
L_tc_copy_exit56:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end66:

MOV(ADDR(1550), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop65:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit65);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop65);
L_env_loop_exit65: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop65:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit65);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop65);
L_params_loop_exit65: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body65));
MOV(R0,R10);
JUMP(L_closure_end65);
L_closure_body65:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1545));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy55:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit55);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy55);
L_tc_copy_exit55:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end65:

MOV(ADDR(1980), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop63:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit63);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop63);
L_env_loop_exit63: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop63:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit63);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop63);
L_params_loop_exit63: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body63));
MOV(R0,R10);
JUMP(L_closure_end63);
L_closure_body63:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop64:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit64);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop64);
L_env_loop_exit64: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop64:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit64);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop64);
L_params_loop_exit64: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body64));
MOV(R0,R10);
JUMP(L_closure_end64);
L_closure_body64:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2161));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2055));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else43);
/* in pvar */
MOV(R0, FPARG(4));

JUMP(L_if3_exit43);
L_if3_else43:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2035));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2000));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2080));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy54:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit54);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy54);
L_tc_copy_exit54:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit43:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end64:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end63:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop61:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit61);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop61);
L_env_loop_exit61: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop61:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit61);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop61);
L_params_loop_exit61: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body61));
MOV(R0,R10);
JUMP(L_closure_end61);
L_closure_body61:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop62:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit62);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop62);
L_env_loop_exit62: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop62:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit62);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop62);
L_params_loop_exit62: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body62));
MOV(R0,R10);
JUMP(L_closure_end62);
L_closure_body62:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2));
PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2040));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2080));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy53:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit53);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy53);
L_tc_copy_exit53:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end62:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end61:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1595), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop58:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit58);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop58);
L_env_loop_exit58: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop58:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit58);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop58);
L_params_loop_exit58: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body58));
MOV(R0,R10);
JUMP(L_closure_end58);
L_closure_body58:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2040));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2040));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop59:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit59);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop59);
L_env_loop_exit59: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop59:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit59);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop59);
L_params_loop_exit59: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body59));
MOV(R0,R10);
JUMP(L_closure_end59);
L_closure_body59:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2055));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else42);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1595));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1595));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop60:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit60);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop60);
L_env_loop_exit60: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop60:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit60);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop60);
L_params_loop_exit60: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body60));
MOV(R0,R10);
JUMP(L_closure_end60);
L_closure_body60:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1675));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1865));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy50:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit50);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy50);
L_tc_copy_exit50:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end60:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy51:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit51);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy51);
L_tc_copy_exit51:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit42);
L_if3_else42:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit42:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end59:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy52:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit52);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy52);
L_tc_copy_exit52:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end58:

MOV(ADDR(1540), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop54:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit54);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop54);
L_env_loop_exit54: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop54:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit54);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop54);
L_params_loop_exit54: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body54));
MOV(R0,R10);
JUMP(L_closure_end54);
L_closure_body54:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop56:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit56);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop56);
L_env_loop_exit56: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop56:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit56);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop56);
L_params_loop_exit56: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body56));
MOV(R0,R10);
JUMP(L_closure_end56);
L_closure_body56:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop57:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit57);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop57);
L_env_loop_exit57: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop57:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit57);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop57);
L_params_loop_exit57: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body57));
MOV(R0,R10);
JUMP(L_closure_end57);
L_closure_body57:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else41);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2115));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy46:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit46);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy46);
L_tc_copy_exit46:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit41);
L_if3_else41:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else40);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit40);
L_if3_else40:
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1675));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else39);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy47:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit47);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy47);
L_tc_copy_exit47:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit39);
L_if3_else39:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1665));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy48:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit48);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy48);
L_tc_copy_exit48:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit39:

L_if3_exit40:

L_if3_exit41:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end57:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end56:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop55:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit55);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop55);
L_env_loop_exit55: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop55:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit55);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop55);
L_params_loop_exit55: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body55));
MOV(R0,R10);
JUMP(L_closure_end55);
L_closure_body55:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1595));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1595));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy45:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit45);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy45);
L_tc_copy_exit45:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end55:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy49:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit49);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy49);
L_tc_copy_exit49:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end54:

MOV(ADDR(1535), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop53:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit53);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop53);
L_env_loop_exit53: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop53:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit53);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop53);
L_params_loop_exit53: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body53));
MOV(R0,R10);
JUMP(L_closure_end53);
L_closure_body53:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1535));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy44:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit44);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy44);
L_tc_copy_exit44:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end53:

MOV(ADDR(1530), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop52:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit52);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop52);
L_env_loop_exit52: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop52:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit52);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop52);
L_params_loop_exit52: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body52));
MOV(R0,R10);
JUMP(L_closure_end52);
L_closure_body52:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1530));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1890));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy43:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit43);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy43);
L_tc_copy_exit43:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end52:

MOV(ADDR(1525), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop51:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit51);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop51);
L_env_loop_exit51: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop51:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit51);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop51);
L_params_loop_exit51: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body51));
MOV(R0,R10);
JUMP(L_closure_end51);
L_closure_body51:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1535));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1890));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy42:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit42);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy42);
L_tc_copy_exit42:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end51:

MOV(ADDR(1520), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1540));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1515), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1535));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1510), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1530));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1505), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1525));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1500), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1520));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1860));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1495), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop49:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit49);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop49);
L_env_loop_exit49: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop49:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit49);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop49);
L_params_loop_exit49: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body49));
MOV(R0,R10);
JUMP(L_closure_end49);
L_closure_body49:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop50:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit50);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop50);
L_env_loop_exit50: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop50:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit50);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop50);
L_params_loop_exit50: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body50));
MOV(R0,R10);
JUMP(L_closure_end50);
L_closure_body50:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2161));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2055));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else38);
/* in pvar */
MOV(R0, FPARG(4));

JUMP(L_if3_exit38);
L_if3_else38:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2015));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2000));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2080));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy41:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit41);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy41);
L_tc_copy_exit41:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit38:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end50:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end49:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop47:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit47);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop47);
L_env_loop_exit47: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop47:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit47);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop47);
L_params_loop_exit47: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body47));
MOV(R0,R10);
JUMP(L_closure_end47);
L_closure_body47:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop48:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit48);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop48);
L_env_loop_exit48: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop48:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit48);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop48);
L_params_loop_exit48: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body48));
MOV(R0,R10);
JUMP(L_closure_end48);
L_closure_body48:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2));
PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2020));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2080));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy40:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit40);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy40);
L_tc_copy_exit40:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end48:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end47:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1490), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop41:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit41);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop41);
L_env_loop_exit41: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop41:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit41);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop41);
L_params_loop_exit41: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body41));
MOV(R0,R10);
JUMP(L_closure_end41);
L_closure_body41:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1970));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop42:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit42);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop42);
L_env_loop_exit42: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop42:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit42);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop42);
L_params_loop_exit42: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body42));
MOV(R0,R10);
JUMP(L_closure_end42);
L_closure_body42:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2025));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop43:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit43);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop43);
L_env_loop_exit43: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop43:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit43);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop43);
L_params_loop_exit43: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body43));
MOV(R0,R10);
JUMP(L_closure_end43);
L_closure_body43:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop45:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit45);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop45);
L_env_loop_exit45: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop45:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit45);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop45);
L_params_loop_exit45: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body45));
MOV(R0,R10);
JUMP(L_closure_end45);
L_closure_body45:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(5));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<4; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop46:
CMP(R5,IMM(4));
JUMP_GE(L_env_loop_exit46);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop46);
L_env_loop_exit46: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop46:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit46);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop46);
L_params_loop_exit46: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body46));
MOV(R0,R10);
JUMP(L_closure_end46);
L_closure_body46:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(2)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2055));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else37);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

JUMP(L_if3_exit37);
L_if3_else37:
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* in fvar */
MOV(R1, IMM(2030));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2085));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy36:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit36);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy36);
L_tc_copy_exit36:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));


L_if3_exit37:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end46:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end45:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop44:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit44);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop44);
L_env_loop_exit44: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop44:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit44);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop44);
L_params_loop_exit44: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body44));
MOV(R0,R10);
JUMP(L_closure_end44);
L_closure_body44:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2163));
PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(2)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy35:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit35);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy35);
L_tc_copy_exit35:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end44:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy37:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit37);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy37);
L_tc_copy_exit37:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end43:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy38:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit38);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy38);
L_tc_copy_exit38:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end42:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy39:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit39);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy39);
L_tc_copy_exit39:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end41:

MOV(ADDR(1600), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop35:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit35);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop35);
L_env_loop_exit35: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop35:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit35);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop35);
L_params_loop_exit35: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body35));
MOV(R0,R10);
JUMP(L_closure_end35);
L_closure_body35:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1970));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop36:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit36);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop36);
L_env_loop_exit36: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop36:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit36);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop36);
L_params_loop_exit36: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body36));
MOV(R0,R10);
JUMP(L_closure_end36);
L_closure_body36:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2005));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop37:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit37);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop37);
L_env_loop_exit37: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop37:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit37);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop37);
L_params_loop_exit37: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body37));
MOV(R0,R10);
JUMP(L_closure_end37);
L_closure_body37:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop39:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit39);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop39);
L_env_loop_exit39: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop39:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit39);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop39);
L_params_loop_exit39: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body39));
MOV(R0,R10);
JUMP(L_closure_end39);
L_closure_body39:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(5));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<4; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop40:
CMP(R5,IMM(4));
JUMP_GE(L_env_loop_exit40);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop40);
L_env_loop_exit40: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop40:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit40);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop40);
L_params_loop_exit40: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body40));
MOV(R0,R10);
JUMP(L_closure_end40);
L_closure_body40:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(2)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2055));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else36);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

JUMP(L_if3_exit36);
L_if3_else36:
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* in fvar */
MOV(R1, IMM(2010));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2085));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy31:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit31);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy31);
L_tc_copy_exit31:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));


L_if3_exit36:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end40:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end39:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(4));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<3; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop38:
CMP(R5,IMM(3));
JUMP_GE(L_env_loop_exit38);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop38);
L_env_loop_exit38: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop38:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit38);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop38);
L_params_loop_exit38: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body38));
MOV(R0,R10);
JUMP(L_closure_end38);
L_closure_body38:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2163));
PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(2)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in pvar */
MOV(R0, FPARG(3));
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy30:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit30);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy30);
L_tc_copy_exit30:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end38:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy32:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit32);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy32);
L_tc_copy_exit32:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end37:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy33:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit33);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy33);
L_tc_copy_exit33:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end36:
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy34:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit34);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy34);
L_tc_copy_exit34:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end35:

MOV(ADDR(1545), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop34:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit34);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop34);
L_env_loop_exit34: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop34:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit34);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop34);
L_params_loop_exit34: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body34));
MOV(R0,R10);
JUMP(L_closure_end34);
L_closure_body34:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else35);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit35);
L_if3_else35:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1480));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else34);
/* in pvar */
MOV(R0, FPARG(3));

JUMP(L_if3_exit34);
L_if3_else34:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1485));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy29:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit29);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy29);
L_tc_copy_exit29:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit34:

L_if3_exit35:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end34:

MOV(ADDR(1485), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* I am in the if exp */
/* In consts .. */
MOV(R0,IMM(3));
CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else15);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit15);
L_if3_else15:
/* In consts .. */
MOV(R0,IMM(1));
L_if3_exit15:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop30:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit30);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop30);
L_env_loop_exit30: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop30:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit30);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop30);
L_params_loop_exit30: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body30));
MOV(R0,R10);
JUMP(L_closure_end30);
L_closure_body30:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop32:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit32);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop32);
L_env_loop_exit32: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop32:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit32);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop32);
L_params_loop_exit32: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body32));
MOV(R0,R10);
JUMP(L_closure_end32);
L_closure_body32:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop33:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit33);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop33);
L_env_loop_exit33: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop33:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit33);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop33);
L_params_loop_exit33: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body33));
MOV(R0,R10);
JUMP(L_closure_end33);
L_closure_body33:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2130));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else16);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2130));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit16);
L_if3_else16:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit16:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else33);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1475));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy19:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit19);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy19);
L_tc_copy_exit19:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit33);
L_if3_else33:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2125));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else17);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2125));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit17);
L_if3_else17:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit17:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else32);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1675));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy20:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit20);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy20);
L_tc_copy_exit20:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit32);
L_if3_else32:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else31);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy21:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit21);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy21);
L_tc_copy_exit21:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit31);
L_if3_else31:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2140));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else18);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2140));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit18);
L_if3_else18:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit18:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else30);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2055));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy22:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit22);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy22);
L_tc_copy_exit22:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit30);
L_if3_else30:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2115));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else19);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2115));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit19);
L_if3_else19:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit19:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else29);
/* I am in the if exp */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else20);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy23:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit23);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy23);
L_tc_copy_exit23:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit20);
L_if3_else20:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit20:

JUMP(L_if3_exit29);
L_if3_else29:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2110));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else21);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2110));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit21);
L_if3_else21:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit21:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else28);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1515));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy24:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit24);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy24);
L_tc_copy_exit24:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit28);
L_if3_else28:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2105));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else22);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2105));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit22);
L_if3_else22:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit22:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else27);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1955));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy25:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit25);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy25);
L_tc_copy_exit25:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit27);
L_if3_else27:
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2095));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else24);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2095));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else23);
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2020));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2020));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2055));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit23);
L_if3_else23:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit23:

JUMP(L_if3_exit24);
L_if3_else24:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit24:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else26);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1490));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1490));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy26:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit26);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy26);
L_tc_copy_exit26:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit26);
L_if3_else26:
/* I am in the if exp */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1955));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else25);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1955));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy27:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit27);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy27);
L_tc_copy_exit27:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit25);
L_if3_else25:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit25:

L_if3_exit26:

L_if3_exit27:

L_if3_exit28:

L_if3_exit29:

L_if3_exit30:

L_if3_exit31:

L_if3_exit32:

L_if3_exit33:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end33:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end32:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop31:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit31);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop31);
L_env_loop_exit31: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop31:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit31);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop31);
L_params_loop_exit31: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body31));
MOV(R0,R10);
JUMP(L_closure_end31);
L_closure_body31:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* in pvar */
MOV(R0, FPARG(3));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end31:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy28:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit28);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy28);
L_tc_copy_exit28:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end30:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1480), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop26:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit26);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop26);
L_env_loop_exit26: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop26:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit26);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop26);
L_params_loop_exit26: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body26));
MOV(R0,R10);
JUMP(L_closure_end26);
L_closure_body26:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop28:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit28);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop28);
L_env_loop_exit28: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop28:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit28);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop28);
L_params_loop_exit28: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body28));
MOV(R0,R10);
JUMP(L_closure_end28);
L_closure_body28:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<2; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop29:
CMP(R5,IMM(2));
JUMP_GE(L_env_loop_exit29);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop29);
L_env_loop_exit29: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop29:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit29);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop29);
L_params_loop_exit29: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body29));
MOV(R0,R10);
JUMP(L_closure_end29);
L_closure_body29:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else14);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit14);
L_if3_else14:
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1830));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(1)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else13);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy16:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit16);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy16);
L_tc_copy_exit16:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit13);
L_if3_else13:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy17:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit17);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy17);
L_tc_copy_exit17:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit13:

L_if3_exit14:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end29:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end28:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop27:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit27);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop27);
L_env_loop_exit27: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop27:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit27);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop27);
L_params_loop_exit27: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body27));
MOV(R0,R10);
JUMP(L_closure_end27);
L_closure_body27:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* in pvar */
MOV(R0, FPARG(3));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end27:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy18:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit18);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy18);
L_tc_copy_exit18:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end26:

MOV(ADDR(1470), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1480));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1470));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1465), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1955));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1470));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1460), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop25:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit25);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop25);
L_env_loop_exit25: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop25:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit25);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop25);
L_params_loop_exit25: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body25));
MOV(R0,R10);
JUMP(L_closure_end25);
L_closure_body25:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2130));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else10);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2130));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

JUMP(L_if3_exit10);
L_if3_else10:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit10:

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else12);
/* I am in the if exp */
/* in pvar */
MOV(R0, FPARG(2));

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else11);
/* in pvar */
MOV(R0, FPARG(3));

JUMP(L_if3_exit11);
L_if3_else11:
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1890));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy15:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit15);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy15);
L_tc_copy_exit15:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit11:

JUMP(L_if3_exit12);
L_if3_else12:
/* In consts .. */
MOV(R0,IMM(3));
L_if3_exit12:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end25:

MOV(ADDR(1475), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* I am in the if exp */
/* In consts .. */
MOV(R0,IMM(3));
CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else9);
/* In consts .. */
MOV(R0,IMM(3));
JUMP(L_if3_exit9);
L_if3_else9:
/* In consts .. */
MOV(R0,IMM(1));
L_if3_exit9:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop23:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit23);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop23);
L_env_loop_exit23: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop23:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit23);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop23);
L_params_loop_exit23: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body23));
MOV(R0,R10);
JUMP(L_closure_end23);
L_closure_body23:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop24:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit24);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop24);
L_env_loop_exit24: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop24:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit24);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop24);
L_params_loop_exit24: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body24));
MOV(R0,R10);
JUMP(L_closure_end24);
L_closure_body24:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(0));
JUMP_NE(ERROR);
/* Call code gen ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end24:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end23:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1455), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* push params reverse order. */
/* push number of args. */
PUSH(IMM(0));
/* in fvar */
MOV(R1, IMM(1455));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop21:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit21);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop21);
L_env_loop_exit21: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop21:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit21);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop21);
L_params_loop_exit21: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body21));
MOV(R0,R10);
JUMP(L_closure_end21);
L_closure_body21:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop22:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit22);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop22);
L_env_loop_exit22: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop22:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit22);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop22);
L_params_loop_exit22: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body22));
MOV(R0,R10);
JUMP(L_closure_end22);
L_closure_body22:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1955));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy14:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit14);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy14);
L_tc_copy_exit14:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end22:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end21:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1450), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop20:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit20);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop20);
L_env_loop_exit20: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop20:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit20);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop20);
L_params_loop_exit20: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body20));
MOV(R0,R10);
JUMP(L_closure_end20);
L_closure_body20:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1595));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1940));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1440));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1975));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1600));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy13:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit13);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy13);
L_tc_copy_exit13:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end20:

MOV(ADDR(1445), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop19:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit19);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop19);
L_env_loop_exit19: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop19:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit19);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop19);
L_params_loop_exit19: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body19));
MOV(R0,R10);
JUMP(L_closure_end19);
L_closure_body19:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1490));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1940));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1440));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1975));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1545));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy12:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit12);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy12);
L_tc_copy_exit12:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end19:

MOV(ADDR(1435), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop13:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit13);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop13);
L_env_loop_exit13: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop13:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit13);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop13);
L_params_loop_exit13: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body13));
MOV(R0,R10);
JUMP(L_closure_end13);
L_closure_body13:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop14:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit14);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop14);
L_env_loop_exit14: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop14:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit14);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop14);
L_params_loop_exit14: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body14));
MOV(R0,R10);
JUMP(L_closure_end14);
L_closure_body14:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else6);
/* in pvar */
MOV(R0, FPARG(2));

JUMP(L_if3_exit6);
L_if3_else6:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(2)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy9:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit9);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy9);
L_tc_copy_exit9:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit6:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end14:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end13:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop17:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit17);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop17);
L_env_loop_exit17: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop17:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit17);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop17);
L_params_loop_exit17: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body17));
MOV(R0,R10);
JUMP(L_closure_end17);
L_closure_body17:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop18:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit18);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop18);
L_env_loop_exit18: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop18:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit18);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop18);
L_params_loop_exit18: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body18));
MOV(R0,R10);
JUMP(L_closure_end18);
L_closure_body18:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else8);
/* in pvar */
MOV(R0, FPARG(3));

JUMP(L_if3_exit8);
L_if3_else8:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(2000));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy11:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit11);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy11);
L_tc_copy_exit11:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit8:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end18:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end17:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop15:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit15);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop15);
L_env_loop_exit15: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop15:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit15);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop15);
L_params_loop_exit15: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body15));
MOV(R0,R10);
JUMP(L_closure_end15);
L_closure_body15:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop16:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit16);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop16);
L_env_loop_exit16: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<3; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop16:
CMP(R5,IMM(5));
JUMP_GE(L_params_loop_exit16);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop16);
L_params_loop_exit16: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body16));
MOV(R0,R10);
JUMP(L_closure_end16);
L_closure_body16:
PUSH(FP);
MOV(FP,SP);
/* In lambda var body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(R4);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R4);
DROP(R4);
PUSH(R0);
PUSH(1);
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else7);
/* In consts .. */
MOV(R0,IMM(2));
JUMP(L_if3_exit7);
L_if3_else7:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(2)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy10:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit10);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy10);
L_tc_copy_exit10:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit7:

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end16:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end15:

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1440), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop11:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit11);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop11);
L_env_loop_exit11: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop11:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit11);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop11);
L_params_loop_exit11: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body11));
MOV(R0,R10);
JUMP(L_closure_end11);
L_closure_body11:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop12:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit12);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop12);
L_env_loop_exit12: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop12:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit12);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop12);
L_params_loop_exit12: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body12));
MOV(R0,R10);
JUMP(L_closure_end12);
L_closure_body12:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2120));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else5);
/* in pvar */
MOV(R0, FPARG(3));

JUMP(L_if3_exit5);
L_if3_else5:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2000));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy8:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit8);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy8);
L_tc_copy_exit8:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit5:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end12:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end11:

PUSH(R0);
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop9:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit9);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop9);
L_env_loop_exit9: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop9:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit9);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop9);
L_params_loop_exit9: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body9));
MOV(R0,R10);
JUMP(L_closure_end9);
L_closure_body9:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop10:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit10);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop10);
L_env_loop_exit10: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<2; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop10:
CMP(R5,IMM(4));
JUMP_GE(L_params_loop_exit10);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop10);
L_params_loop_exit10: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body10));
MOV(R0,R10);
JUMP(L_closure_end10);
L_closure_body10:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* In codegen-tc-applis */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(1)));
MOV(R0,R3);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy7:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit7);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy7);
L_tc_copy_exit7:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end10:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end9:

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(1935));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1430), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* in fvar */
MOV(R1, IMM(1595));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1430));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* in fvar */
MOV(R1, IMM(1600));
MOV(R2,INDD(R1,0));
MOV(R0,R2);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* in fvar */
MOV(R1, IMM(1835));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1425), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop8:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit8);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop8);
L_env_loop_exit8: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop8:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit8);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop8);
L_params_loop_exit8: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body8));
MOV(R0,R10);
JUMP(L_closure_end8);
L_closure_body8:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2100));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else4);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1995));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(2));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy5:
CMP(R4, IMM(4));
JUMP_EQ(L_tc_copy_exit5);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy5);
L_tc_copy_exit5:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit4);
L_if3_else4:
/* In codegen-tc-applis */
/* push params reverse order. */
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2080));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1570));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy6:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit6);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy6);
L_tc_copy_exit6:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit4:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end8:

MOV(ADDR(1570), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop7:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit7);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop7);
L_env_loop_exit7: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop7:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit7);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop7);
L_params_loop_exit7: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body7));
MOV(R0,R10);
JUMP(L_closure_end7);
L_closure_body7:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(3));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(2100));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else3);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1945));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(3));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy3:
CMP(R4, IMM(5));
JUMP_EQ(L_tc_copy_exit3);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy3);
L_tc_copy_exit3:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

JUMP(L_if3_exit3);
L_if3_else3:
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(4));

PUSH(R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2080));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* in fvar */
MOV(R1, IMM(1990));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1420));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy4:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit4);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy4);
L_tc_copy_exit4:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

L_if3_exit3:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end7:

MOV(ADDR(1420), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop4:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit4);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop4);
L_env_loop_exit4: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop4:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit4);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop4);
L_params_loop_exit4: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body4));
MOV(R0,R10);
JUMP(L_closure_end4);
L_closure_body4:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2060));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else2);
/* in pvar */
MOV(R0, FPARG(2));

JUMP(L_if3_exit2);
L_if3_else2:
/* in pvar */
MOV(R0, FPARG(3));

L_if3_exit2:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end4:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop5:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit5);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop5);
L_env_loop_exit5: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop5:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit5);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop5);
L_params_loop_exit5: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body5));
MOV(R0,R10);
JUMP(L_closure_end5);
L_closure_body5:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop6:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit6);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop6);
L_env_loop_exit6: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop6:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit6);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop6);
L_params_loop_exit6: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body6));
MOV(R0,R10);
JUMP(L_closure_end6);
L_closure_body6:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy2:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit2);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy2);
L_opt_copy_exit2:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy2:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit2);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy2);
L_opt_2copy_exit2:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1840));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy2:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit2);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy2);
L_tc_copy_exit2:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end6:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end5:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1415), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* In Define .. */
/* push params reverse order. */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop1:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit1);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop1);
L_env_loop_exit1: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop1:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit1);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop1);
L_params_loop_exit1: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body1));
MOV(R0,R10);
JUMP(L_closure_end1);
L_closure_body1:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(2));
JUMP_NE(ERROR);
/* Call code gen ... */
/* I am in the if exp */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2065));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CMP(R0, SOB_FALSE);
JUMP_EQ(L_if3_else1);
/* in pvar */
MOV(R0, FPARG(2));

JUMP(L_if3_exit1);
L_if3_else1:
/* in pvar */
MOV(R0, FPARG(3));

L_if3_exit1:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end1:

PUSH(R0);
/* push number of args. */
PUSH(IMM(1));
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<0; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop2:
CMP(R5,IMM(0));
JUMP_GE(L_env_loop_exit2);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop2);
L_env_loop_exit2: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(0));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<0; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop2:
CMP(R5,IMM(2));
JUMP_GE(L_params_loop_exit2);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop2);
L_params_loop_exit2: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body2));
MOV(R0,R10);
JUMP(L_closure_end2);
L_closure_body2:
PUSH(FP);
MOV(FP,SP);
/* In lambda body ... */
MOV(R1, FPARG(1));
CMP(R1, IMM(1));
JUMP_NE(ERROR);
/* Call code gen ... */
/* Calling malloc with 3 for closure, env and body. */
PUSH(IMM(3));
CALL(MALLOC);
DROP(IMM(1));
/* R10 will hold the adress of the malloc */
MOV(R10,R0);
/* putting T_Closure at place 0 */
MOV(INDD(R10,0), IMM(T_CLOSURE));
/* call malloc with |env| + 1 */
PUSH(IMM(2));
CALL(MALLOC);
DROP(IMM(1));
/* R2 will hold the new env adress */
MOV(R2,R0);
/* R3 get the old env adress */MOV(R3, FPARG(0));
/* cloning the env .. */
/* R4 is i, R5 is j
for(i=1,j=0; j<1; j++, i++)
MOV(INDD(R2,IMM(i)), INDD(R3,IMM(j));
*/
MOV(R4, IMM(1));
MOV(R5, IMM(0));
L_env_loop3:
CMP(R5,IMM(1));
JUMP_GE(L_env_loop_exit3);
MOV(INDD(R2,R4), INDD(R3,R5));
INCR(R4);
INCR(R5);
JUMP(L_env_loop3);
L_env_loop_exit3: 
/* Now cloning the parameters if nedded ... */
/* calling malloc with params length ... */
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));

/* R3 hold the new parametes adress .. */
MOV(R3, R0);
/*for loop for clone ... */
/*
for(i=0; i<1; i++) {
MOV(INDD(R3,IMM(i)), FPARG(2 + i));
} */
/* R5 = 2*/
MOV(INDD(R2,0), R3);
MOV(R5, IMM(2));
MOV(R6, IMM(0));
L_params_loop3:
CMP(R5,IMM(3));
JUMP_GE(L_params_loop_exit3);
MOV(INDD(R3,R6), FPARG(R5));
/* the new env R2[0] = new parameters */
INCR(R5);
INCR(R6);
JUMP(L_params_loop3);
L_params_loop_exit3: 
/* finish copy parameters */
/* new struct at 1 = new env */
MOV(INDD(R10,1),R2);
/* appending body ...*/
MOV(INDD(R10,IMM(2)), LABEL(L_closure_body3));
MOV(R0,R10);
JUMP(L_closure_end3);
L_closure_body3:
PUSH(FP);
MOV(FP,SP);
/* In lambda opt body ... */
POP(R1);
POP(R2);
POP(R3);
POP(R4);
PUSH(IMM(1));
CALL(MALLOC);
DROP(IMM(1));
MOV(R5, R0);
MOV(R6, IMM(0));
L_opt_copy1:
CMP(R6, IMM(1));
JUMP_EQ(L_opt_copy_exit1);
POP(R7);
MOV(INDD(R5,R6), R7);
ADD(R6, IMM(1));
JUMP(L_opt_copy1);
L_opt_copy_exit1:
MOV(R7, R4);
SUB(R7, IMM(1));
PUSH(R7);
PUSH(IMM(0));
CALL(LIST);
DROP(IMM(1));
POP(R7);
DROP(R7);
MOV(R8, R0);
PUSH(R8);
MOV(R6, IMM(0));
L_opt_2copy1:
CMP(R6, IMM(-1));
JUMP_EQ(L_opt_2copy_exit1);
PUSH(INDD(R5,R6));
SUB(R6, IMM(1));
JUMP(L_opt_2copy1);
L_opt_2copy_exit1:
PUSH(IMM(2));
PUSH(R3);
PUSH(R2);
PUSH(R1);
MOV(FP, SP);
/* In codegen-tc-applis */
/* push params reverse order. */
/* in pvar */
MOV(R0, FPARG(3));

PUSH(R0);
/* in pvar */
MOV(R0, FPARG(2));

PUSH(R0);
/* in bvar */
MOV(R1,FPARG(LOC_ENV));
MOV(R2,INDD(R1,IMM(0)));
MOV(R3,INDD(R2,IMM(0)));
MOV(R0,R3);

PUSH(R0);
/* push number of args. */
PUSH(IMM(3));
/* add function code ... */
/* in fvar */
MOV(R1, IMM(1840));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0),IMM(T_CLOSURE));
JUMP_NE(ERROR);
/* push env ... */
PUSH(INDD(R0,1));
/*  Push the return address from current frame */
PUSH(FPARG(-1));
/* R8 hold the old fp */
MOV(R8,FPARG(-2));
/* R12 hold the old num of arg */
MOV(R12,FPARG(1));
/* R13 hold the new num of arg */
MOV(R13,STARG(1));
/* R6 will old the STARG offset */
MOV(R6, IMM(4));
/* R5 will old the FPARG offset */
MOV(R5, R12);
ADD(R5, IMM(1));
/* R4 is the running index */
MOV(R4, IMM(0));
L_tc_copy1:
CMP(R4, IMM(6));
JUMP_EQ(L_tc_copy_exit1);
MOV(FPARG(R5), STARG(R6));
SUB(R6, IMM(1));
SUB(R5, IMM(1));
ADD(R4, IMM(1));
JUMP(L_tc_copy1);
L_tc_copy_exit1:
MOV(R9, R13);
SUB(R9, IMM(1));
SUB(R9, R12);
MOV(SP, FP);
ADD(SP, R9);
MOV(FP, R8);
JUMPA(INDD(R0, 2));

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end3:
/* retrun from code gen .. */

POP(FP);
RETURN;
/* LABEL END LAMBDA */
L_closure_end2:
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

MOV(ADDR(1410), R0);
MOV(R0, SOB_VOID);

CALL(PRINT_R0);
/* push params reverse order. */
/* In consts .. */
MOV(R0,IMM(2165));
PUSH(R0);
/* In consts .. */
MOV(R0,IMM(2175));
PUSH(R0);
/* push number of args. */
PUSH(IMM(2));
/* in fvar */
MOV(R1, IMM(2085));
MOV(R2,INDD(R1,0));
MOV(R0,R2);
CMP(INDD(R0,0), IMM(T_CLOSURE));
JUMP_NE(ERROR);
PUSH(INDD(R0,IMM(1)));
CALLA(INDD(R0,IMM(2)));
/* move to R5 number of args .. to know how to drop from stack. */
MOV(R5,STARG(IMM(0)));
/* add r5 env, numOfArg */
ADD(R5, IMM(2));
DROP(R5);

CALL(PRINT_R0);

POP(FP);
DROP(IMM(3));
STOP_MACHINE;
HALT;
}
