PROCSS:

_PREDICATES:

ISBOOLEAN:
	PUSH(FP);
	MOV(FP, SP);
	MOV(R0, FPARG(2));
	CMP(IND(R0), T_BOOL);
	JUMP(CHECK_BOOL_RESULT);

ISCHAR:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(FPARG(2));
	CALL(IS_SOB_CHAR);
	JUMP(CHECK_BOOL);

ISNULL:
	PUSH(FP);
	MOV(FP, SP);
	MOV(R0, FPARG(2));
	CMP(R0, SOB_NIL);
	JUMP(CHECK_BOOL_RESULT);

ISNUMBER:
	PUSH(FP);
	MOV(FP, SP);
	MOV(R0, FPARG(2));
	CMP(IND(R0), T_INTEGER);
	JUMP_EQ(RETURN_TRUE);
	CMP(IND(R0), T_FRACTION);
	JUMP(CHECK_BOOL_RESULT);	

ISRATIONAL:
	JUMP(ISNUMBER);

ISINTEGER:
	PUSH(FP);
	MOV(FP, SP);
	MOV(R0, FPARG(2));
	CMP(IND(R0), T_INTEGER);
	JUMP(CHECK_BOOL_RESULT);

ISPAIR:
	PUSH(FP);
	MOV(FP, SP);
	MOV(R0, FPARG(2));
	CMP(IND(R0), T_PAIR);
	JUMP(CHECK_BOOL_RESULT);

ISSTRING:
	PUSH(FP);
	MOV(FP, SP);
	MOV(R0, FPARG(2));
	CMP(IND(R0), T_STRING);
	JUMP(CHECK_BOOL_RESULT);

ISSYMBOL:
	PUSH(FP);
	MOV(FP, SP);
	MOV(R0, FPARG(2));
	CMP(IND(R0), T_SYMBOL);
	JUMP(CHECK_BOOL_RESULT);			

ISVECTOR:
	PUSH(FP);
	MOV(FP, SP);
	MOV(R0, FPARG(2));
	CMP(IND(R0), T_VECTOR);
	JUMP(CHECK_BOOL_RESULT);
	
ISZERO:
	PUSH(FP);
	MOV(FP, SP);
	MOV(R2, FPARG(2));
	MOV(R2, INDD(R2, 1));
	CMP(R2, 0);
	JUMP(CHECK_BOOL_RESULT);

ISPROCEDURE:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(FPARG(2));
	CALL(IS_SOB_CLOSURE);
	JUMP(CHECK_BOOL);
		
CHECK_BOOL:
	DROP(1);
	CMP(1, R0);
	JUMP(CHECK_BOOL_RESULT);		
		
CHECK_BOOL_RESULT:
	JUMP_EQ(RETURN_TRUE);
	MOV(R0, SOB_FALSE);
	JUMP(END);


FRACTIONS:

DENOMINATOR:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	MOV(R1, 0);	
	MOV(R1, FPARG(2));
	CMP(INDD(R1, 0), T_FRACTION);
	JUMP_EQ(DENOMERATOR_FRAC);
	PUSH(INDD(R1, 1));
	PUSH(1);
	CALL(MAKE_SOB_FRACTION);
	DROP(2);
	MOV(R1, R0);
DENOMERATOR_FRAC:
	MOV(R0, INDD(R1, 2));
	PUSH(R0);
	CALL(MAKE_SOB_INTEGER);
	DROP(1);
	POP(R1);
	POP(FP);
	RETURN;

NUMERATOR:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	MOV(R1, 0);	
	MOV(R1, FPARG(2));
	CMP(INDD(R1, 0), T_FRACTION);
	JUMP_EQ(NUMERATOR_FRAC);
	PUSH(INDD(R1, 1));
	PUSH(1);
	CALL(MAKE_SOB_FRACTION);
	DROP(2);
	MOV(R1, R0);
NUMERATOR_FRAC:
	MOV(R0, INDD(R1, 1));
	PUSH(R0);
	CALL(MAKE_SOB_INTEGER);
	DROP(1);
	POP(R1);
	POP(FP);
	RETURN;


VAR_PLUS:

  PUSH(FP);
  MOV(FP, SP);
  PUSH(R1);
  PUSH(R2);
  PUSH(R3);
  PUSH(R4);
  PUSH(R5);
  PUSH(R6);

  // Put 0/1 in R1:
  PUSH(0);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R1, R0);

  // Start loop stuff:
  MOV(R5, FPARG(NUMOFARGS)); /*iterate from 2 to 2+ number of args */
  ADD(R5, 2);
  MOV(R3, 2); 

PLUS_LOOP:
  CMP(R5, R3);
  
  JUMP_EQ(PLUS_END);
  // Get arg:
  MOV(R4, FPARG(R3)); /* SCHEME INTEGER */

  // Check if it is a fraction already:
  CMP(INDD(R4, 0), T_FRACTION);
  JUMP_EQ(IS_FRAC);
  // It is not, turn it to fraction:

  MOV(R2, INDD(R4, 1));
  PUSH(R2);
  PUSH(1);

  CALL(MAKE_SOB_FRACTION);
  DROP(2);

  MOV(R4, R0);


  IS_FRAC:


  PUSH(R1);
  PUSH(R4);
  CALL(SUM_FRACS);

  DROP(2);
  MOV(R1, R0);
  ADD(R3, 1);
  JUMP(PLUS_LOOP);

PLUS_END:

MOV(R0, R1);
CMP(INDD(R0, 2), 1); // Somthing / 1
JUMP_NE(RETURN_FRACTION);
PUSH(INDD(R0, 1));
CALL(MAKE_SOB_INTEGER);
DROP(1);  
RETURN_FRACTION:


  POP(R6);
  POP(R5);
  POP(R4);
  POP(R3);
  POP(R2);
  POP(R1);
  POP(FP);
RETURN;

 /* RECEIVES 2 T_FRACS AND RETURN A FRAC*/
  SUM_FRACS: 

  PUSH(FP);
  MOV(FP, SP);
  PUSH(R1);
  PUSH(R2);
  PUSH(R3);
  PUSH(R4);
  PUSH(R5);
  PUSH(R6);
  MOV(R1, FPARG(0));
  MOV(R2, FPARG(1));

  MOV(R3, INDD(R1, 1));
  MOV(R4, INDD(R1, 2));
  MOV(R5, INDD(R2, 1));
  MOV(R6, INDD(R2, 2));

  MUL(R3, R6);
  MUL(R5, R4);
  ADD(R3, R5);
  MUL(R4, R6);

  PUSH(R3);
  PUSH(R4);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);

  POP(R6);
  POP(R5);
  POP(R4);
  POP(R3);
  POP(R2);
  POP(R1);
  POP(FP);

RETURN;


VAR_MUL:

  PUSH(FP);
  MOV(FP, SP);
  PUSH(R1);
  PUSH(R2);
  PUSH(R3);
  PUSH(R4);
  PUSH(R5);
  PUSH(R6);
  PUSH(R7);

  MOV(R1,FPARG(1));
  CMP(R1,IMM(0));
  JUMP_EQ(MULTIPLY_NO_ARGS);

  MOV(R5, FPARG(NUMOFARGS)); //iterate from 2 to 2+ number of args
  ADD(R5, 2);
  MOV(R3, 2);
  MOV(R6, FPARG(R3)); // first scheme arg
  /* CHANGINY THE FIRST ARG TO BE A FRAC */
  CMP(INDD(R6, 0), T_FRACTION);
  JUMP_EQ(MULTIPLY_FIRST_ARGUMENT_IS_FRAC);
  MOV(R2, INDD(R6, 1));
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R6, R0);

  MULTIPLY_FIRST_ARGUMENT_IS_FRAC:
  ADD(R3, 1);
  CMP(R5, R3);
  JUMP_EQ(MULTIPLY_ONLY_ONE_ARG);

  /* MUL LOOP*/
  MUL_LOOP:
  CMP(R5, R3);
  JUMP_EQ(MUL_END);
  /* SCHEME ARG */
  MOV(R4, FPARG(R3)); 

  // Check if it is a fraction already:
  CMP(INDD(R4, 0), T_FRACTION);
  JUMP_EQ(MUL_IS_FRAC);
  // It is not, turn it to fraction:
  MOV(R2, INDD(R4, 1));
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R4, R0);

  MUL_IS_FRAC:
  PUSH(R6);
  PUSH(R4);
  CALL(MUL_FRACS);
  DROP(2);
  MOV(R6, R0);
  ADD(R3, 1);
  JUMP(MUL_LOOP);

   
  

  MULTIPLY_ONLY_ONE_ARG:
  MOV(R0, R6);
  CMP(INDD(R0, 2), 1); // Somthing / 1
  JUMP_NE(MULTIPLY_RETURN_FRACTION);
  PUSH(INDD(R0, 1));
  CALL(MAKE_SOB_INTEGER);
  DROP(1);
  JUMP(MULTIPLY_RETURN_FRACTION);


MULTIPLY_NO_ARGS: 
  PUSH(IMM(1));
  CALL(MAKE_SOB_INTEGER);
  DROP(1);
  JUMP(MULTIPLY_RETURN_FRACTION);

  MUL_END:
  MOV(R0, R6);
  CMP(INDD(R0, 2), 1); // Somthing / 1
  JUMP_NE(MULTIPLY_RETURN_FRACTION);
  PUSH(INDD(R0, 1));
  CALL(MAKE_SOB_INTEGER);
  DROP(1);  


  MULTIPLY_RETURN_FRACTION:
  POP(R7);
  POP(R6);
  POP(R5);
  POP(R4);
  POP(R3);
  POP(R2);
  POP(R1);
  POP(FP);
  RETURN;
	

/* RECEIVES 2 T_FRACS AND RETURN A FRAC*/
  MUL_FRACS:

  PUSH(FP);
  MOV(FP, SP);
  PUSH(R1);
  PUSH(R2);
  PUSH(R3);
  PUSH(R4);
  PUSH(R5);
  PUSH(R6);
  MOV(R1, FPARG(0));
  MOV(R2, FPARG(1));

  MOV(R3, INDD(R1, 1));
  MOV(R4, INDD(R1, 2));
  MOV(R5, INDD(R2, 1));
  MOV(R6, INDD(R2, 2));

  MUL(R5, R3);
  MUL(R6, R4);


  PUSH(R5);
  PUSH(R6);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);

  POP(R6);
  POP(R5);
  POP(R4);
  POP(R3);
  POP(R2);
  POP(R1);
  POP(FP);

RETURN;


VAR_DIV:

  PUSH(FP);
  MOV(FP, SP);
  PUSH(R1);
  PUSH(R2);
  PUSH(R3);
  PUSH(R4);
  PUSH(R5);
  PUSH(R6);
  PUSH(R7);


  MOV(R5, FPARG(NUMOFARGS)); //iterate from 2 to 2+ number of args
  ADD(R5, 2);
  MOV(R3, 2);
  MOV(R6, FPARG(R3)); // first scheme arg
  /* CHANGINY THE FIRST ARG TO BE A FRAC */
  CMP(INDD(R6, 0), T_FRACTION);
  JUMP_EQ(DIVIDE_FIRST_ARGUMENT_IS_FRAC);
  MOV(R2, INDD(R6, 1));
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R6, R0);

  DIVIDE_FIRST_ARGUMENT_IS_FRAC:
  ADD(R3, 1);
  CMP(R5, R3);
  JUMP_EQ(DIVIDE_ONLY_ONE_ARG);

  /* DIVIDE LOOP*/
  DIVIDE_LOOP:
  CMP(R5, R3);
  JUMP_EQ(DIVIDE_END);
  /* SCHEME ARG */
  MOV(R4, FPARG(R3)); 

  // Check if it is a fraction already:
  CMP(INDD(R4, 0), T_FRACTION);
  JUMP_EQ(DIVIDE_IS_FRAC);
  // It is not, turn it to fraction:
  MOV(R2, INDD(R4, 1));
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R4, R0);

  DIVIDE_IS_FRAC:
  /* R4 <- 1/R4 */
  MOV(R2, INDD(R4, 1));
  MOV(INDD(R4,1), INDD(R4,2));
  MOV(INDD(R4,2), R2);
  PUSH(R6);
  PUSH(R4);
  CALL(MUL_FRACS);
  DROP(2);
  MOV(R6, R0);
  ADD(R3, 1);
  JUMP(DIVIDE_LOOP);


  DIVIDE_ONLY_ONE_ARG:

  PUSH(INDD(R6, 2));
  PUSH(INDD(R6, 1));
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R6, R0);
  

  DIVIDE_END:
  MOV(R0, R6);
  CMP(INDD(R0, 2), 1); // Somthing / 1
  JUMP_NE(DIVIDE_RETURN_FRACTION);
  PUSH(INDD(R0, 1));
  CALL(MAKE_SOB_INTEGER);
  DROP(1);  


  DIVIDE_RETURN_FRACTION:
  POP(R7);
  POP(R6);
  POP(R5);
  POP(R4);
  POP(R3);
  POP(R2);
  POP(R1);
  POP(FP);
RETURN;

VAR_MIN:

  PUSH(FP);
  MOV(FP, SP);
  PUSH(R1);
  PUSH(R2);
  PUSH(R3);
  PUSH(R4);
  PUSH(R5);
  PUSH(R6);
  PUSH(R7);
  

  /* TAKING THE FIRST ARGUMENT OUT FROM THE 'ADD' LOOP*/
  MOV(R5, FPARG(NUMOFARGS)); /*iterate from 2 to 2+ number of args */
  ADD(R5, 2);
  MOV(R3, 2);
  MOV(R6, FPARG(R3)); /* FIRST SCHEME INTEGER */
  CMP(INDD(R6, 0), T_FRACTION);
  JUMP_EQ(FIRST_ARGUMENT_IS_FRAC_IN_MINUS);
  // It is not, turn it to fraction:
  MOV(R2, INDD(R6, 1));
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R6, R0);

  FIRST_ARGUMENT_IS_FRAC_IN_MINUS:
  ADD(R3, 1);
  CMP(R5, R3);
  JUMP_EQ(ONLY_ONE_ARG);
  

 /* STARING THE 'ADD' LOOP */

  // Put 0/1 in R1:
  PUSH(0);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R1, R0);

  PLUS_LOOP_IN_MINUS:
  CMP(R5, R3);
  JUMP_EQ(PLUS_END_IN_MINUS);
  // Get arg:
  MOV(R4, FPARG(R3)); /* SCHEME INTEGER */

  // Check if it is a fraction already:
  CMP(INDD(R4, 0), T_FRACTION);
  JUMP_EQ(IS_FRAC_IN_MINUS);
  // It is not, turn it to fraction:
  MOV(R2, INDD(R4, 1));
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R4, R0);


  IS_FRAC_IN_MINUS:
  PUSH(R1);
  PUSH(R4);
  CALL(SUM_FRACS);
  DROP(2);
  MOV(R1, R0);
  ADD(R3, 1);
  JUMP(PLUS_LOOP_IN_MINUS);

  PLUS_END_IN_MINUS: // THE SUM IS IN R1
  //MULING THE SUM BY -1
  MOV(R2, INDD(R1, 1));
  MUL(R2, -1);
  PUSH(R2);
  PUSH(INDD(R1, 2));
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R1, R0);

  //USING SUM_FRACS TO GET THE ANSWER
  PUSH(R1);
  PUSH(R6);
  CALL(SUM_FRACS);
  DROP(2);

  JUMP(MANY_ARGS);

  ONLY_ONE_ARG:
  //MULING R6 BY -1
  MOV(R2, INDD(R6, 1));
  MUL(R2, -1);
  PUSH(R2);
  PUSH(INDD(R6, 2));
  CALL(MAKE_SOB_FRACTION);
  DROP(2);

  MANY_ARGS:
  CMP(INDD(R0, 2), 1); // Somthing / 1
  JUMP_NE(RETURN_FRACTION_IN_MINUS);
  PUSH(INDD(R0, 1));
  CALL(MAKE_SOB_INTEGER);
  DROP(1);  

  RETURN_FRACTION_IN_MINUS:
  POP(R7);
  POP(R6);
  POP(R5);
  POP(R4);
  POP(R3);
  POP(R2);
  POP(R1);
  POP(FP);
  RETURN;


VAR_EQUAL:
  PUSH(FP);
  MOV(FP, SP);
  PUSH(R1);
  PUSH(R2);
  PUSH(R3);
  PUSH(R4);
  PUSH(R5);
  PUSH(R6);
  PUSH(R7);

  MOV(R1, SOB_TRUE); //R1 HOLDS THE ANSWER
  MOV(R5, FPARG(NUMOFARGS)); //iterate from 2 to 2+ number of args
  ADD(R5, 2);
  MOV(R3, 2);
  MOV(R6, FPARG(R3)); // first scheme arg
  /* CHANGINY THE FIRST ARG TO BE A FRAC */
  CMP(INDD(R6, 0), T_FRACTION);
  JUMP_EQ(EQUAL_FIRST_ARGUMENT_IS_FRAC);
  MOV(R2, INDD(R6, 1));
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R6, R0);

  EQUAL_FIRST_ARGUMENT_IS_FRAC:
  ADD(R3, 1);
  CMP(R5, R3);
  JUMP_EQ(EQUAL_ONLY_ONE_ARG);

  EQUAL_LOOP:
  CMP(R5, R3);
  JUMP_EQ(EQUAL_END);
  MOV(R4, FPARG(R3)); 
  
  CMP(INDD(R4, 0), T_FRACTION);// Check if it is a fraction already:
  JUMP_EQ(EQUAL_IS_FRAC);
  MOV(R2, INDD(R4, 1)); // It is not, turn it to fraction:
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R4, R0);

  EQUAL_IS_FRAC:
  CMP(INDD(R4, 1), INDD(R6, 1));
  JUMP_NE(EQUAL_FALSE);
  CMP(INDD(R4, 2), INDD(R6, 2));
  JUMP_NE(EQUAL_FALSE);
  ADD(R3, 1);
  JUMP(EQUAL_LOOP);

  EQUAL_ONLY_ONE_ARG:
  JUMP(EQUAL_END)

  EQUAL_FALSE:
  MOV(R1, SOB_FALSE);
  EQUAL_END:
  MOV(R0, R1);

  EQUAL_RETURN_FRACTION:
  POP(R7);
  POP(R6);
  POP(R5);
  POP(R4);
  POP(R3);
  POP(R2);
  POP(R1);
  POP(FP);
RETURN;

EQUAL:
  PUSH(FP);
  MOV(FP, SP);
  PUSH(R1);
  PUSH(R2);
  PUSH(R3);
  PUSH(R4);
  PUSH(R5);
  PUSH(R6);
  PUSH(R7);

  MOV(R1, SOB_TRUE); //R1 HOLDS THE ANSWER
  MOV(R5, FPARG(NUMOFARGS)); //iterate from 2 to 2+ number of args
  ADD(R5, 2);
  MOV(R3, 2);
  MOV(R6, FPARG(R3)); // first scheme arg
  /* CHANGINY THE FIRST ARG TO BE A FRAC */
  CMP(INDD(R6, 0), T_FRACTION);
  JUMP_EQ(EQUAL_FIRST_ARGUMENT_IS_FRAC);
  MOV(R2, INDD(R6, 1));
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R6, R0);

  
  CMP(INDD(R4, 0), T_FRACTION);// Check if it is a fraction already:
  JUMP_EQ(EQUAL_IS_FRAC);
  MOV(R2, INDD(R4, 1)); // It is not, turn it to fraction:
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R4, R0);



VAR_GREATERTHAN:
  PUSH(FP);
  MOV(FP, SP);
  PUSH(R1);
  PUSH(R2);
  PUSH(R3);
  PUSH(R4);
  PUSH(R5);
  PUSH(R6);
  PUSH(R7);

  MOV(R1, SOB_TRUE); //R1 HOLDS THE ANSWER
  MOV(R5, FPARG(NUMOFARGS)); //iterate from 2 to 2+ number of args
  ADD(R5, 2);
  MOV(R3, 2);
  MOV(R6, FPARG(R3)); // first scheme arg
  /* CHANGINY THE FIRST ARG TO BE A FRAC */
  CMP(INDD(R6, 0), T_FRACTION);
  JUMP_EQ(GREATER_FIRST_ARGUMENT_IS_FRAC);
  MOV(R2, INDD(R6, 1));
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R6, R0);

  GREATER_FIRST_ARGUMENT_IS_FRAC:
  ADD(R3, 1);
  CMP(R5, R3);
  JUMP_EQ(GREATER_ONLY_ONE_ARG);

  GREATER_LOOP:
  CMP(R5, R3);
  JUMP_EQ(GREATER_END);
  MOV(R4, FPARG(R3)); 
  
  CMP(INDD(R4, 0), T_FRACTION);// Check if it is a fraction already:
  JUMP_EQ(GREATER_IS_FRAC);
  MOV(R2, INDD(R4, 1)); // It is not, turn it to fraction:
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R4, R0);

  GREATER_IS_FRAC:
  MOV(R2, INDD(R4, 1));
  MUL(R2, IMM(-1));
  PUSH(R2);
  PUSH(INDD(R4, 2));
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  PUSH(R0);
  PUSH(R6);
  CALL(SUM_FRACS);
  DROP(2);
  MOV(R2, R0);
  CMP(INDD(R2, 1), 0);
  JUMP_LE(GREATER_FALSE);
  ADD(R3, 1);
  MOV(R6, R4);
  JUMP(GREATER_LOOP);

  GREATER_ONLY_ONE_ARG:
  JUMP(GREATER_END)

  GREATER_FALSE:
  MOV(R1, SOB_FALSE);
  GREATER_END:
  MOV(R0, R1);

  GREATER_RETURN_FRACTION:
  POP(R7);
  POP(R6);
  POP(R5);
  POP(R4);
  POP(R3);
  POP(R2);
  POP(R1);
  POP(FP);
  RETURN;


VAR_LESSTHAN:
  PUSH(FP);
  MOV(FP, SP);
  PUSH(R1);
  PUSH(R2);
  PUSH(R3);
  PUSH(R4);
  PUSH(R5);
  PUSH(R6);
  PUSH(R7);

  MOV(R6, IMM(0));
  MOV(R4, IMM(0));
  MOV(R1, SOB_TRUE); //R1 HOLDS THE ANSWER
  MOV(R5, FPARG(NUMOFARGS)); //iterate from 2 to 2+ number of args
  ADD(R5, 2);
  MOV(R3, 2);
  MOV(R6, FPARG(R3)); // first scheme arg
  /* CHANGINY THE FIRST ARG TO BE A FRAC */
  CMP(INDD(R6, 0), T_FRACTION);
  JUMP_EQ(LOWER_FIRST_ARGUMENT_IS_FRAC);
  MOV(R2, INDD(R6, 1));
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R6, R0);

  LOWER_FIRST_ARGUMENT_IS_FRAC:
  ADD(R3, 1);
  CMP(R5, R3);
  JUMP_EQ(LOWER_ONLY_ONE_ARG);

  LOWER_LOOP:
  CMP(R5, R3);
  JUMP_EQ(LOWER_END);
  MOV(R4, FPARG(R3)); 
  CMP(INDD(R4, 0), T_FRACTION);// Check if it is a fraction already:
  JUMP_EQ(LOWER_IS_FRAC);
  MOV(R2, INDD(R4, 1)); // It is not, turn it to fraction:
  PUSH(R2);
  PUSH(1);
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  MOV(R4, R0);

  LOWER_IS_FRAC:
  MOV(R2, INDD(R4, 1));
  MUL(R2, IMM(-1));
  PUSH(R2);
  PUSH(INDD(R4, 2));
  CALL(MAKE_SOB_FRACTION);
  DROP(2);
  PUSH(R0);
  PUSH(R6);
  CALL(SUM_FRACS);
  DROP(2);
  MOV(R2, R0);
  CMP(INDD(R2, 1), 0);

  JUMP_GE(LOWER_FALSE);
  ADD(R3, 1);
  MOV(R6, R4);
  JUMP(LOWER_LOOP);

  LOWER_ONLY_ONE_ARG:
  JUMP(LOWER_END)

  LOWER_FALSE:
  MOV(R1, SOB_FALSE);
  LOWER_END:
  MOV(R0, R1);

  LOWER_RETURN_FRACTION:
  POP(R7);
  POP(R6);
  POP(R5);
  POP(R4);
  POP(R3);
  POP(R2);
  POP(R1);
  POP(FP);
RETURN;



	
CONVERTERS:

CHAR_TO_INT:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R2, INDD(R1, 1));
	PUSH(R2);
	CALL(MAKE_SOB_INTEGER);
	DROP(1);
	POP(R2);
	POP(R1);
	JUMP(END);

INT_TO_CHAR:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R2, INDD(R1, 1));
	PUSH(R2);
	CALL(MAKE_SOB_CHAR);
	DROP(1);
	POP(R2);
	POP(R1);
	JUMP(END);


REMAINDER:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1,0);
	MOV(R1, FPARG(2));
	MOV(R1, INDD(R1, 1));
	MOV(R2, FPARG(3));
	MOV(R2, INDD(R2, 1));
	REM(R1, R2);
	PUSH(R1);
	CALL(MAKE_SOB_INTEGER);
	DROP(1);
	POP(R2);
	POP(R1);
	JUMP(END);
	
STRINGS:

STR_LENGTH:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R2, INDD(R1, 1));
	PUSH(R2);
	CALL(MAKE_SOB_INTEGER);
	DROP(1);
	POP(R2);
	POP(R1);
	JUMP(END);

STR_REF:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R2, FPARG(3));
	MOV(R2, INDD(R2, 1));
	ADD(R2, 2);
	MOV(R1, INDD(R1, R2));
	PUSH(R1);
	CALL(MAKE_SOB_CHAR);
	DROP(1);
	POP(R2);
	POP(R1);
	JUMP(END);
		

STR_SET:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R2, FPARG(3));
	MOV(R3, FPARG(4));
	MOV(R2, INDD(R2, 1));
	MOV(R3, INDD(R3, 1));
	ADD(R2, 2);
	MOV(INDD(R1, R2), R3);
	MOV(R0, SOB_VOID);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(END);	

MAKE_STRING:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R5);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2)); 
	MOV(R1, INDD(R1, 1));
	MOV(R5, FPARG(NUMOFARGS));
	CMP(R5, 1);
	JUMP_EQ(MAKE_STRING_CHAR0);
	MOV(R2, FPARG(3));
	MOV(R2, INDD(R2, 1));
	JUMP(MAKE_STRING_ARG2);
MAKE_STRING_CHAR0:
	PUSH(0);
	CALL(MAKE_SOB_CHAR);
	DROP(1); 
	MOV(R2, R0);	
MAKE_STRING_ARG2:
	MOV(R5, 0);
MAKE_STRING_PUSH_LOOP:
	CMP(R5, R1);
	JUMP_EQ(MAKE_STRING_AFTER_PUSH);
	PUSH(R2);
	ADD(R5, 1);
	JUMP(MAKE_STRING_PUSH_LOOP);
MAKE_STRING_AFTER_PUSH:
	PUSH(R1);
	CALL(MAKE_SOB_STRING);
	POP(R1);
	DROP(R1);
	POP(R5);
	POP(R2);
	POP(R1);
	JUMP(END);
	

VECTORS:

VEC_LENGTH:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R2, INDD(R1, 1));
	PUSH(R2);
	CALL(MAKE_SOB_INTEGER);
	DROP(1);
	POP(R2);
	POP(R1);
	JUMP(END);

VEC_REF:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R2, FPARG(3));
	MOV(R2, INDD(R2, 1));
	ADD(R2, 2);
	MOV(R1, INDD(R1, R2));
	MOV(R0, R1);
	POP(R2);
	POP(R1);
	JUMP(END);
		

VEC_SET:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R2, FPARG(3));
	MOV(R3, FPARG(4));
	MOV(R2, INDD(R2, 1));
	ADD(R2, 2);
	MOV(INDD(R1, R2), R3);
	MOV(R0, SOB_VOID);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(END);

VECTOR:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R5);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(NUMOFARGS));
	MOV(R5, 0);	
	MOV(R2, 2);
PUSH_VEC_ARGS:
	CMP(R5, R1);
	JUMP_EQ(VECTOR_AFTER_PUSH_ARGS);
	MOV(R3, FPARG(R2));
	PUSH(R3);
	ADD(R5, 1);
	ADD(R2, 1);
	JUMP(PUSH_VEC_ARGS);
VECTOR_AFTER_PUSH_ARGS:
	PUSH(R1);
	CALL(MAKE_SOB_VECTOR);
	POP(R1);
	DROP(R1);
	POP(R5);
	POP(R2);
	POP(R1);
	JUMP(END);	

	
MAKE_VECTOR:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R5);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2)); 
	MOV(R1, INDD(R1, 1));
	MOV(R5, FPARG(NUMOFARGS));
	CMP(R5, 1);
	JUMP_EQ(MAKE_VECTOR_CHAR0);
	MOV(R2, FPARG(3));
	JUMP(MAKE_VECTOR_ARG2);
MAKE_VECTOR_CHAR0:
	PUSH(0);
	CALL(MAKE_SOB_INTEGER);
	DROP(1); 
	MOV(R2, R0);	
MAKE_VECTOR_ARG2:
	MOV(R5, 0);
MAKE_VECTOR_PUSH_LOOP:
	CMP(R5, R1);
	JUMP_EQ(MAKE_VECTOR_AFTER_PUSH);
	PUSH(R2);
	ADD(R5, 1);
	JUMP(MAKE_VECTOR_PUSH_LOOP);
MAKE_VECTOR_AFTER_PUSH:
	PUSH(R1);
	CALL(MAKE_SOB_VECTOR);
	POP(R1);
	DROP(R1);
	POP(R5);
	POP(R2);
	POP(R1);
	JUMP(END);

	
PAIRS:

CONS:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R2, FPARG(3));
	PUSH(R2);
	PUSH(R1);
	CALL(MAKE_SOB_PAIR);
	DROP(2);
	POP(R2);
	POP(R1);
	JUMP(END);

CAR:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R1, INDD(R1, 1));
	MOV(R0, R1);
	POP(R2);
	POP(R1);
	JUMP(END);

CDR:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R1, INDD(R1, 2));
	MOV(R0, R1);
	POP(R2);
	POP(R1);
	JUMP(END);

SET_CAR:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R2, FPARG(3));
	MOV(INDD(R1, 1), R2);
	MOV(R0, SOB_VOID);
	POP(R2);
	POP(R1);
	JUMP(END);


SET_CDR:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, FPARG(2));
	MOV(R2, FPARG(3));
	MOV(INDD(R1, 2), R2);
	MOV(R0, SOB_VOID);
	POP(R2);
	POP(R1);
	JUMP(END);

LISTS:

LIST:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R5);
	PUSH(R6);
	PUSH(R7);
	PUSH(R8);
	PUSH(R10);
	PUSH(R11);
	MOV(R5, 0);
	MOV(R5, FPARG(NUMOFARGS)); 
	MOV(R6, 0);	
	MOV(R7, 2);
	CMP(0, R5);
	JUMP_NE(LIST_CREATE_NODES);	
	PUSH(1);
	CALL(MALLOC);
	DROP(1);
	MOV(R0, SOB_NIL);
	JUMP(LIST_END);
LIST_CREATE_NODES:
	CMP(R5, R6);
	JUMP_EQ(LIST_LAST_ELEMENT);
	PUSH(3);
	CALL(MALLOC);
	DROP(1);
	MOV(R10, R0);
	MOV(INDD(R10, 0), T_PAIR);
	MOV(INDD(R10, 1), FPARG(R7));
	CMP(R6, 0);
	JUMP_EQ(LIST_FIRST);
	MOV(INDD(R11, 2), R10);
	JUMP(LIST_CONTINUE);
LIST_FIRST:
	MOV(R8, R10);
LIST_CONTINUE:
	MOV(R11, R10);
	ADD(R6, 1);
	ADD(R7, 1);
	JUMP(LIST_CREATE_NODES);
LIST_LAST_ELEMENT:
	MOV(INDD(R11, 2), SOB_NIL);
	MOV(R0, R8);
LIST_END:
	POP(R11);
	POP(R10);
	POP(R8);
	POP(R7);
	POP(R6);
	POP(R5);
	JUMP(END);
	

LIST_LENGTH:
	PUSH(FP);
	MOV(FP,SP);
	PUSH(R1);
	PUSH(R2);
	MOV(R1, 0);
	MOV(R2, 0);	
	MOV(R1, IMM(0));
	MOV(R2, FPARG(0));
LIST_LENGTH_LOOP:
	CMP(INDD(R2, 0), T_NIL);
	JUMP_EQ(LIST_LENGTH_END_LOOP);
	ADD(R1, 1);
	MOV(R2, INDD(R2, 2));
	JUMP(LIST_LENGTH_LOOP);
LIST_LENGTH_END_LOOP:
	MOV(R0, R1);
	POP(R2);   
	POP(R1);   
	JUMP(END);


LIST_REF:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	MOV(R1, 0);
	MOV(R2, 0);
	MOV(R1, FPARG(0));
	MOV(R2, FPARG(1));
	MOV(R3, 0);
LIST_REF_LOOP:
	CMP(R3, R1);
	JUMP_EQ(LIST_REF_END);
	MOV(R2, INDD(R2, 2));
	ADD(R3, 1);
	JUMP(LIST_REF_LOOP);
LIST_REF_END:
	MOV(R0, R2);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(END);




SYMBOL_TO_STR:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R2);
	MOV(R2, 0);	
	MOV(R2, FPARG(2));
	MOV(R2, INDD(R2, 1));
	MOV(R2, INDD(R2, 0));
	MOV(R0, R2);
	POP(R2);
	JUMP(END);	
	
MATCH_STRS:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	PUSH(R4);
	PUSH(R5);
	MOV(R1, 0);
	MOV(R2, 0);
	MOV(R1, FPARG(0));	
	MOV(R2, FPARG(1));	
	MOV(R3, INDD(R1, 1)); 
	MOV(R4, INDD(R2, 1));	
	CMP(R3, R4);
	JUMP_NE(MATCH_STRS_FAIL);
	MOV(R4, 0);
MATCH_STRS_LOOP:
	CMP(R4, R3);
	JUMP_EQ(MATCH_STRS_LOOP_END);
	MOV(R5, 2);
	ADD(R5, R4);
	CMP(INDD(R1, R5), INDD(R2, R5));
	JUMP_NE(MATCH_STRS_FAIL);  
	ADD(R4, 1);
	ADD(R5, 1);	
	JUMP(MATCH_STRS_LOOP);
MATCH_STRS_LOOP_END:
	MOV(R0, 1);
	JUMP(MATCH_STRS_END);
MATCH_STRS_FAIL:
	MOV(R0, 0);
	JUMP(MATCH_STRS_END);
MATCH_STRS_END:
	POP(R5);
	POP(R4);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(END);

CHK_SYM_THERE:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	PUSH(R4);
	PUSH(R5);
  MOV(R1, 0);
  MOV(R2, 0);
	MOV(R1, SYM_TAB_START);
	MOV(R2, FPARG(0));
CHK_SYM_LOOP:		
	MOV(R3, INDD(R1, 1));
	MOV(R4, INDD(R3, 0));
	PUSH(R4);
	PUSH(R2);
	CALL(MATCH_STRS);
	DROP(2);
	CMP(R0, 1);
	JUMP_EQ(CHK_SYM_HAS);
	CMP(INDD(R1, 2), SOB_NIL);
	JUMP_EQ(CHK_SYM_NOT_THERE);
	MOV(R1, INDD(R1, 2));
	JUMP(CHK_SYM_LOOP);
CHK_SYM_HAS:
	MOV(R0, R3);
	JUMP(CHK_SYM_END);	
CHK_SYM_NOT_THERE:
	MOV(R0, 0);	
	JUMP(CHK_SYM_END);
CHK_SYM_END:
	POP(R5);
	POP(R4);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(END);
		
MAKE_SOB_SYMBOL:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	PUSH(R4);
	PUSH(R5);		
	MOV(R1, 0);
	MOV(R2, 0);
	MOV(R1, FPARG(0));
	PUSH(R1);
	CALL(CHK_SYM_THERE);
	POP(R1);
	CMP(R0, 0);
	JUMP_NE(BUCK_R0);
	PUSH(2);
	CALL(MALLOC);
	DROP(1);
	MOV(INDD(R0, 0), R1);
	MOV(INDD(R0, 1), 0);
BUCK_R0:
	MOV(R2, R0);
	PUSH(3);
	CALL(MALLOC);
	DROP(1);
	MOV(INDD(R0, 0), T_SYMBOL);
	MOV(INDD(R0, 1), R2);	
	MOV(INDD(R0, 2), SOB_NIL);
	MOV(R3, R0);
	MOV(R4, SYM_TAB_START);		
INSERT_NODE_LOOP:
	CMP(INDD(R4, 2), SOB_NIL);
	JUMP_EQ(FOUND_LAST);
	MOV(R4, INDD(R4, 2));		
	JUMP(INSERT_NODE_LOOP);
FOUND_LAST:
	MOV(INDD(R4, 2), R3);
	JUMP(MAKE_SOB_SYMBOL_END);
	MOV(R0, R3);
MAKE_SOB_SYMBOL_END:
	POP(R5);
	POP(R4);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(END);

STR_TO_SYMBOL:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	PUSH(R4);
	PUSH(R5);	
	MOV(R1, 0);
	MOV(R2, 0);		
	MOV(R1, FPARG(2));
	PUSH(R1);
	CALL(MAKE_SOB_SYMBOL);
	POP(R1);
	JUMP(STR_TO_SYMBOL_END);
STR_TO_SYMBOL_END:
	POP(R5);
	POP(R4);
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(END);

WRITE_SOB_SYMBOL:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	MOV(R1, 0); 
	MOV(R2, 0);	
	MOV(R0, FPARG(0)); //first arg
	MOV(R0, INDD(R0, 1));
	MOV(R0, INDD(R0, 0));
	MOV(R1, INDD(R0, 1));
	MOV(R2, R0);
	ADD(R2, IMM(2));
 WSS_LOOP_SYMBOL:
	CMP(R1, IMM(0));
	JUMP_EQ(WSS_EXIT_SYMBOL);
	CMP(IND(R2), '\n');
	JUMP_EQ(WSS_NEWLINE_SYMBOL);
	CMP(IND(R2), '\t');
	JUMP_EQ(WSS_TAB_SYMBOL);
	CMP(IND(R2), '\f');
	JUMP_EQ(WSS_PAGE_SYMBOL);
	CMP(IND(R2), '\r');
	JUMP_EQ(WSS_RETURN_SYMBOL);
	CMP(IND(R2), '\\');
	JUMP_EQ(WSS_BACKSLASH_SYMBOL);
	CMP(IND(R2), '\"');
	JUMP_EQ(WSS_DQUOTE_SYMBOL);
	CMP(IND(R2), ' ');
	JUMP_LT(WSS_OCT_CHAR_SYMBOL);
	PUSH(IND(R2));
	CALL(PUTCHAR);
	DROP(1);
	JUMP(WSS_LOOP_CONT_SYMBOL);
 WSS_DQUOTE_SYMBOL:
	PUSH(IMM('\\'));
	CALL(PUTCHAR);
	PUSH(IMM('\"'));
	CALL(PUTCHAR);
	DROP(2);
	JUMP(WSS_LOOP_CONT_SYMBOL);
 WSS_BACKSLASH_SYMBOL:
	PUSH(IMM('\\'));
	CALL(PUTCHAR);
	PUSH(IMM('\\'));
	CALL(PUTCHAR);
	DROP(2);
	JUMP(WSS_LOOP_CONT_SYMBOL);
 WSS_RETURN_SYMBOL:
	PUSH(IMM('\\'));
	CALL(PUTCHAR);
	PUSH(IMM('r'));
	CALL(PUTCHAR);
	DROP(2);
	JUMP(WSS_LOOP_CONT_SYMBOL);
 WSS_PAGE_SYMBOL:
	PUSH(IMM('\\'));
	CALL(PUTCHAR);
	PUSH(IMM('f'));
	CALL(PUTCHAR);
	DROP(2);
	JUMP(WSS_LOOP_CONT_SYMBOL);
 WSS_TAB_SYMBOL:
	PUSH(IMM('\\'));
	CALL(PUTCHAR);
	PUSH(IMM('t'));
	CALL(PUTCHAR);
	DROP(2);
	JUMP(WSS_LOOP_CONT_SYMBOL);  
 WSS_NEWLINE_SYMBOL:
	PUSH(IMM('\\'));
	CALL(PUTCHAR);
	PUSH(IMM('n'));
	CALL(PUTCHAR);
	DROP(2);
	JUMP(WSS_LOOP_CONT_SYMBOL);
 WSS_OCT_CHAR_SYMBOL:
	MOV(R0, IND(R2));
	MOV(R3, R0);
	REM(R3, IMM(8));
	PUSH(R3);
	DIV(R0, IMM(8));
	MOV(R3, R0);
	REM(R3, IMM(8));
	PUSH(R3);
	DIV(R0, IMM(8));
	REM(R0, IMM(8));
	PUSH(R0);
	PUSH(IMM('\\'));
	CALL(PUTCHAR);
	DROP(1);
	CALL(WRITE_INTEGER);
	DROP(1);
	CALL(WRITE_INTEGER);
	DROP(1);
	CALL(WRITE_INTEGER);
	DROP(1);
 WSS_LOOP_CONT_SYMBOL:
	INCR(R2);
	DECR(R1);
	JUMP(WSS_LOOP_SYMBOL);
 WSS_EXIT_SYMBOL:
	POP(R3);
	POP(R2);
	POP(R1);
	JUMP(END);
  

EQ:
  PUSH(FP);
  MOV(FP, SP);
  PUSH(R1);
  PUSH(R2);
  PUSH(R3);
  PUSH(R4);
  PUSH(R5);
  MOV(R1 , 0);
  MOV(R2, 0);
  MOV(R1, FPARG(2)); //get Arg 1
  MOV(R2, FPARG(3)); //get Arg 2
  CMP(IND(R1),IND(R2));
  JUMP_NE(EQ_NOT_MATCHING_TYPE);
  CMP(IND(R1),T_SYMBOL);
  JUMP_EQ(CHK_EQ_SYMBOL);
  CMP(IND(R1),T_INTEGER);
  JUMP_EQ(CHK_EQ_SINGLE);
  //ADDED FRACTION SUPPORT
  CMP(IND(R1),T_FRACTION);
  JUMP_EQ(CHK_EQ_FRACTION);
  CMP(IND(R1),T_CHAR);
  JUMP_EQ(CHK_EQ_SINGLE);
  CMP(IND(R1),T_VOID);
  JUMP_EQ(CHK_EQ_ADDR);
  CMP(IND(R1),T_NIL);
  JUMP_EQ(CHK_EQ_ADDR);
  CMP(IND(R1),T_NIL);
  JUMP_EQ(CHK_EQ_ADDR);
  CMP(IND(R1),T_BOOL);
  JUMP_EQ(CHK_EQ_BOOLEAN);
  CMP(IND(R1),T_STRING);
  JUMP_EQ(CHK_EQ_BOOLEAN);
  CMP(IND(R1),T_VECTOR);
  JUMP_EQ(CHK_EQ_BOOLEAN);
  CMP(IND(R1),T_PAIR);
  JUMP_EQ(CHK_EQ_BOOLEAN);
CHK_EQ_BOOLEAN:
  CMP(R1,R2);  
  JUMP_NE(EQ_NOT_MATCHING_TYPE);
  MOV(R0,SOB_TRUE);
  JUMP(CHK_EQ_END);
CHK_EQ_ADDR:
  MOV(R0,SOB_TRUE);
  JUMP(CHK_EQ_END);
CHK_EQ_FRACTION:
  CMP(INDD(R1,1),INDD(R2,1));
  JUMP_NE(EQ_NOT_MATCHING_TYPE);
  CMP(INDD(R1,2),INDD(R2,2));
  JUMP_NE(EQ_NOT_MATCHING_TYPE);
  MOV(R0,SOB_TRUE);
  JUMP(CHK_EQ_END);
CHK_EQ_SYMBOL:
  CMP(INDD(R1,1),INDD(R2,1));
  JUMP_NE(CHK_EQ_SYMBOL2);
  MOV(R0,SOB_TRUE);
  JUMP(CHK_EQ_END);
CHK_EQ_SYMBOL2:
  MOV(R1,INDD(R1,1));  
  MOV(R2,INDD(R2,1));
  MOV(R3,INDD(R1,0));  
  MOV(R4,INDD(R2,0));
  CMP(R3,R4);
  JUMP_NE(EQ_NOT_MATCHING_TYPE);
  MOV(R5,IMM(0));
  ADD(R1,IMM(2));
  ADD(R2,IMM(2));
CHK_EQ_SYMBOL_LOOP:
  CMP(R5,R4);
  JUMP_EQ(SYM_EQ_TRUE);
  CMP(INDD(R1,R5),INDD(R2,R5));
  JUMP_NE(EQ_NOT_MATCHING_TYPE);
  INCR(R5);
  JUMP(CHK_EQ_SYMBOL_LOOP);
CHK_EQ_SINGLE:
  CMP(INDD(R1,1),INDD(R2,1));
  JUMP_NE(EQ_NOT_MATCHING_TYPE);
  MOV(R0,SOB_TRUE);
  JUMP(CHK_EQ_END);
EQ_NOT_MATCHING_TYPE:
  MOV(R0,SOB_FALSE);
  JUMP(CHK_EQ_END);
SYM_EQ_TRUE:
  MOV(R0,SOB_TRUE);
  JUMP(CHK_EQ_END);  
CHK_EQ_END:
  POP(R5);
  POP(R4);
  POP(R3);
  POP(R2);
  POP(R1);
  POP(FP);
  RETURN;


APPLY:
	PUSH(FP);
	MOV(FP,SP);
	MOV(R0, IMM(0)); 
	MOV(R12, FPARG(2)); //get Arg 1
	MOV(R13, FPARG(3)); //get Arg 2
	MOV(R14, FPARG(-1));
	MOV(R8, IMM(0));
	MOV(R9, IMM(1));
	PUSH(R13);
	CALL(LIST_LENGTH);
	DROP(1);
	MOV(R8, 0);
	MOV(R8, R0);
CHANGE_STACK:
	POP(FP);
	SUB(SP, IMM(5));
	ADD(SP, IMM(3));
	ADD(SP, R8);
	PUSH(FP);
	MOV(FP,SP);
	MOV(FPARG(-1), R14);
	MOV(FPARG(0), INDD(R12, 1));
	MOV(FPARG(1), R8);
	MOV(R8, IMM(2));
PUSH_ARGS:
	CMP(INDD(R13, 0), T_NIL);
	JUMP_EQ(CONT);
	MOV(FPARG(R8), INDD(R13, 1)); 
	MOV(R13, INDD(R13, 2));   
	INCR(R8);
	JUMP(PUSH_ARGS);
CONT:
	POP(FP);
	JUMPA(INDD(R12, 2));  
GET_ARG_FROM_LST:
	PUSH(FP);
	MOV(FP, SP);
	PUSH(R1);
	PUSH(R2);
	PUSH(R3);
	MOV(R1, FPARG(0)); 
	MOV(R2, FPARG(1));
	MOV(R3, IMM(0));
GET_ARG_FROM_LST_LOOP:
	CMP(R3, R1);
	JUMP_EQ(GET_ARG_FROM_LST_END);
	MOV(R2, INDD(R2, 2));
	ADD(R3, IMM(1));
	JUMP(GET_ARG_FROM_LST_LOOP);
GET_ARG_FROM_LST_END:
  MOV(R0, INDD(R2, 1));
  POP(R3);
  POP(R2);
  POP(R1);
  JUMP(END);

  
NOT:
  PUSH(FP);
  MOV(FP, SP);
  PUSH(R1);
  MOV(R1, 0);
  MOV(R1, FPARG(2)); //get arg 1
  CMP(INDD(R1, 0), T_BOOL);
  JUMP_NE(NOT_RETURN_FALSE);
  CMP(R1, IMM(SOB_FALSE));
  JUMP_EQ(NOT_RETURN_TRUE);

RETURNS:

NOT_RETURN_FALSE:  
  MOV(R0,IMM(SOB_FALSE));
  JUMP(NOT_END_YET);
NOT_RETURN_TRUE:
  MOV(R0,IMM(SOB_TRUE));
NOT_END_YET:
  POP(R1);
  POP(FP);
  RETURN;

RETURN_TRUE:
  MOV(R0, SOB_TRUE);
  JUMP(END);

PRINT_R0_VALUE:
  PUSH(FP);
  MOV(FP, SP);
  MOV(R1,0)
  CMP(R0, SOB_VOID);
  JUMP_EQ(END);
  PUSH(R0);
  CALL(WRITE_SOB);
  DROP(IMM(1));
    PUSH('\n'); 
    CALL(PUTCHAR);
    DROP(IMM(1));

PRINT_END:
  JUMP(END);


END:
 	POP(FP);
	RETURN;
